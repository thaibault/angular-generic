<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: index.compiled.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: index.compiled.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';
var index =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module &amp;&amp; module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 3);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_0__;

/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_1__;

/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_2__;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(4);
__webpack_require__(5);
module.exports = __webpack_require__(10);


/***/ }),
/* 4 */
/***/ (function(module, exports) {

/*! *****************************************************************************
Copyright (C) Microsoft. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var Reflect;
(function (Reflect) {
    "use strict";
    var hasOwn = Object.prototype.hasOwnProperty;
    // feature test for Symbol support
    var supportsSymbol = typeof Symbol === "function";
    var toPrimitiveSymbol = supportsSymbol &amp;&amp; typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
    var iteratorSymbol = supportsSymbol &amp;&amp; typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
    var HashMap;
    (function (HashMap) {
        var supportsCreate = typeof Object.create === "function"; // feature test for Object.create support
        var supportsProto = { __proto__: [] } instanceof Array; // feature test for __proto__ support
        var downLevel = !supportsCreate &amp;&amp; !supportsProto;
        // create an object in dictionary mode (a.k.a. "slow" mode in v8)
        HashMap.create = supportsCreate
            ? function () { return MakeDictionary(Object.create(null)); }
            : supportsProto
                ? function () { return MakeDictionary({ __proto__: null }); }
                : function () { return MakeDictionary({}); };
        HashMap.has = downLevel
            ? function (map, key) { return hasOwn.call(map, key); }
            : function (map, key) { return key in map; };
        HashMap.get = downLevel
            ? function (map, key) { return hasOwn.call(map, key) ? map[key] : undefined; }
            : function (map, key) { return map[key]; };
    })(HashMap || (HashMap = {}));
    // Load global or shim versions of Map, Set, and WeakMap
    var functionPrototype = Object.getPrototypeOf(Function);
    var usePolyfill = typeof process === "object" &amp;&amp; process.env &amp;&amp; process.env["REFLECT_METADATA_USE_MAP_POLYFILL"] === "true";
    var _Map = !usePolyfill &amp;&amp; typeof Map === "function" &amp;&amp; typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
    var _Set = !usePolyfill &amp;&amp; typeof Set === "function" &amp;&amp; typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
    var _WeakMap = !usePolyfill &amp;&amp; typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
    // [[Metadata]] internal slot
    // https://rbuckton.github.io/reflect-metadata/#ordinary-object-internal-methods-and-internal-slots
    var Metadata = new _WeakMap();
    /**
      * Applies a set of decorators to a property of a target object.
      * @param decorators An array of decorators.
      * @param target The target object.
      * @param propertyKey (Optional) The property key to decorate.
      * @param attributes (Optional) The property descriptor for the target key.
      * @remarks Decorators are applied in reverse order.
      * @example
      *
      *     class Example {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     Example = Reflect.decorate(decoratorsArray, Example);
      *
      *     // property (on constructor)
      *     Reflect.decorate(decoratorsArray, Example, "staticProperty");
      *
      *     // property (on prototype)
      *     Reflect.decorate(decoratorsArray, Example.prototype, "property");
      *
      *     // method (on constructor)
      *     Object.defineProperty(Example, "staticMethod",
      *         Reflect.decorate(decoratorsArray, Example, "staticMethod",
      *             Object.getOwnPropertyDescriptor(Example, "staticMethod")));
      *
      *     // method (on prototype)
      *     Object.defineProperty(Example.prototype, "method",
      *         Reflect.decorate(decoratorsArray, Example.prototype, "method",
      *             Object.getOwnPropertyDescriptor(Example.prototype, "method")));
      *
      */
    function decorate(decorators, target, propertyKey, attributes) {
        if (!IsUndefined(propertyKey)) {
            if (!IsArray(decorators))
                throw new TypeError();
            if (!IsObject(target))
                throw new TypeError();
            if (!IsObject(attributes) &amp;&amp; !IsUndefined(attributes) &amp;&amp; !IsNull(attributes))
                throw new TypeError();
            if (IsNull(attributes))
                attributes = undefined;
            propertyKey = ToPropertyKey(propertyKey);
            return DecorateProperty(decorators, target, propertyKey, attributes);
        }
        else {
            if (!IsArray(decorators))
                throw new TypeError();
            if (!IsConstructor(target))
                throw new TypeError();
            return DecorateConstructor(decorators, target);
        }
    }
    Reflect.decorate = decorate;
    // 4.1.2 Reflect.metadata(metadataKey, metadataValue)
    // https://rbuckton.github.io/reflect-metadata/#reflect.metadata
    /**
      * A default metadata decorator factory that can be used on a class, class member, or parameter.
      * @param metadataKey The key for the metadata entry.
      * @param metadataValue The value for the metadata entry.
      * @returns A decorator function.
      * @remarks
      * If `metadataKey` is already defined for the target and target key, the
      * metadataValue for that key will be overwritten.
      * @example
      *
      *     // constructor
      *     @Reflect.metadata(key, value)
      *     class Example {
      *     }
      *
      *     // property (on constructor, TypeScript only)
      *     class Example {
      *         @Reflect.metadata(key, value)
      *         static staticProperty;
      *     }
      *
      *     // property (on prototype, TypeScript only)
      *     class Example {
      *         @Reflect.metadata(key, value)
      *         property;
      *     }
      *
      *     // method (on constructor)
      *     class Example {
      *         @Reflect.metadata(key, value)
      *         static staticMethod() { }
      *     }
      *
      *     // method (on prototype)
      *     class Example {
      *         @Reflect.metadata(key, value)
      *         method() { }
      *     }
      *
      */
    function metadata(metadataKey, metadataValue) {
        function decorator(target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey) &amp;&amp; !IsPropertyKey(propertyKey))
                throw new TypeError();
            OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
        }
        return decorator;
    }
    Reflect.metadata = metadata;
    /**
      * Define a unique metadata entry on the target.
      * @param metadataKey A key used to store and retrieve metadata.
      * @param metadataValue A value that contains attached metadata.
      * @param target The target object on which to define metadata.
      * @param propertyKey (Optional) The property key for the target.
      * @example
      *
      *     class Example {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     Reflect.defineMetadata("custom:annotation", options, Example);
      *
      *     // property (on constructor)
      *     Reflect.defineMetadata("custom:annotation", options, Example, "staticProperty");
      *
      *     // property (on prototype)
      *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "property");
      *
      *     // method (on constructor)
      *     Reflect.defineMetadata("custom:annotation", options, Example, "staticMethod");
      *
      *     // method (on prototype)
      *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "method");
      *
      *     // decorator factory as metadata-producing annotation.
      *     function MyAnnotation(options): Decorator {
      *         return (target, key?) => Reflect.defineMetadata("custom:annotation", options, target, key);
      *     }
      *
      */
    function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
        if (!IsObject(target))
            throw new TypeError();
        if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
    }
    Reflect.defineMetadata = defineMetadata;
    /**
      * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.
      * @param metadataKey A key used to store and retrieve metadata.
      * @param target The target object on which the metadata is defined.
      * @param propertyKey (Optional) The property key for the target.
      * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.
      * @example
      *
      *     class Example {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     result = Reflect.hasMetadata("custom:annotation", Example);
      *
      *     // property (on constructor)
      *     result = Reflect.hasMetadata("custom:annotation", Example, "staticProperty");
      *
      *     // property (on prototype)
      *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "property");
      *
      *     // method (on constructor)
      *     result = Reflect.hasMetadata("custom:annotation", Example, "staticMethod");
      *
      *     // method (on prototype)
      *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "method");
      *
      */
    function hasMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target))
            throw new TypeError();
        if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryHasMetadata(metadataKey, target, propertyKey);
    }
    Reflect.hasMetadata = hasMetadata;
    /**
      * Gets a value indicating whether the target object has the provided metadata key defined.
      * @param metadataKey A key used to store and retrieve metadata.
      * @param target The target object on which the metadata is defined.
      * @param propertyKey (Optional) The property key for the target.
      * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.
      * @example
      *
      *     class Example {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     result = Reflect.hasOwnMetadata("custom:annotation", Example);
      *
      *     // property (on constructor)
      *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticProperty");
      *
      *     // property (on prototype)
      *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "property");
      *
      *     // method (on constructor)
      *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticMethod");
      *
      *     // method (on prototype)
      *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "method");
      *
      */
    function hasOwnMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target))
            throw new TypeError();
        if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
    }
    Reflect.hasOwnMetadata = hasOwnMetadata;
    /**
      * Gets the metadata value for the provided metadata key on the target object or its prototype chain.
      * @param metadataKey A key used to store and retrieve metadata.
      * @param target The target object on which the metadata is defined.
      * @param propertyKey (Optional) The property key for the target.
      * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
      * @example
      *
      *     class Example {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     result = Reflect.getMetadata("custom:annotation", Example);
      *
      *     // property (on constructor)
      *     result = Reflect.getMetadata("custom:annotation", Example, "staticProperty");
      *
      *     // property (on prototype)
      *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "property");
      *
      *     // method (on constructor)
      *     result = Reflect.getMetadata("custom:annotation", Example, "staticMethod");
      *
      *     // method (on prototype)
      *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "method");
      *
      */
    function getMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target))
            throw new TypeError();
        if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryGetMetadata(metadataKey, target, propertyKey);
    }
    Reflect.getMetadata = getMetadata;
    /**
      * Gets the metadata value for the provided metadata key on the target object.
      * @param metadataKey A key used to store and retrieve metadata.
      * @param target The target object on which the metadata is defined.
      * @param propertyKey (Optional) The property key for the target.
      * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
      * @example
      *
      *     class Example {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     result = Reflect.getOwnMetadata("custom:annotation", Example);
      *
      *     // property (on constructor)
      *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticProperty");
      *
      *     // property (on prototype)
      *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "property");
      *
      *     // method (on constructor)
      *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticMethod");
      *
      *     // method (on prototype)
      *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "method");
      *
      */
    function getOwnMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target))
            throw new TypeError();
        if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
    }
    Reflect.getOwnMetadata = getOwnMetadata;
    /**
      * Gets the metadata keys defined on the target object or its prototype chain.
      * @param target The target object on which the metadata is defined.
      * @param propertyKey (Optional) The property key for the target.
      * @returns An array of unique metadata keys.
      * @example
      *
      *     class Example {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     result = Reflect.getMetadataKeys(Example);
      *
      *     // property (on constructor)
      *     result = Reflect.getMetadataKeys(Example, "staticProperty");
      *
      *     // property (on prototype)
      *     result = Reflect.getMetadataKeys(Example.prototype, "property");
      *
      *     // method (on constructor)
      *     result = Reflect.getMetadataKeys(Example, "staticMethod");
      *
      *     // method (on prototype)
      *     result = Reflect.getMetadataKeys(Example.prototype, "method");
      *
      */
    function getMetadataKeys(target, propertyKey) {
        if (!IsObject(target))
            throw new TypeError();
        if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryMetadataKeys(target, propertyKey);
    }
    Reflect.getMetadataKeys = getMetadataKeys;
    /**
      * Gets the unique metadata keys defined on the target object.
      * @param target The target object on which the metadata is defined.
      * @param propertyKey (Optional) The property key for the target.
      * @returns An array of unique metadata keys.
      * @example
      *
      *     class Example {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     result = Reflect.getOwnMetadataKeys(Example);
      *
      *     // property (on constructor)
      *     result = Reflect.getOwnMetadataKeys(Example, "staticProperty");
      *
      *     // property (on prototype)
      *     result = Reflect.getOwnMetadataKeys(Example.prototype, "property");
      *
      *     // method (on constructor)
      *     result = Reflect.getOwnMetadataKeys(Example, "staticMethod");
      *
      *     // method (on prototype)
      *     result = Reflect.getOwnMetadataKeys(Example.prototype, "method");
      *
      */
    function getOwnMetadataKeys(target, propertyKey) {
        if (!IsObject(target))
            throw new TypeError();
        if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryOwnMetadataKeys(target, propertyKey);
    }
    Reflect.getOwnMetadataKeys = getOwnMetadataKeys;
    /**
      * Deletes the metadata entry from the target object with the provided key.
      * @param metadataKey A key used to store and retrieve metadata.
      * @param target The target object on which the metadata is defined.
      * @param propertyKey (Optional) The property key for the target.
      * @returns `true` if the metadata entry was found and deleted; otherwise, false.
      * @example
      *
      *     class Example {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     result = Reflect.deleteMetadata("custom:annotation", Example);
      *
      *     // property (on constructor)
      *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticProperty");
      *
      *     // property (on prototype)
      *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "property");
      *
      *     // method (on constructor)
      *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticMethod");
      *
      *     // method (on prototype)
      *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "method");
      *
      */
    function deleteMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target))
            throw new TypeError();
        if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
        var metadataMap = GetOrCreateMetadataMap(target, propertyKey, /*Create*/ false);
        if (IsUndefined(metadataMap))
            return false;
        if (!metadataMap.delete(metadataKey))
            return false;
        if (metadataMap.size > 0)
            return true;
        var targetMetadata = Metadata.get(target);
        targetMetadata.delete(propertyKey);
        if (targetMetadata.size > 0)
            return true;
        Metadata.delete(target);
        return true;
    }
    Reflect.deleteMetadata = deleteMetadata;
    function DecorateConstructor(decorators, target) {
        for (var i = decorators.length - 1; i >= 0; --i) {
            var decorator = decorators[i];
            var decorated = decorator(target);
            if (!IsUndefined(decorated) &amp;&amp; !IsNull(decorated)) {
                if (!IsConstructor(decorated))
                    throw new TypeError();
                target = decorated;
            }
        }
        return target;
    }
    function DecorateProperty(decorators, target, propertyKey, descriptor) {
        for (var i = decorators.length - 1; i >= 0; --i) {
            var decorator = decorators[i];
            var decorated = decorator(target, propertyKey, descriptor);
            if (!IsUndefined(decorated) &amp;&amp; !IsNull(decorated)) {
                if (!IsObject(decorated))
                    throw new TypeError();
                descriptor = decorated;
            }
        }
        return descriptor;
    }
    function GetOrCreateMetadataMap(O, P, Create) {
        var targetMetadata = Metadata.get(O);
        if (IsUndefined(targetMetadata)) {
            if (!Create)
                return undefined;
            targetMetadata = new _Map();
            Metadata.set(O, targetMetadata);
        }
        var metadataMap = targetMetadata.get(P);
        if (IsUndefined(metadataMap)) {
            if (!Create)
                return undefined;
            metadataMap = new _Map();
            targetMetadata.set(P, metadataMap);
        }
        return metadataMap;
    }
    // 3.1.1.1 OrdinaryHasMetadata(MetadataKey, O, P)
    // https://rbuckton.github.io/reflect-metadata/#ordinaryhasmetadata
    function OrdinaryHasMetadata(MetadataKey, O, P) {
        var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
        if (hasOwn)
            return true;
        var parent = OrdinaryGetPrototypeOf(O);
        if (!IsNull(parent))
            return OrdinaryHasMetadata(MetadataKey, parent, P);
        return false;
    }
    // 3.1.2.1 OrdinaryHasOwnMetadata(MetadataKey, O, P)
    // https://rbuckton.github.io/reflect-metadata/#ordinaryhasownmetadata
    function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
        var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
        if (IsUndefined(metadataMap))
            return false;
        return ToBoolean(metadataMap.has(MetadataKey));
    }
    // 3.1.3.1 OrdinaryGetMetadata(MetadataKey, O, P)
    // https://rbuckton.github.io/reflect-metadata/#ordinarygetmetadata
    function OrdinaryGetMetadata(MetadataKey, O, P) {
        var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
        if (hasOwn)
            return OrdinaryGetOwnMetadata(MetadataKey, O, P);
        var parent = OrdinaryGetPrototypeOf(O);
        if (!IsNull(parent))
            return OrdinaryGetMetadata(MetadataKey, parent, P);
        return undefined;
    }
    // 3.1.4.1 OrdinaryGetOwnMetadata(MetadataKey, O, P)
    // https://rbuckton.github.io/reflect-metadata/#ordinarygetownmetadata
    function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
        var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
        if (IsUndefined(metadataMap))
            return undefined;
        return metadataMap.get(MetadataKey);
    }
    // 3.1.5.1 OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P)
    // https://rbuckton.github.io/reflect-metadata/#ordinarydefineownmetadata
    function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
        var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ true);
        metadataMap.set(MetadataKey, MetadataValue);
    }
    // 3.1.6.1 OrdinaryMetadataKeys(O, P)
    // https://rbuckton.github.io/reflect-metadata/#ordinarymetadatakeys
    function OrdinaryMetadataKeys(O, P) {
        var ownKeys = OrdinaryOwnMetadataKeys(O, P);
        var parent = OrdinaryGetPrototypeOf(O);
        if (parent === null)
            return ownKeys;
        var parentKeys = OrdinaryMetadataKeys(parent, P);
        if (parentKeys.length &lt;= 0)
            return ownKeys;
        if (ownKeys.length &lt;= 0)
            return parentKeys;
        var set = new _Set();
        var keys = [];
        for (var _i = 0, ownKeys_1 = ownKeys; _i &lt; ownKeys_1.length; _i++) {
            var key = ownKeys_1[_i];
            var hasKey = set.has(key);
            if (!hasKey) {
                set.add(key);
                keys.push(key);
            }
        }
        for (var _a = 0, parentKeys_1 = parentKeys; _a &lt; parentKeys_1.length; _a++) {
            var key = parentKeys_1[_a];
            var hasKey = set.has(key);
            if (!hasKey) {
                set.add(key);
                keys.push(key);
            }
        }
        return keys;
    }
    // 3.1.7.1 OrdinaryOwnMetadataKeys(O, P)
    // https://rbuckton.github.io/reflect-metadata/#ordinaryownmetadatakeys
    function OrdinaryOwnMetadataKeys(O, P) {
        var keys = [];
        var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
        if (IsUndefined(metadataMap))
            return keys;
        var keysObj = metadataMap.keys();
        var iterator = GetIterator(keysObj);
        var k = 0;
        while (true) {
            var next = IteratorStep(iterator);
            if (!next) {
                keys.length = k;
                return keys;
            }
            var nextValue = IteratorValue(next);
            try {
                keys[k] = nextValue;
            }
            catch (e) {
                try {
                    IteratorClose(iterator);
                }
                finally {
                    throw e;
                }
            }
            k++;
        }
    }
    // 6 ECMAScript Data Typ0es and Values
    // https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values
    function Type(x) {
        if (x === null)
            return 1 /* Null */;
        switch (typeof x) {
            case "undefined": return 0 /* Undefined */;
            case "boolean": return 2 /* Boolean */;
            case "string": return 3 /* String */;
            case "symbol": return 4 /* Symbol */;
            case "number": return 5 /* Number */;
            case "object": return x === null ? 1 /* Null */ : 6 /* Object */;
            default: return 6 /* Object */;
        }
    }
    // 6.1.1 The Undefined Type
    // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-undefined-type
    function IsUndefined(x) {
        return x === undefined;
    }
    // 6.1.2 The Null Type
    // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-null-type
    function IsNull(x) {
        return x === null;
    }
    // 6.1.5 The Symbol Type
    // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-symbol-type
    function IsSymbol(x) {
        return typeof x === "symbol";
    }
    // 6.1.7 The Object Type
    // https://tc39.github.io/ecma262/#sec-object-type
    function IsObject(x) {
        return typeof x === "object" ? x !== null : typeof x === "function";
    }
    // 7.1 Type Conversion
    // https://tc39.github.io/ecma262/#sec-type-conversion
    // 7.1.1 ToPrimitive(input [, PreferredType])
    // https://tc39.github.io/ecma262/#sec-toprimitive
    function ToPrimitive(input, PreferredType) {
        switch (Type(input)) {
            case 0 /* Undefined */: return input;
            case 1 /* Null */: return input;
            case 2 /* Boolean */: return input;
            case 3 /* String */: return input;
            case 4 /* Symbol */: return input;
            case 5 /* Number */: return input;
        }
        var hint = PreferredType === 3 /* String */ ? "string" : PreferredType === 5 /* Number */ ? "number" : "default";
        var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
        if (exoticToPrim !== undefined) {
            var result = exoticToPrim.call(input, hint);
            if (IsObject(result))
                throw new TypeError();
            return result;
        }
        return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
    }
    // 7.1.1.1 OrdinaryToPrimitive(O, hint)
    // https://tc39.github.io/ecma262/#sec-ordinarytoprimitive
    function OrdinaryToPrimitive(O, hint) {
        if (hint === "string") {
            var toString_1 = O.toString;
            if (IsCallable(toString_1)) {
                var result = toString_1.call(O);
                if (!IsObject(result))
                    return result;
            }
            var valueOf = O.valueOf;
            if (IsCallable(valueOf)) {
                var result = valueOf.call(O);
                if (!IsObject(result))
                    return result;
            }
        }
        else {
            var valueOf = O.valueOf;
            if (IsCallable(valueOf)) {
                var result = valueOf.call(O);
                if (!IsObject(result))
                    return result;
            }
            var toString_2 = O.toString;
            if (IsCallable(toString_2)) {
                var result = toString_2.call(O);
                if (!IsObject(result))
                    return result;
            }
        }
        throw new TypeError();
    }
    // 7.1.2 ToBoolean(argument)
    // https://tc39.github.io/ecma262/2016/#sec-toboolean
    function ToBoolean(argument) {
        return !!argument;
    }
    // 7.1.12 ToString(argument)
    // https://tc39.github.io/ecma262/#sec-tostring
    function ToString(argument) {
        return "" + argument;
    }
    // 7.1.14 ToPropertyKey(argument)
    // https://tc39.github.io/ecma262/#sec-topropertykey
    function ToPropertyKey(argument) {
        var key = ToPrimitive(argument, 3 /* String */);
        if (IsSymbol(key))
            return key;
        return ToString(key);
    }
    // 7.2 Testing and Comparison Operations
    // https://tc39.github.io/ecma262/#sec-testing-and-comparison-operations
    // 7.2.2 IsArray(argument)
    // https://tc39.github.io/ecma262/#sec-isarray
    function IsArray(argument) {
        return Array.isArray
            ? Array.isArray(argument)
            : argument instanceof Object
                ? argument instanceof Array
                : Object.prototype.toString.call(argument) === "[object Array]";
    }
    // 7.2.3 IsCallable(argument)
    // https://tc39.github.io/ecma262/#sec-iscallable
    function IsCallable(argument) {
        // NOTE: This is an approximation as we cannot check for [[Call]] internal method.
        return typeof argument === "function";
    }
    // 7.2.4 IsConstructor(argument)
    // https://tc39.github.io/ecma262/#sec-isconstructor
    function IsConstructor(argument) {
        // NOTE: This is an approximation as we cannot check for [[Construct]] internal method.
        return typeof argument === "function";
    }
    // 7.2.7 IsPropertyKey(argument)
    // https://tc39.github.io/ecma262/#sec-ispropertykey
    function IsPropertyKey(argument) {
        switch (Type(argument)) {
            case 3 /* String */: return true;
            case 4 /* Symbol */: return true;
            default: return false;
        }
    }
    // 7.3 Operations on Objects
    // https://tc39.github.io/ecma262/#sec-operations-on-objects
    // 7.3.9 GetMethod(V, P)
    // https://tc39.github.io/ecma262/#sec-getmethod
    function GetMethod(V, P) {
        var func = V[P];
        if (func === undefined || func === null)
            return undefined;
        if (!IsCallable(func))
            throw new TypeError();
        return func;
    }
    // 7.4 Operations on Iterator Objects
    // https://tc39.github.io/ecma262/#sec-operations-on-iterator-objects
    function GetIterator(obj) {
        var method = GetMethod(obj, iteratorSymbol);
        if (!IsCallable(method))
            throw new TypeError(); // from Call
        var iterator = method.call(obj);
        if (!IsObject(iterator))
            throw new TypeError();
        return iterator;
    }
    // 7.4.4 IteratorValue(iterResult)
    // https://tc39.github.io/ecma262/2016/#sec-iteratorvalue
    function IteratorValue(iterResult) {
        return iterResult.value;
    }
    // 7.4.5 IteratorStep(iterator)
    // https://tc39.github.io/ecma262/#sec-iteratorstep
    function IteratorStep(iterator) {
        var result = iterator.next();
        return result.done ? false : result;
    }
    // 7.4.6 IteratorClose(iterator, completion)
    // https://tc39.github.io/ecma262/#sec-iteratorclose
    function IteratorClose(iterator) {
        var f = iterator["return"];
        if (f)
            f.call(iterator);
    }
    // 9.1 Ordinary Object Internal Methods and Internal Slots
    // https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots
    // 9.1.1.1 OrdinaryGetPrototypeOf(O)
    // https://tc39.github.io/ecma262/#sec-ordinarygetprototypeof
    function OrdinaryGetPrototypeOf(O) {
        var proto = Object.getPrototypeOf(O);
        if (typeof O !== "function" || O === functionPrototype)
            return proto;
        // TypeScript doesn't set __proto__ in ES5, as it's non-standard.
        // Try to determine the superclass constructor. Compatible implementations
        // must either set __proto__ on a subclass constructor to the superclass constructor,
        // or ensure each class has a valid `constructor` property on its prototype that
        // points back to the constructor.
        // If this is not the same as Function.[[Prototype]], then this is definately inherited.
        // This is the case when in ES6 or when using __proto__ in a compatible browser.
        if (proto !== functionPrototype)
            return proto;
        // If the super prototype is Object.prototype, null, or undefined, then we cannot determine the heritage.
        var prototype = O.prototype;
        var prototypeProto = prototype &amp;&amp; Object.getPrototypeOf(prototype);
        if (prototypeProto == null || prototypeProto === Object.prototype)
            return proto;
        // If the constructor was not a function, then we cannot determine the heritage.
        var constructor = prototypeProto.constructor;
        if (typeof constructor !== "function")
            return proto;
        // If we have some kind of self-reference, then we cannot determine the heritage.
        if (constructor === O)
            return proto;
        // we have a pretty good guess at the heritage.
        return constructor;
    }
    // naive Map shim
    function CreateMapPolyfill() {
        var cacheSentinel = {};
        var arraySentinel = [];
        var MapIterator = (function () {
            function MapIterator(keys, values, selector) {
                this._index = 0;
                this._keys = keys;
                this._values = values;
                this._selector = selector;
            }
            MapIterator.prototype["@@iterator"] = function () { return this; };
            MapIterator.prototype[iteratorSymbol] = function () { return this; };
            MapIterator.prototype.next = function () {
                var index = this._index;
                if (index >= 0 &amp;&amp; index &lt; this._keys.length) {
                    var result = this._selector(this._keys[index], this._values[index]);
                    if (index + 1 >= this._keys.length) {
                        this._index = -1;
                        this._keys = arraySentinel;
                        this._values = arraySentinel;
                    }
                    else {
                        this._index++;
                    }
                    return { value: result, done: false };
                }
                return { value: undefined, done: true };
            };
            MapIterator.prototype.throw = function (error) {
                if (this._index >= 0) {
                    this._index = -1;
                    this._keys = arraySentinel;
                    this._values = arraySentinel;
                }
                throw error;
            };
            MapIterator.prototype.return = function (value) {
                if (this._index >= 0) {
                    this._index = -1;
                    this._keys = arraySentinel;
                    this._values = arraySentinel;
                }
                return { value: value, done: true };
            };
            return MapIterator;
        }());
        return (function () {
            function Map() {
                this._keys = [];
                this._values = [];
                this._cacheKey = cacheSentinel;
                this._cacheIndex = -2;
            }
            Object.defineProperty(Map.prototype, "size", {
                get: function () { return this._keys.length; },
                enumerable: true,
                configurable: true
            });
            Map.prototype.has = function (key) { return this._find(key, /*insert*/ false) >= 0; };
            Map.prototype.get = function (key) {
                var index = this._find(key, /*insert*/ false);
                return index >= 0 ? this._values[index] : undefined;
            };
            Map.prototype.set = function (key, value) {
                var index = this._find(key, /*insert*/ true);
                this._values[index] = value;
                return this;
            };
            Map.prototype.delete = function (key) {
                var index = this._find(key, /*insert*/ false);
                if (index >= 0) {
                    var size = this._keys.length;
                    for (var i = index + 1; i &lt; size; i++) {
                        this._keys[i - 1] = this._keys[i];
                        this._values[i - 1] = this._values[i];
                    }
                    this._keys.length--;
                    this._values.length--;
                    if (key === this._cacheKey) {
                        this._cacheKey = cacheSentinel;
                        this._cacheIndex = -2;
                    }
                    return true;
                }
                return false;
            };
            Map.prototype.clear = function () {
                this._keys.length = 0;
                this._values.length = 0;
                this._cacheKey = cacheSentinel;
                this._cacheIndex = -2;
            };
            Map.prototype.keys = function () { return new MapIterator(this._keys, this._values, getKey); };
            Map.prototype.values = function () { return new MapIterator(this._keys, this._values, getValue); };
            Map.prototype.entries = function () { return new MapIterator(this._keys, this._values, getEntry); };
            Map.prototype["@@iterator"] = function () { return this.entries(); };
            Map.prototype[iteratorSymbol] = function () { return this.entries(); };
            Map.prototype._find = function (key, insert) {
                if (this._cacheKey !== key) {
                    this._cacheIndex = this._keys.indexOf(this._cacheKey = key);
                }
                if (this._cacheIndex &lt; 0 &amp;&amp; insert) {
                    this._cacheIndex = this._keys.length;
                    this._keys.push(key);
                    this._values.push(undefined);
                }
                return this._cacheIndex;
            };
            return Map;
        }());
        function getKey(key, _) {
            return key;
        }
        function getValue(_, value) {
            return value;
        }
        function getEntry(key, value) {
            return [key, value];
        }
    }
    // naive Set shim
    function CreateSetPolyfill() {
        return (function () {
            function Set() {
                this._map = new _Map();
            }
            Object.defineProperty(Set.prototype, "size", {
                get: function () { return this._map.size; },
                enumerable: true,
                configurable: true
            });
            Set.prototype.has = function (value) { return this._map.has(value); };
            Set.prototype.add = function (value) { return this._map.set(value, value), this; };
            Set.prototype.delete = function (value) { return this._map.delete(value); };
            Set.prototype.clear = function () { this._map.clear(); };
            Set.prototype.keys = function () { return this._map.keys(); };
            Set.prototype.values = function () { return this._map.values(); };
            Set.prototype.entries = function () { return this._map.entries(); };
            Set.prototype["@@iterator"] = function () { return this.keys(); };
            Set.prototype[iteratorSymbol] = function () { return this.keys(); };
            return Set;
        }());
    }
    // naive WeakMap shim
    function CreateWeakMapPolyfill() {
        var UUID_SIZE = 16;
        var keys = HashMap.create();
        var rootKey = CreateUniqueKey();
        return (function () {
            function WeakMap() {
                this._key = CreateUniqueKey();
            }
            WeakMap.prototype.has = function (target) {
                var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                return table !== undefined ? HashMap.has(table, this._key) : false;
            };
            WeakMap.prototype.get = function (target) {
                var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                return table !== undefined ? HashMap.get(table, this._key) : undefined;
            };
            WeakMap.prototype.set = function (target, value) {
                var table = GetOrCreateWeakMapTable(target, /*create*/ true);
                table[this._key] = value;
                return this;
            };
            WeakMap.prototype.delete = function (target) {
                var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                return table !== undefined ? delete table[this._key] : false;
            };
            WeakMap.prototype.clear = function () {
                // NOTE: not a real clear, just makes the previous data unreachable
                this._key = CreateUniqueKey();
            };
            return WeakMap;
        }());
        function CreateUniqueKey() {
            var key;
            do
                key = "@@WeakMap@@" + CreateUUID();
            while (HashMap.has(keys, key));
            keys[key] = true;
            return key;
        }
        function GetOrCreateWeakMapTable(target, create) {
            if (!hasOwn.call(target, rootKey)) {
                if (!create)
                    return undefined;
                Object.defineProperty(target, rootKey, { value: HashMap.create() });
            }
            return target[rootKey];
        }
        function FillRandomBytes(buffer, size) {
            for (var i = 0; i &lt; size; ++i)
                buffer[i] = Math.random() * 0xff | 0;
            return buffer;
        }
        function GenRandomBytes(size) {
            if (typeof Uint8Array === "function") {
                if (typeof crypto !== "undefined")
                    return crypto.getRandomValues(new Uint8Array(size));
                if (typeof msCrypto !== "undefined")
                    return msCrypto.getRandomValues(new Uint8Array(size));
                return FillRandomBytes(new Uint8Array(size), size);
            }
            return FillRandomBytes(new Array(size), size);
        }
        function CreateUUID() {
            var data = GenRandomBytes(UUID_SIZE);
            // mark as random - RFC 4122 § 4.4
            data[6] = data[6] &amp; 0x4f | 0x40;
            data[8] = data[8] &amp; 0xbf | 0x80;
            var result = "";
            for (var offset = 0; offset &lt; UUID_SIZE; ++offset) {
                var byte = data[offset];
                if (offset === 4 || offset === 6 || offset === 8)
                    result += "-";
                if (byte &lt; 16)
                    result += "0";
                result += byte.toString(16).toLowerCase();
            }
            return result;
        }
    }
    // uses a heuristic used by v8 and chakra to force an object into dictionary mode.
    function MakeDictionary(obj) {
        obj.__ = undefined;
        delete obj.__;
        return obj;
    }
    // patch global Reflect
    (function (__global) {
        if (typeof __global.Reflect !== "undefined") {
            if (__global.Reflect !== Reflect) {
                for (var p in Reflect) {
                    if (hasOwn.call(Reflect, p)) {
                        __global.Reflect[p] = Reflect[p];
                    }
                }
            }
        }
        else {
            __global.Reflect = Reflect;
        }
    })(typeof global !== "undefined" ? global :
        typeof self !== "undefined" ? self :
            Function("return this;")());
})(Reflect || (Reflect = {}));
//# sourceMappingURL=Reflect.js.map

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

/**
* @license
* Copyright Google Inc. All Rights Reserved.
*
* Use of this source code is governed by an MIT-style license that can be
* found in the LICENSE file at https://angular.io/license
*/
(function (global, factory) {
	 true ? factory() :
	typeof define === 'function' &amp;&amp; define.amd ? define(factory) :
	(factory());
}(this, (function () { 'use strict';

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var Zone$1 = (function (global) {
    var FUNCTION = 'function';
    var performance = global['performance'];
    function mark(name) {
        performance &amp;&amp; performance['mark'] &amp;&amp; performance['mark'](name);
    }
    function performanceMeasure(name, label) {
        performance &amp;&amp; performance['measure'] &amp;&amp; performance['measure'](name, label);
    }
    mark('Zone');
    if (global['Zone']) {
        throw new Error('Zone already loaded.');
    }
    var Zone = (function () {
        function Zone(parent, zoneSpec) {
            this._properties = null;
            this._parent = parent;
            this._name = zoneSpec ? zoneSpec.name || 'unnamed' : '&lt;root>';
            this._properties = zoneSpec &amp;&amp; zoneSpec.properties || {};
            this._zoneDelegate =
                new ZoneDelegate(this, this._parent &amp;&amp; this._parent._zoneDelegate, zoneSpec);
        }
        Zone.assertZonePatched = function () {
            if (global['Promise'] !== patches['ZoneAwarePromise']) {
                throw new Error('Zone.js has detected that ZoneAwarePromise `(window|global).Promise` ' +
                    'has been overwritten.\n' +
                    'Most likely cause is that a Promise polyfill has been loaded ' +
                    'after Zone.js (Polyfilling Promise api is not necessary when zone.js is loaded. ' +
                    'If you must load one, do so before loading zone.js.)');
            }
        };
        Object.defineProperty(Zone, "root", {
            get: function () {
                var zone = Zone.current;
                while (zone.parent) {
                    zone = zone.parent;
                }
                return zone;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Zone, "current", {
            get: function () {
                return _currentZoneFrame.zone;
            },
            enumerable: true,
            configurable: true
        });
        
        Object.defineProperty(Zone, "currentTask", {
            get: function () {
                return _currentTask;
            },
            enumerable: true,
            configurable: true
        });
        
        Zone.__load_patch = function (name, fn) {
            if (patches.hasOwnProperty(name)) {
                throw Error('Already loaded patch: ' + name);
            }
            else if (!global['__Zone_disable_' + name]) {
                var perfName = 'Zone:' + name;
                mark(perfName);
                patches[name] = fn(global, Zone, _api);
                performanceMeasure(perfName, perfName);
            }
        };
        Object.defineProperty(Zone.prototype, "parent", {
            get: function () {
                return this._parent;
            },
            enumerable: true,
            configurable: true
        });
        
        Object.defineProperty(Zone.prototype, "name", {
            get: function () {
                return this._name;
            },
            enumerable: true,
            configurable: true
        });
        
        Zone.prototype.get = function (key) {
            var zone = this.getZoneWith(key);
            if (zone)
                return zone._properties[key];
        };
        Zone.prototype.getZoneWith = function (key) {
            var current = this;
            while (current) {
                if (current._properties.hasOwnProperty(key)) {
                    return current;
                }
                current = current._parent;
            }
            return null;
        };
        Zone.prototype.fork = function (zoneSpec) {
            if (!zoneSpec)
                throw new Error('ZoneSpec required!');
            return this._zoneDelegate.fork(this, zoneSpec);
        };
        Zone.prototype.wrap = function (callback, source) {
            if (typeof callback !== FUNCTION) {
                throw new Error('Expecting function got: ' + callback);
            }
            var _callback = this._zoneDelegate.intercept(this, callback, source);
            var zone = this;
            return function () {
                return zone.runGuarded(_callback, this, arguments, source);
            };
        };
        Zone.prototype.run = function (callback, applyThis, applyArgs, source) {
            if (applyThis === void 0) { applyThis = undefined; }
            if (applyArgs === void 0) { applyArgs = null; }
            if (source === void 0) { source = null; }
            _currentZoneFrame = { parent: _currentZoneFrame, zone: this };
            try {
                return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);
            }
            finally {
                _currentZoneFrame = _currentZoneFrame.parent;
            }
        };
        Zone.prototype.runGuarded = function (callback, applyThis, applyArgs, source) {
            if (applyThis === void 0) { applyThis = null; }
            if (applyArgs === void 0) { applyArgs = null; }
            if (source === void 0) { source = null; }
            _currentZoneFrame = { parent: _currentZoneFrame, zone: this };
            try {
                try {
                    return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);
                }
                catch (error) {
                    if (this._zoneDelegate.handleError(this, error)) {
                        throw error;
                    }
                }
            }
            finally {
                _currentZoneFrame = _currentZoneFrame.parent;
            }
        };
        Zone.prototype.runTask = function (task, applyThis, applyArgs) {
            if (task.zone != this) {
                throw new Error('A task can only be run in the zone of creation! (Creation: ' +
                    (task.zone || NO_ZONE).name + '; Execution: ' + this.name + ')');
            }
            // https://github.com/angular/zone.js/issues/778, sometimes eventTask
            // will run in notScheduled(canceled) state, we should not try to
            // run such kind of task but just return
            // we have to define an variable here, if not
            // typescript compiler will complain below
            var isNotScheduled = task.state === notScheduled;
            if (isNotScheduled &amp;&amp; task.type === eventTask) {
                return;
            }
            var reEntryGuard = task.state != running;
            reEntryGuard &amp;&amp; task._transitionTo(running, scheduled);
            task.runCount++;
            var previousTask = _currentTask;
            _currentTask = task;
            _currentZoneFrame = { parent: _currentZoneFrame, zone: this };
            try {
                if (task.type == macroTask &amp;&amp; task.data &amp;&amp; !task.data.isPeriodic) {
                    task.cancelFn = null;
                }
                try {
                    return this._zoneDelegate.invokeTask(this, task, applyThis, applyArgs);
                }
                catch (error) {
                    if (this._zoneDelegate.handleError(this, error)) {
                        throw error;
                    }
                }
            }
            finally {
                // if the task's state is notScheduled or unknown, then it has already been cancelled
                // we should not reset the state to scheduled
                if (task.state !== notScheduled &amp;&amp; task.state !== unknown) {
                    if (task.type == eventTask || (task.data &amp;&amp; task.data.isPeriodic)) {
                        reEntryGuard &amp;&amp; task._transitionTo(scheduled, running);
                    }
                    else {
                        task.runCount = 0;
                        this._updateTaskCount(task, -1);
                        reEntryGuard &amp;&amp;
                            task._transitionTo(notScheduled, running, notScheduled);
                    }
                }
                _currentZoneFrame = _currentZoneFrame.parent;
                _currentTask = previousTask;
            }
        };
        Zone.prototype.scheduleTask = function (task) {
            if (task.zone &amp;&amp; task.zone !== this) {
                // check if the task was rescheduled, the newZone
                // should not be the children of the original zone
                var newZone = this;
                while (newZone) {
                    if (newZone === task.zone) {
                        throw Error("can not reschedule task to " + this
                            .name + " which is descendants of the original zone " + task.zone.name);
                    }
                    newZone = newZone.parent;
                }
            }
            task._transitionTo(scheduling, notScheduled);
            var zoneDelegates = [];
            task._zoneDelegates = zoneDelegates;
            task._zone = this;
            try {
                task = this._zoneDelegate.scheduleTask(this, task);
            }
            catch (err) {
                // should set task's state to unknown when scheduleTask throw error
                // because the err may from reschedule, so the fromState maybe notScheduled
                task._transitionTo(unknown, scheduling, notScheduled);
                // TODO: @JiaLiPassion, should we check the result from handleError?
                this._zoneDelegate.handleError(this, err);
                throw err;
            }
            if (task._zoneDelegates === zoneDelegates) {
                // we have to check because internally the delegate can reschedule the task.
                this._updateTaskCount(task, 1);
            }
            if (task.state == scheduling) {
                task._transitionTo(scheduled, scheduling);
            }
            return task;
        };
        Zone.prototype.scheduleMicroTask = function (source, callback, data, customSchedule) {
            return this.scheduleTask(new ZoneTask(microTask, source, callback, data, customSchedule, null));
        };
        Zone.prototype.scheduleMacroTask = function (source, callback, data, customSchedule, customCancel) {
            return this.scheduleTask(new ZoneTask(macroTask, source, callback, data, customSchedule, customCancel));
        };
        Zone.prototype.scheduleEventTask = function (source, callback, data, customSchedule, customCancel) {
            return this.scheduleTask(new ZoneTask(eventTask, source, callback, data, customSchedule, customCancel));
        };
        Zone.prototype.cancelTask = function (task) {
            if (task.zone != this)
                throw new Error('A task can only be cancelled in the zone of creation! (Creation: ' +
                    (task.zone || NO_ZONE).name + '; Execution: ' + this.name + ')');
            task._transitionTo(canceling, scheduled, running);
            try {
                this._zoneDelegate.cancelTask(this, task);
            }
            catch (err) {
                // if error occurs when cancelTask, transit the state to unknown
                task._transitionTo(unknown, canceling);
                this._zoneDelegate.handleError(this, err);
                throw err;
            }
            this._updateTaskCount(task, -1);
            task._transitionTo(notScheduled, canceling);
            task.runCount = 0;
            return task;
        };
        Zone.prototype._updateTaskCount = function (task, count) {
            var zoneDelegates = task._zoneDelegates;
            if (count == -1) {
                task._zoneDelegates = null;
            }
            for (var i = 0; i &lt; zoneDelegates.length; i++) {
                zoneDelegates[i]._updateTaskCount(task.type, count);
            }
        };
        return Zone;
    }());
    Zone.__symbol__ = __symbol__;
    var DELEGATE_ZS = {
        name: '',
        onHasTask: function (delegate, _, target, hasTaskState) {
            return delegate.hasTask(target, hasTaskState);
        },
        onScheduleTask: function (delegate, _, target, task) {
            return delegate.scheduleTask(target, task);
        },
        onInvokeTask: function (delegate, _, target, task, applyThis, applyArgs) { return delegate.invokeTask(target, task, applyThis, applyArgs); },
        onCancelTask: function (delegate, _, target, task) {
            return delegate.cancelTask(target, task);
        }
    };
    var ZoneDelegate = (function () {
        function ZoneDelegate(zone, parentDelegate, zoneSpec) {
            this._taskCounts = { 'microTask': 0, 'macroTask': 0, 'eventTask': 0 };
            this.zone = zone;
            this._parentDelegate = parentDelegate;
            this._forkZS = zoneSpec &amp;&amp; (zoneSpec &amp;&amp; zoneSpec.onFork ? zoneSpec : parentDelegate._forkZS);
            this._forkDlgt = zoneSpec &amp;&amp; (zoneSpec.onFork ? parentDelegate : parentDelegate._forkDlgt);
            this._forkCurrZone = zoneSpec &amp;&amp; (zoneSpec.onFork ? this.zone : parentDelegate.zone);
            this._interceptZS =
                zoneSpec &amp;&amp; (zoneSpec.onIntercept ? zoneSpec : parentDelegate._interceptZS);
            this._interceptDlgt =
                zoneSpec &amp;&amp; (zoneSpec.onIntercept ? parentDelegate : parentDelegate._interceptDlgt);
            this._interceptCurrZone =
                zoneSpec &amp;&amp; (zoneSpec.onIntercept ? this.zone : parentDelegate.zone);
            this._invokeZS = zoneSpec &amp;&amp; (zoneSpec.onInvoke ? zoneSpec : parentDelegate._invokeZS);
            this._invokeDlgt =
                zoneSpec &amp;&amp; (zoneSpec.onInvoke ? parentDelegate : parentDelegate._invokeDlgt);
            this._invokeCurrZone = zoneSpec &amp;&amp; (zoneSpec.onInvoke ? this.zone : parentDelegate.zone);
            this._handleErrorZS =
                zoneSpec &amp;&amp; (zoneSpec.onHandleError ? zoneSpec : parentDelegate._handleErrorZS);
            this._handleErrorDlgt =
                zoneSpec &amp;&amp; (zoneSpec.onHandleError ? parentDelegate : parentDelegate._handleErrorDlgt);
            this._handleErrorCurrZone =
                zoneSpec &amp;&amp; (zoneSpec.onHandleError ? this.zone : parentDelegate.zone);
            this._scheduleTaskZS =
                zoneSpec &amp;&amp; (zoneSpec.onScheduleTask ? zoneSpec : parentDelegate._scheduleTaskZS);
            this._scheduleTaskDlgt =
                zoneSpec &amp;&amp; (zoneSpec.onScheduleTask ? parentDelegate : parentDelegate._scheduleTaskDlgt);
            this._scheduleTaskCurrZone =
                zoneSpec &amp;&amp; (zoneSpec.onScheduleTask ? this.zone : parentDelegate.zone);
            this._invokeTaskZS =
                zoneSpec &amp;&amp; (zoneSpec.onInvokeTask ? zoneSpec : parentDelegate._invokeTaskZS);
            this._invokeTaskDlgt =
                zoneSpec &amp;&amp; (zoneSpec.onInvokeTask ? parentDelegate : parentDelegate._invokeTaskDlgt);
            this._invokeTaskCurrZone =
                zoneSpec &amp;&amp; (zoneSpec.onInvokeTask ? this.zone : parentDelegate.zone);
            this._cancelTaskZS =
                zoneSpec &amp;&amp; (zoneSpec.onCancelTask ? zoneSpec : parentDelegate._cancelTaskZS);
            this._cancelTaskDlgt =
                zoneSpec &amp;&amp; (zoneSpec.onCancelTask ? parentDelegate : parentDelegate._cancelTaskDlgt);
            this._cancelTaskCurrZone =
                zoneSpec &amp;&amp; (zoneSpec.onCancelTask ? this.zone : parentDelegate.zone);
            this._hasTaskZS = null;
            this._hasTaskDlgt = null;
            this._hasTaskDlgtOwner = null;
            this._hasTaskCurrZone = null;
            var zoneSpecHasTask = zoneSpec &amp;&amp; zoneSpec.onHasTask;
            var parentHasTask = parentDelegate &amp;&amp; parentDelegate._hasTaskZS;
            if (zoneSpecHasTask || parentHasTask) {
                // If we need to report hasTask, than this ZS needs to do ref counting on tasks. In such
                // a case all task related interceptors must go through this ZD. We can't short circuit it.
                this._hasTaskZS = zoneSpecHasTask ? zoneSpec : DELEGATE_ZS;
                this._hasTaskDlgt = parentDelegate;
                this._hasTaskDlgtOwner = this;
                this._hasTaskCurrZone = zone;
                if (!zoneSpec.onScheduleTask) {
                    this._scheduleTaskZS = DELEGATE_ZS;
                    this._scheduleTaskDlgt = parentDelegate;
                    this._scheduleTaskCurrZone = this.zone;
                }
                if (!zoneSpec.onInvokeTask) {
                    this._invokeTaskZS = DELEGATE_ZS;
                    this._invokeTaskDlgt = parentDelegate;
                    this._invokeTaskCurrZone = this.zone;
                }
                if (!zoneSpec.onCancelTask) {
                    this._cancelTaskZS = DELEGATE_ZS;
                    this._cancelTaskDlgt = parentDelegate;
                    this._cancelTaskCurrZone = this.zone;
                }
            }
        }
        ZoneDelegate.prototype.fork = function (targetZone, zoneSpec) {
            return this._forkZS ? this._forkZS.onFork(this._forkDlgt, this.zone, targetZone, zoneSpec) :
                new Zone(targetZone, zoneSpec);
        };
        ZoneDelegate.prototype.intercept = function (targetZone, callback, source) {
            return this._interceptZS ?
                this._interceptZS.onIntercept(this._interceptDlgt, this._interceptCurrZone, targetZone, callback, source) :
                callback;
        };
        ZoneDelegate.prototype.invoke = function (targetZone, callback, applyThis, applyArgs, source) {
            return this._invokeZS ?
                this._invokeZS.onInvoke(this._invokeDlgt, this._invokeCurrZone, targetZone, callback, applyThis, applyArgs, source) :
                callback.apply(applyThis, applyArgs);
        };
        ZoneDelegate.prototype.handleError = function (targetZone, error) {
            return this._handleErrorZS ?
                this._handleErrorZS.onHandleError(this._handleErrorDlgt, this._handleErrorCurrZone, targetZone, error) :
                true;
        };
        ZoneDelegate.prototype.scheduleTask = function (targetZone, task) {
            var returnTask = task;
            if (this._scheduleTaskZS) {
                if (this._hasTaskZS) {
                    returnTask._zoneDelegates.push(this._hasTaskDlgtOwner);
                }
                returnTask = this._scheduleTaskZS.onScheduleTask(this._scheduleTaskDlgt, this._scheduleTaskCurrZone, targetZone, task);
                if (!returnTask)
                    returnTask = task;
            }
            else {
                if (task.scheduleFn) {
                    task.scheduleFn(task);
                }
                else if (task.type == microTask) {
                    scheduleMicroTask(task);
                }
                else {
                    throw new Error('Task is missing scheduleFn.');
                }
            }
            return returnTask;
        };
        ZoneDelegate.prototype.invokeTask = function (targetZone, task, applyThis, applyArgs) {
            return this._invokeTaskZS ?
                this._invokeTaskZS.onInvokeTask(this._invokeTaskDlgt, this._invokeTaskCurrZone, targetZone, task, applyThis, applyArgs) :
                task.callback.apply(applyThis, applyArgs);
        };
        ZoneDelegate.prototype.cancelTask = function (targetZone, task) {
            var value;
            if (this._cancelTaskZS) {
                value = this._cancelTaskZS.onCancelTask(this._cancelTaskDlgt, this._cancelTaskCurrZone, targetZone, task);
            }
            else {
                if (!task.cancelFn) {
                    throw Error('Task is not cancelable');
                }
                value = task.cancelFn(task);
            }
            return value;
        };
        ZoneDelegate.prototype.hasTask = function (targetZone, isEmpty) {
            // hasTask should not throw error so other ZoneDelegate
            // can still trigger hasTask callback
            try {
                return this._hasTaskZS &amp;&amp;
                    this._hasTaskZS.onHasTask(this._hasTaskDlgt, this._hasTaskCurrZone, targetZone, isEmpty);
            }
            catch (err) {
                this.handleError(targetZone, err);
            }
        };
        ZoneDelegate.prototype._updateTaskCount = function (type, count) {
            var counts = this._taskCounts;
            var prev = counts[type];
            var next = counts[type] = prev + count;
            if (next &lt; 0) {
                throw new Error('More tasks executed then were scheduled.');
            }
            if (prev == 0 || next == 0) {
                var isEmpty = {
                    microTask: counts['microTask'] > 0,
                    macroTask: counts['macroTask'] > 0,
                    eventTask: counts['eventTask'] > 0,
                    change: type
                };
                this.hasTask(this.zone, isEmpty);
            }
        };
        return ZoneDelegate;
    }());
    var ZoneTask = (function () {
        function ZoneTask(type, source, callback, options, scheduleFn, cancelFn) {
            this._zone = null;
            this.runCount = 0;
            this._zoneDelegates = null;
            this._state = 'notScheduled';
            this.type = type;
            this.source = source;
            this.data = options;
            this.scheduleFn = scheduleFn;
            this.cancelFn = cancelFn;
            this.callback = callback;
            var self = this;
            if (type === eventTask &amp;&amp; options &amp;&amp; options.isUsingGlobalCallback) {
                this.invoke = ZoneTask.invokeTask;
            }
            else {
                this.invoke = function () {
                    return ZoneTask.invokeTask.apply(global, [self, this, arguments]);
                };
            }
        }
        ZoneTask.invokeTask = function (task, target, args) {
            if (!task) {
                task = this;
            }
            _numberOfNestedTaskFrames++;
            try {
                task.runCount++;
                return task.zone.runTask(task, target, args);
            }
            finally {
                if (_numberOfNestedTaskFrames == 1) {
                    drainMicroTaskQueue();
                }
                _numberOfNestedTaskFrames--;
            }
        };
        Object.defineProperty(ZoneTask.prototype, "zone", {
            get: function () {
                return this._zone;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ZoneTask.prototype, "state", {
            get: function () {
                return this._state;
            },
            enumerable: true,
            configurable: true
        });
        ZoneTask.prototype.cancelScheduleRequest = function () {
            this._transitionTo(notScheduled, scheduling);
        };
        ZoneTask.prototype._transitionTo = function (toState, fromState1, fromState2) {
            if (this._state === fromState1 || this._state === fromState2) {
                this._state = toState;
                if (toState == notScheduled) {
                    this._zoneDelegates = null;
                }
            }
            else {
                throw new Error(this.type + " '" + this.source + "': can not transition to '" + toState + "', expecting state '" + fromState1 + "'" + (fromState2 ?
                    ' or \'' + fromState2 + '\'' :
                    '') + ", was '" + this._state + "'.");
            }
        };
        ZoneTask.prototype.toString = function () {
            if (this.data &amp;&amp; typeof this.data.handleId !== 'undefined') {
                return this.data.handleId;
            }
            else {
                return Object.prototype.toString.call(this);
            }
        };
        // add toJSON method to prevent cyclic error when
        // call JSON.stringify(zoneTask)
        ZoneTask.prototype.toJSON = function () {
            return {
                type: this.type,
                state: this.state,
                source: this.source,
                zone: this.zone.name,
                invoke: this.invoke,
                scheduleFn: this.scheduleFn,
                cancelFn: this.cancelFn,
                runCount: this.runCount,
                callback: this.callback
            };
        };
        return ZoneTask;
    }());
    //////////////////////////////////////////////////////
    //////////////////////////////////////////////////////
    ///  MICROTASK QUEUE
    //////////////////////////////////////////////////////
    //////////////////////////////////////////////////////
    var symbolSetTimeout = __symbol__('setTimeout');
    var symbolPromise = __symbol__('Promise');
    var symbolThen = __symbol__('then');
    var _microTaskQueue = [];
    var _isDrainingMicrotaskQueue = false;
    var nativeMicroTaskQueuePromise;
    function scheduleMicroTask(task) {
        // if we are not running in any task, and there has not been anything scheduled
        // we must bootstrap the initial task creation by manually scheduling the drain
        if (_numberOfNestedTaskFrames === 0 &amp;&amp; _microTaskQueue.length === 0) {
            // We are not running in Task, so we need to kickstart the microtask queue.
            if (!nativeMicroTaskQueuePromise) {
                if (global[symbolPromise]) {
                    nativeMicroTaskQueuePromise = global[symbolPromise].resolve(0);
                }
            }
            if (nativeMicroTaskQueuePromise) {
                nativeMicroTaskQueuePromise[symbolThen](drainMicroTaskQueue);
            }
            else {
                global[symbolSetTimeout](drainMicroTaskQueue, 0);
            }
        }
        task &amp;&amp; _microTaskQueue.push(task);
    }
    function drainMicroTaskQueue() {
        if (!_isDrainingMicrotaskQueue) {
            _isDrainingMicrotaskQueue = true;
            while (_microTaskQueue.length) {
                var queue = _microTaskQueue;
                _microTaskQueue = [];
                for (var i = 0; i &lt; queue.length; i++) {
                    var task = queue[i];
                    try {
                        task.zone.runTask(task, null, null);
                    }
                    catch (error) {
                        _api.onUnhandledError(error);
                    }
                }
            }
            var showError = !Zone[__symbol__('ignoreConsoleErrorUncaughtError')];
            _api.microtaskDrainDone();
            _isDrainingMicrotaskQueue = false;
        }
    }
    //////////////////////////////////////////////////////
    //////////////////////////////////////////////////////
    ///  BOOTSTRAP
    //////////////////////////////////////////////////////
    //////////////////////////////////////////////////////
    var NO_ZONE = { name: 'NO ZONE' };
    var notScheduled = 'notScheduled', scheduling = 'scheduling', scheduled = 'scheduled', running = 'running', canceling = 'canceling', unknown = 'unknown';
    var microTask = 'microTask', macroTask = 'macroTask', eventTask = 'eventTask';
    var patches = {};
    var _api = {
        symbol: __symbol__,
        currentZoneFrame: function () { return _currentZoneFrame; },
        onUnhandledError: noop,
        microtaskDrainDone: noop,
        scheduleMicroTask: scheduleMicroTask,
        showUncaughtError: function () { return !Zone[__symbol__('ignoreConsoleErrorUncaughtError')]; },
        patchEventTarget: function () { return []; },
        patchOnProperties: noop,
        patchMethod: function () { return noop; },
        setNativePromise: function (NativePromise) {
            nativeMicroTaskQueuePromise = NativePromise.resolve(0);
        },
    };
    var _currentZoneFrame = { parent: null, zone: new Zone(null, null) };
    var _currentTask = null;
    var _numberOfNestedTaskFrames = 0;
    function noop() { }
    function __symbol__(name) {
        return '__zone_symbol__' + name;
    }
    performanceMeasure('Zone', 'Zone');
    return global['Zone'] = Zone;
})(typeof window !== 'undefined' &amp;&amp; window || typeof self !== 'undefined' &amp;&amp; self || global);

var __read = (undefined &amp;&amp; undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" &amp;&amp; o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) &amp;&amp; !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r &amp;&amp; !r.done &amp;&amp; (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __values = (undefined &amp;&amp; undefined.__values) || function (o) {
    var m = typeof Symbol === "function" &amp;&amp; o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o &amp;&amp; i >= o.length) o = void 0;
            return { value: o &amp;&amp; o[i++], done: !o };
        }
    };
};
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
Zone.__load_patch('ZoneAwarePromise', function (global, Zone, api) {
    var __symbol__ = api.symbol;
    var _uncaughtPromiseErrors = [];
    var symbolPromise = __symbol__('Promise');
    var symbolThen = __symbol__('then');
    api.onUnhandledError = function (e) {
        if (api.showUncaughtError()) {
            var rejection = e &amp;&amp; e.rejection;
            if (rejection) {
                console.error('Unhandled Promise rejection:', rejection instanceof Error ? rejection.message : rejection, '; Zone:', e.zone.name, '; Task:', e.task &amp;&amp; e.task.source, '; Value:', rejection, rejection instanceof Error ? rejection.stack : undefined);
            }
            else {
                console.error(e);
            }
        }
    };
    api.microtaskDrainDone = function () {
        while (_uncaughtPromiseErrors.length) {
            var _loop_1 = function () {
                var uncaughtPromiseError = _uncaughtPromiseErrors.shift();
                try {
                    uncaughtPromiseError.zone.runGuarded(function () {
                        throw uncaughtPromiseError;
                    });
                }
                catch (error) {
                    handleUnhandledRejection(error);
                }
            };
            while (_uncaughtPromiseErrors.length) {
                _loop_1();
            }
        }
    };
    var UNHANDLED_PROMISE_REJECTION_HANDLER_SYMBOL = __symbol__('unhandledPromiseRejectionHandler');
    function handleUnhandledRejection(e) {
        api.onUnhandledError(e);
        try {
            var handler = Zone[UNHANDLED_PROMISE_REJECTION_HANDLER_SYMBOL];
            if (handler &amp;&amp; typeof handler === 'function') {
                handler.apply(this, [e]);
            }
        }
        catch (err) {
        }
    }
    function isThenable(value) {
        return value &amp;&amp; value.then;
    }
    function forwardResolution(value) {
        return value;
    }
    function forwardRejection(rejection) {
        return ZoneAwarePromise.reject(rejection);
    }
    var symbolState = __symbol__('state');
    var symbolValue = __symbol__('value');
    var source = 'Promise.then';
    var UNRESOLVED = null;
    var RESOLVED = true;
    var REJECTED = false;
    var REJECTED_NO_CATCH = 0;
    function makeResolver(promise, state) {
        return function (v) {
            try {
                resolvePromise(promise, state, v);
            }
            catch (err) {
                resolvePromise(promise, false, err);
            }
            // Do not return value or you will break the Promise spec.
        };
    }
    var once = function () {
        var wasCalled = false;
        return function wrapper(wrappedFunction) {
            return function () {
                if (wasCalled) {
                    return;
                }
                wasCalled = true;
                wrappedFunction.apply(null, arguments);
            };
        };
    };
    var TYPE_ERROR = 'Promise resolved with itself';
    var OBJECT = 'object';
    var FUNCTION = 'function';
    var CURRENT_TASK_SYMBOL = __symbol__('currentTask');
    // Promise Resolution
    function resolvePromise(promise, state, value) {
        var onceWrapper = once();
        if (promise === value) {
            throw new TypeError(TYPE_ERROR);
        }
        if (promise[symbolState] === UNRESOLVED) {
            // should only get value.then once based on promise spec.
            var then = null;
            try {
                if (typeof value === OBJECT || typeof value === FUNCTION) {
                    then = value &amp;&amp; value.then;
                }
            }
            catch (err) {
                onceWrapper(function () {
                    resolvePromise(promise, false, err);
                })();
                return promise;
            }
            // if (value instanceof ZoneAwarePromise) {
            if (state !== REJECTED &amp;&amp; value instanceof ZoneAwarePromise &amp;&amp;
                value.hasOwnProperty(symbolState) &amp;&amp; value.hasOwnProperty(symbolValue) &amp;&amp;
                value[symbolState] !== UNRESOLVED) {
                clearRejectedNoCatch(value);
                resolvePromise(promise, value[symbolState], value[symbolValue]);
            }
            else if (state !== REJECTED &amp;&amp; typeof then === FUNCTION) {
                try {
                    then.apply(value, [
                        onceWrapper(makeResolver(promise, state)), onceWrapper(makeResolver(promise, false))
                    ]);
                }
                catch (err) {
                    onceWrapper(function () {
                        resolvePromise(promise, false, err);
                    })();
                }
            }
            else {
                promise[symbolState] = state;
                var queue = promise[symbolValue];
                promise[symbolValue] = value;
                // record task information in value when error occurs, so we can
                // do some additional work such as render longStackTrace
                if (state === REJECTED &amp;&amp; value instanceof Error) {
                    value[CURRENT_TASK_SYMBOL] = Zone.currentTask;
                }
                for (var i = 0; i &lt; queue.length;) {
                    scheduleResolveOrReject(promise, queue[i++], queue[i++], queue[i++], queue[i++]);
                }
                if (queue.length == 0 &amp;&amp; state == REJECTED) {
                    promise[symbolState] = REJECTED_NO_CATCH;
                    try {
                        throw new Error('Uncaught (in promise): ' + value +
                            (value &amp;&amp; value.stack ? '\n' + value.stack : ''));
                    }
                    catch (err) {
                        var error_1 = err;
                        error_1.rejection = value;
                        error_1.promise = promise;
                        error_1.zone = Zone.current;
                        error_1.task = Zone.currentTask;
                        _uncaughtPromiseErrors.push(error_1);
                        api.scheduleMicroTask(); // to make sure that it is running
                    }
                }
            }
        }
        // Resolving an already resolved promise is a noop.
        return promise;
    }
    var REJECTION_HANDLED_HANDLER = __symbol__('rejectionHandledHandler');
    function clearRejectedNoCatch(promise) {
        if (promise[symbolState] === REJECTED_NO_CATCH) {
            // if the promise is rejected no catch status
            // and queue.length > 0, means there is a error handler
            // here to handle the rejected promise, we should trigger
            // windows.rejectionhandled eventHandler or nodejs rejectionHandled
            // eventHandler
            try {
                var handler = Zone[REJECTION_HANDLED_HANDLER];
                if (handler &amp;&amp; typeof handler === FUNCTION) {
                    handler.apply(this, [{ rejection: promise[symbolValue], promise: promise }]);
                }
            }
            catch (err) {
            }
            promise[symbolState] = REJECTED;
            for (var i = 0; i &lt; _uncaughtPromiseErrors.length; i++) {
                if (promise === _uncaughtPromiseErrors[i].promise) {
                    _uncaughtPromiseErrors.splice(i, 1);
                }
            }
        }
    }
    function scheduleResolveOrReject(promise, zone, chainPromise, onFulfilled, onRejected) {
        clearRejectedNoCatch(promise);
        var delegate = promise[symbolState] ?
            (typeof onFulfilled === FUNCTION) ? onFulfilled : forwardResolution :
            (typeof onRejected === FUNCTION) ? onRejected : forwardRejection;
        zone.scheduleMicroTask(source, function () {
            try {
                resolvePromise(chainPromise, true, zone.run(delegate, undefined, [promise[symbolValue]]));
            }
            catch (error) {
                resolvePromise(chainPromise, false, error);
            }
        });
    }
    var ZONE_AWARE_PROMISE_TO_STRING = 'function ZoneAwarePromise() { [native code] }';
    var ZoneAwarePromise = (function () {
        function ZoneAwarePromise(executor) {
            var promise = this;
            if (!(promise instanceof ZoneAwarePromise)) {
                throw new Error('Must be an instanceof Promise.');
            }
            promise[symbolState] = UNRESOLVED;
            promise[symbolValue] = []; // queue;
            try {
                executor &amp;&amp; executor(makeResolver(promise, RESOLVED), makeResolver(promise, REJECTED));
            }
            catch (error) {
                resolvePromise(promise, false, error);
            }
        }
        ZoneAwarePromise.toString = function () {
            return ZONE_AWARE_PROMISE_TO_STRING;
        };
        ZoneAwarePromise.resolve = function (value) {
            return resolvePromise(new this(null), RESOLVED, value);
        };
        ZoneAwarePromise.reject = function (error) {
            return resolvePromise(new this(null), REJECTED, error);
        };
        ZoneAwarePromise.race = function (values) {
            var resolve;
            var reject;
            var promise = new this(function (res, rej) {
                _a = __read([res, rej], 2), resolve = _a[0], reject = _a[1];
                var _a;
            });
            function onResolve(value) {
                promise &amp;&amp; (promise = null || resolve(value));
            }
            function onReject(error) {
                promise &amp;&amp; (promise = null || reject(error));
            }
            try {
                for (var values_1 = __values(values), values_1_1 = values_1.next(); !values_1_1.done; values_1_1 = values_1.next()) {
                    var value = values_1_1.value;
                    if (!isThenable(value)) {
                        value = this.resolve(value);
                    }
                    value.then(onResolve, onReject);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (values_1_1 &amp;&amp; !values_1_1.done &amp;&amp; (_a = values_1.return)) _a.call(values_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return promise;
            var e_1, _a;
        };
        ZoneAwarePromise.all = function (values) {
            var resolve;
            var reject;
            var promise = new this(function (res, rej) {
                resolve = res;
                reject = rej;
            });
            var count = 0;
            var resolvedValues = [];
            try {
                for (var values_2 = __values(values), values_2_1 = values_2.next(); !values_2_1.done; values_2_1 = values_2.next()) {
                    var value = values_2_1.value;
                    if (!isThenable(value)) {
                        value = this.resolve(value);
                    }
                    value.then((function (index) { return function (value) {
                        resolvedValues[index] = value;
                        count--;
                        if (!count) {
                            resolve(resolvedValues);
                        }
                    }; })(count), reject);
                    count++;
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (values_2_1 &amp;&amp; !values_2_1.done &amp;&amp; (_a = values_2.return)) _a.call(values_2);
                }
                finally { if (e_2) throw e_2.error; }
            }
            if (!count)
                resolve(resolvedValues);
            return promise;
            var e_2, _a;
        };
        ZoneAwarePromise.prototype.then = function (onFulfilled, onRejected) {
            var chainPromise = new this.constructor(null);
            var zone = Zone.current;
            if (this[symbolState] == UNRESOLVED) {
                this[symbolValue].push(zone, chainPromise, onFulfilled, onRejected);
            }
            else {
                scheduleResolveOrReject(this, zone, chainPromise, onFulfilled, onRejected);
            }
            return chainPromise;
        };
        ZoneAwarePromise.prototype.catch = function (onRejected) {
            return this.then(null, onRejected);
        };
        return ZoneAwarePromise;
    }());
    // Protect against aggressive optimizers dropping seemingly unused properties.
    // E.g. Closure Compiler in advanced mode.
    ZoneAwarePromise['resolve'] = ZoneAwarePromise.resolve;
    ZoneAwarePromise['reject'] = ZoneAwarePromise.reject;
    ZoneAwarePromise['race'] = ZoneAwarePromise.race;
    ZoneAwarePromise['all'] = ZoneAwarePromise.all;
    var NativePromise = global[symbolPromise] = global['Promise'];
    var ZONE_AWARE_PROMISE = Zone.__symbol__('ZoneAwarePromise');
    var desc = Object.getOwnPropertyDescriptor(global, 'Promise');
    if (!desc || desc.configurable) {
        desc &amp;&amp; delete desc.writable;
        desc &amp;&amp; delete desc.value;
        if (!desc) {
            desc = { configurable: true, enumerable: true };
        }
        desc.get = function () {
            // if we already set ZoneAwarePromise, use patched one
            // otherwise return native one.
            return global[ZONE_AWARE_PROMISE] ? global[ZONE_AWARE_PROMISE] : global[symbolPromise];
        };
        desc.set = function (NewNativePromise) {
            if (NewNativePromise === ZoneAwarePromise) {
                // if the NewNativePromise is ZoneAwarePromise
                // save to global
                global[ZONE_AWARE_PROMISE] = NewNativePromise;
            }
            else {
                // if the NewNativePromise is not ZoneAwarePromise
                // for example: after load zone.js, some library just
                // set es6-promise to global, if we set it to global
                // directly, assertZonePatched will fail and angular
                // will not loaded, so we just set the NewNativePromise
                // to global[symbolPromise], so the result is just like
                // we load ES6 Promise before zone.js
                global[symbolPromise] = NewNativePromise;
                if (!NewNativePromise.prototype[symbolThen]) {
                    patchThen(NewNativePromise);
                }
                api.setNativePromise(NewNativePromise);
            }
        };
        Object.defineProperty(global, 'Promise', desc);
    }
    global['Promise'] = ZoneAwarePromise;
    var symbolThenPatched = __symbol__('thenPatched');
    function patchThen(Ctor) {
        var proto = Ctor.prototype;
        var originalThen = proto.then;
        // Keep a reference to the original method.
        proto[symbolThen] = originalThen;
        // check Ctor.prototype.then propertyDescritor is writable or not
        // in meteor env, writable is false, we have to make it to be true.
        var prop = Object.getOwnPropertyDescriptor(Ctor.prototype, 'then');
        if (prop &amp;&amp; prop.writable === false &amp;&amp; prop.configurable) {
            Object.defineProperty(Ctor.prototype, 'then', { writable: true });
        }
        Ctor.prototype.then = function (onResolve, onReject) {
            var _this = this;
            var wrapped = new ZoneAwarePromise(function (resolve, reject) {
                originalThen.call(_this, resolve, reject);
            });
            return wrapped.then(onResolve, onReject);
        };
        Ctor[symbolThenPatched] = true;
    }
    function zoneify(fn) {
        return function () {
            var resultPromise = fn.apply(this, arguments);
            if (resultPromise instanceof ZoneAwarePromise) {
                return resultPromise;
            }
            var ctor = resultPromise.constructor;
            if (!ctor[symbolThenPatched]) {
                patchThen(ctor);
            }
            return resultPromise;
        };
    }
    if (NativePromise) {
        patchThen(NativePromise);
        var fetch_1 = global['fetch'];
        if (typeof fetch_1 == FUNCTION) {
            global['fetch'] = zoneify(fetch_1);
        }
    }
    // This is not part of public API, but it is useful for tests, so we expose it.
    Promise[Zone.__symbol__('uncaughtPromiseErrors')] = _uncaughtPromiseErrors;
    return ZoneAwarePromise;
});

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Suppress closure compiler errors about unknown 'Zone' variable
 * @fileoverview
 * @suppress {undefinedVars,globalThis,missingRequire}
 */
var zoneSymbol = Zone.__symbol__;
var _global = typeof window === 'object' &amp;&amp; window || typeof self === 'object' &amp;&amp; self || global;
var FUNCTION = 'function';
var UNDEFINED = 'undefined';


function isPropertyWritable(propertyDesc) {
    if (!propertyDesc) {
        return true;
    }
    if (propertyDesc.writable === false) {
        return false;
    }
    if (typeof propertyDesc.get === FUNCTION &amp;&amp; typeof propertyDesc.set === UNDEFINED) {
        return false;
    }
    return true;
}
var isWebWorker = (typeof WorkerGlobalScope !== 'undefined' &amp;&amp; self instanceof WorkerGlobalScope);
// Make sure to access `process` through `_global` so that WebPack does not accidently browserify
// this code.
var isNode = (!('nw' in _global) &amp;&amp; typeof _global.process !== 'undefined' &amp;&amp;
    {}.toString.call(_global.process) === '[object process]');

// we are in electron of nw, so we are both browser and nodejs
// Make sure to access `process` through `_global` so that WebPack does not accidently browserify
// this code.
var isMix = typeof _global.process !== 'undefined' &amp;&amp;
    {}.toString.call(_global.process) === '[object process]' &amp;&amp; !isWebWorker &amp;&amp;
    !!(typeof window !== 'undefined' &amp;&amp; window['HTMLElement']);


var originalInstanceKey = zoneSymbol('originalInstance');
// wrap some native API on `window`

function patchMethod(target, name, patchFn) {
    var proto = target;
    while (proto &amp;&amp; !proto.hasOwnProperty(name)) {
        proto = Object.getPrototypeOf(proto);
    }
    if (!proto &amp;&amp; target[name]) {
        // somehow we did not find it, but we can see it. This happens on IE for Window properties.
        proto = target;
    }
    var delegateName = zoneSymbol(name);
    var delegate;
    if (proto &amp;&amp; !(delegate = proto[delegateName])) {
        delegate = proto[delegateName] = proto[name];
        // check whether proto[name] is writable
        // some property is readonly in safari, such as HtmlCanvasElement.prototype.toBlob
        var desc = proto &amp;&amp; Object.getOwnPropertyDescriptor(proto, name);
        if (isPropertyWritable(desc)) {
            var patchDelegate_1 = patchFn(delegate, delegateName, name);
            proto[name] = function () {
                return patchDelegate_1(this, arguments);
            };
            attachOriginToPatched(proto[name], delegate);
        }
    }
    return delegate;
}
// TODO: @JiaLiPassion, support cancel task later if necessary
function patchMacroTask(obj, funcName, metaCreator) {
    var setNative = null;
    function scheduleTask(task) {
        var data = task.data;
        data.args[data.callbackIndex] = function () {
            task.invoke.apply(this, arguments);
        };
        setNative.apply(data.target, data.args);
        return task;
    }
    setNative = patchMethod(obj, funcName, function (delegate) { return function (self, args) {
        var meta = metaCreator(self, args);
        if (meta.callbackIndex >= 0 &amp;&amp; typeof args[meta.callbackIndex] === 'function') {
            var task = Zone.current.scheduleMacroTask(meta.name, args[meta.callbackIndex], meta, scheduleTask, null);
            return task;
        }
        else {
            // cause an error by calling it directly.
            return delegate.apply(self, args);
        }
    }; });
}
function patchMicroTask(obj, funcName, metaCreator) {
    var setNative = null;
    function scheduleTask(task) {
        var data = task.data;
        data.args[data.callbackIndex] = function () {
            task.invoke.apply(this, arguments);
        };
        setNative.apply(data.target, data.args);
        return task;
    }
    setNative = patchMethod(obj, funcName, function (delegate) { return function (self, args) {
        var meta = metaCreator(self, args);
        if (meta.callbackIndex >= 0 &amp;&amp; typeof args[meta.callbackIndex] === 'function') {
            var task = Zone.current.scheduleMicroTask(meta.name, args[meta.callbackIndex], meta, scheduleTask);
            return task;
        }
        else {
            // cause an error by calling it directly.
            return delegate.apply(self, args);
        }
    }; });
}
function attachOriginToPatched(patched, original) {
    patched[zoneSymbol('OriginalDelegate')] = original;
}

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
// override Function.prototype.toString to make zone.js patched function
// look like native function
Zone.__load_patch('toString', function (global, Zone, api) {
    // patch Func.prototype.toString to let them look like native
    var originalFunctionToString = Zone['__zone_symbol__originalToString'] =
        Function.prototype.toString;
    var FUNCTION = 'function';
    var ORIGINAL_DELEGATE_SYMBOL = zoneSymbol('OriginalDelegate');
    var PROMISE_SYMBOL = zoneSymbol('Promise');
    var ERROR_SYMBOL = zoneSymbol('Error');
    Function.prototype.toString = function () {
        if (typeof this === FUNCTION) {
            var originalDelegate = this[ORIGINAL_DELEGATE_SYMBOL];
            if (originalDelegate) {
                if (typeof originalDelegate === FUNCTION) {
                    return originalFunctionToString.apply(this[ORIGINAL_DELEGATE_SYMBOL], arguments);
                }
                else {
                    return Object.prototype.toString.call(originalDelegate);
                }
            }
            if (this === Promise) {
                var nativePromise = global[PROMISE_SYMBOL];
                if (nativePromise) {
                    return originalFunctionToString.apply(nativePromise, arguments);
                }
            }
            if (this === Error) {
                var nativeError = global[ERROR_SYMBOL];
                if (nativeError) {
                    return originalFunctionToString.apply(nativeError, arguments);
                }
            }
        }
        return originalFunctionToString.apply(this, arguments);
    };
    // patch Object.prototype.toString to let them look like native
    var originalObjectToString = Object.prototype.toString;
    var PROMISE_OBJECT_TO_STRING = '[object Promise]';
    Object.prototype.toString = function () {
        if (this instanceof Promise) {
            return PROMISE_OBJECT_TO_STRING;
        }
        return originalObjectToString.apply(this, arguments);
    };
});

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @fileoverview
 * @suppress {missingRequire}
 */
var __read$1 = (undefined &amp;&amp; undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" &amp;&amp; o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) &amp;&amp; !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r &amp;&amp; !r.done &amp;&amp; (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (undefined &amp;&amp; undefined.__spread) || function () {
    for (var ar = [], i = 0; i &lt; arguments.length; i++) ar = ar.concat(__read$1(arguments[i]));
    return ar;
};
var TRUE_STR = 'true';
var FALSE_STR = 'false';
// an identifier to tell ZoneTask do not create a new invoke closure
var OPTIMIZED_ZONE_EVENT_TASK_DATA = {
    isUsingGlobalCallback: true
};
var zoneSymbolEventNames$1 = {};
var globalSources = {};
var CONSTRUCTOR_NAME = 'name';
var FUNCTION_TYPE = 'function';
var OBJECT_TYPE = 'object';
var ZONE_SYMBOL_PREFIX = '__zone_symbol__';
var EVENT_NAME_SYMBOL_REGX = /^__zone_symbol__(\w+)(true|false)$/;
var IMMEDIATE_PROPAGATION_SYMBOL = ('__zone_symbol__propagationStopped');
function patchEventTarget(_global, apis, patchOptions) {
    var ADD_EVENT_LISTENER = (patchOptions &amp;&amp; patchOptions.addEventListenerFnName) || 'addEventListener';
    var REMOVE_EVENT_LISTENER = (patchOptions &amp;&amp; patchOptions.removeEventListenerFnName) || 'removeEventListener';
    var LISTENERS_EVENT_LISTENER = (patchOptions &amp;&amp; patchOptions.listenersFnName) || 'eventListeners';
    var REMOVE_ALL_LISTENERS_EVENT_LISTENER = (patchOptions &amp;&amp; patchOptions.removeAllFnName) || 'removeAllListeners';
    var zoneSymbolAddEventListener = zoneSymbol(ADD_EVENT_LISTENER);
    var ADD_EVENT_LISTENER_SOURCE = '.' + ADD_EVENT_LISTENER + ':';
    var PREPEND_EVENT_LISTENER = 'prependListener';
    var PREPEND_EVENT_LISTENER_SOURCE = '.' + PREPEND_EVENT_LISTENER + ':';
    var invokeTask = function (task, target, event) {
        // for better performance, check isRemoved which is set
        // by removeEventListener
        if (task.isRemoved) {
            return;
        }
        var delegate = task.callback;
        if (typeof delegate === OBJECT_TYPE &amp;&amp; delegate.handleEvent) {
            // create the bind version of handleEvent when invoke
            task.callback = function (event) { return delegate.handleEvent(event); };
            task.originalDelegate = delegate;
        }
        // invoke static task.invoke
        task.invoke(task, target, [event]);
        var options = task.options;
        if (options &amp;&amp; typeof options === 'object' &amp;&amp; options.once) {
            // if options.once is true, after invoke once remove listener here
            // only browser need to do this, nodejs eventEmitter will cal removeListener
            // inside EventEmitter.once
            var delegate_1 = task.originalDelegate ? task.originalDelegate : task.callback;
            target[REMOVE_EVENT_LISTENER].apply(target, [event.type, delegate_1, options]);
        }
    };
    // global shared zoneAwareCallback to handle all event callback with capture = false
    var globalZoneAwareCallback = function (event) {
        // https://github.com/angular/zone.js/issues/911, in IE, sometimes
        // event will be undefined, so we need to use window.event
        event = event || _global.event;
        if (!event) {
            return;
        }
        // event.target is needed for Samusung TV and SourceBuffer
        // || global is needed https://github.com/angular/zone.js/issues/190
        var target = this || event.target || _global;
        var tasks = target[zoneSymbolEventNames$1[event.type][FALSE_STR]];
        if (tasks) {
            // invoke all tasks which attached to current target with given event.type and capture = false
            // for performance concern, if task.length === 1, just invoke
            if (tasks.length === 1) {
                invokeTask(tasks[0], target, event);
            }
            else {
                // https://github.com/angular/zone.js/issues/836
                // copy the tasks array before invoke, to avoid
                // the callback will remove itself or other listener
                var copyTasks = tasks.slice();
                for (var i = 0; i &lt; copyTasks.length; i++) {
                    if (event &amp;&amp; event[IMMEDIATE_PROPAGATION_SYMBOL] === true) {
                        break;
                    }
                    invokeTask(copyTasks[i], target, event);
                }
            }
        }
    };
    // global shared zoneAwareCallback to handle all event callback with capture = true
    var globalZoneAwareCaptureCallback = function (event) {
        // https://github.com/angular/zone.js/issues/911, in IE, sometimes
        // event will be undefined, so we need to use window.event
        event = event || _global.event;
        if (!event) {
            return;
        }
        // event.target is needed for Samusung TV and SourceBuffer
        // || global is needed https://github.com/angular/zone.js/issues/190
        var target = this || event.target || _global;
        var tasks = target[zoneSymbolEventNames$1[event.type][TRUE_STR]];
        if (tasks) {
            // invoke all tasks which attached to current target with given event.type and capture = false
            // for performance concern, if task.length === 1, just invoke
            if (tasks.length === 1) {
                invokeTask(tasks[0], target, event);
            }
            else {
                // https://github.com/angular/zone.js/issues/836
                // copy the tasks array before invoke, to avoid
                // the callback will remove itself or other listener
                var copyTasks = tasks.slice();
                for (var i = 0; i &lt; copyTasks.length; i++) {
                    if (event &amp;&amp; event[IMMEDIATE_PROPAGATION_SYMBOL] === true) {
                        break;
                    }
                    invokeTask(copyTasks[i], target, event);
                }
            }
        }
    };
    function patchEventTargetMethods(obj, patchOptions) {
        if (!obj) {
            return false;
        }
        var useGlobalCallback = true;
        if (patchOptions &amp;&amp; patchOptions.useGlobalCallback !== undefined) {
            useGlobalCallback = patchOptions.useGlobalCallback;
        }
        var validateHandler = patchOptions &amp;&amp; patchOptions.validateHandler;
        var checkDuplicate = true;
        if (patchOptions &amp;&amp; patchOptions.checkDuplicate !== undefined) {
            checkDuplicate = patchOptions.checkDuplicate;
        }
        var returnTarget = false;
        if (patchOptions &amp;&amp; patchOptions.returnTarget !== undefined) {
            returnTarget = patchOptions.returnTarget;
        }
        var proto = obj;
        while (proto &amp;&amp; !proto.hasOwnProperty(ADD_EVENT_LISTENER)) {
            proto = Object.getPrototypeOf(proto);
        }
        if (!proto &amp;&amp; obj[ADD_EVENT_LISTENER]) {
            // somehow we did not find it, but we can see it. This happens on IE for Window properties.
            proto = obj;
        }
        if (!proto) {
            return false;
        }
        if (proto[zoneSymbolAddEventListener]) {
            return false;
        }
        // a shared global taskData to pass data for scheduleEventTask
        // so we do not need to create a new object just for pass some data
        var taskData = {};
        var nativeAddEventListener = proto[zoneSymbolAddEventListener] = proto[ADD_EVENT_LISTENER];
        var nativeRemoveEventListener = proto[zoneSymbol(REMOVE_EVENT_LISTENER)] =
            proto[REMOVE_EVENT_LISTENER];
        var nativeListeners = proto[zoneSymbol(LISTENERS_EVENT_LISTENER)] =
            proto[LISTENERS_EVENT_LISTENER];
        var nativeRemoveAllListeners = proto[zoneSymbol(REMOVE_ALL_LISTENERS_EVENT_LISTENER)] =
            proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER];
        var nativePrependEventListener;
        if (patchOptions &amp;&amp; patchOptions.prependEventListenerFnName) {
            nativePrependEventListener = proto[zoneSymbol(patchOptions.prependEventListenerFnName)] =
                proto[patchOptions.prependEventListenerFnName];
        }
        var customScheduleGlobal = function (task) {
            // if there is already a task for the eventName + capture,
            // just return, because we use the shared globalZoneAwareCallback here.
            if (taskData.isExisting) {
                return;
            }
            return nativeAddEventListener.apply(taskData.target, [
                taskData.eventName,
                taskData.capture ? globalZoneAwareCaptureCallback : globalZoneAwareCallback,
                taskData.options
            ]);
        };
        var customCancelGlobal = function (task) {
            // if task is not marked as isRemoved, this call is directly
            // from Zone.prototype.cancelTask, we should remove the task
            // from tasksList of target first
            if (!task.isRemoved) {
                var symbolEventNames = zoneSymbolEventNames$1[task.eventName];
                var symbolEventName = void 0;
                if (symbolEventNames) {
                    symbolEventName = symbolEventNames[task.capture ? TRUE_STR : FALSE_STR];
                }
                var existingTasks = symbolEventName &amp;&amp; task.target[symbolEventName];
                if (existingTasks) {
                    for (var i = 0; i &lt; existingTasks.length; i++) {
                        var existingTask = existingTasks[i];
                        if (existingTask === task) {
                            existingTasks.splice(i, 1);
                            // set isRemoved to data for faster invokeTask check
                            task.isRemoved = true;
                            if (existingTasks.length === 0) {
                                // all tasks for the eventName + capture have gone,
                                // remove globalZoneAwareCallback and remove the task cache from target
                                task.allRemoved = true;
                                task.target[symbolEventName] = null;
                            }
                            break;
                        }
                    }
                }
            }
            // if all tasks for the eventName + capture have gone,
            // we will really remove the global event callback,
            // if not, return
            if (!task.allRemoved) {
                return;
            }
            return nativeRemoveEventListener.apply(task.target, [
                task.eventName, task.capture ? globalZoneAwareCaptureCallback : globalZoneAwareCallback,
                task.options
            ]);
        };
        var customScheduleNonGlobal = function (task) {
            return nativeAddEventListener.apply(taskData.target, [taskData.eventName, task.invoke, taskData.options]);
        };
        var customSchedulePrepend = function (task) {
            return nativePrependEventListener.apply(taskData.target, [taskData.eventName, task.invoke, taskData.options]);
        };
        var customCancelNonGlobal = function (task) {
            return nativeRemoveEventListener.apply(task.target, [task.eventName, task.invoke, task.options]);
        };
        var customSchedule = useGlobalCallback ? customScheduleGlobal : customScheduleNonGlobal;
        var customCancel = useGlobalCallback ? customCancelGlobal : customCancelNonGlobal;
        var compareTaskCallbackVsDelegate = function (task, delegate) {
            var typeOfDelegate = typeof delegate;
            if ((typeOfDelegate === FUNCTION_TYPE &amp;&amp; task.callback === delegate) ||
                (typeOfDelegate === OBJECT_TYPE &amp;&amp; task.originalDelegate === delegate)) {
                // same callback, same capture, same event name, just return
                return true;
            }
            return false;
        };
        var compare = (patchOptions &amp;&amp; patchOptions.compareTaskCallbackVsDelegate) ?
            patchOptions.compareTaskCallbackVsDelegate :
            compareTaskCallbackVsDelegate;
        var makeAddListener = function (nativeListener, addSource, customScheduleFn, customCancelFn, returnTarget, prepend) {
            if (returnTarget === void 0) { returnTarget = false; }
            if (prepend === void 0) { prepend = false; }
            return function () {
                var target = this || _global;
                var targetZone = Zone.current;
                var delegate = arguments[1];
                if (!delegate) {
                    return nativeListener.apply(this, arguments);
                }
                // don't create the bind delegate function for handleEvent
                // case here to improve addEventListener performance
                // we will create the bind delegate when invoke
                var isHandleEvent = false;
                if (typeof delegate !== FUNCTION_TYPE) {
                    if (!delegate.handleEvent) {
                        return nativeListener.apply(this, arguments);
                    }
                    isHandleEvent = true;
                }
                if (validateHandler &amp;&amp; !validateHandler(nativeListener, delegate, target, arguments)) {
                    return;
                }
                var eventName = arguments[0];
                var options = arguments[2];
                var capture;
                var once = false;
                if (options === undefined) {
                    capture = false;
                }
                else if (options === true) {
                    capture = true;
                }
                else if (options === false) {
                    capture = false;
                }
                else {
                    capture = options ? !!options.capture : false;
                    once = options ? !!options.once : false;
                }
                var zone = Zone.current;
                var symbolEventNames = zoneSymbolEventNames$1[eventName];
                var symbolEventName;
                if (!symbolEventNames) {
                    // the code is duplicate, but I just want to get some better performance
                    var falseEventName = eventName + FALSE_STR;
                    var trueEventName = eventName + TRUE_STR;
                    var symbol = ZONE_SYMBOL_PREFIX + falseEventName;
                    var symbolCapture = ZONE_SYMBOL_PREFIX + trueEventName;
                    zoneSymbolEventNames$1[eventName] = {};
                    zoneSymbolEventNames$1[eventName][FALSE_STR] = symbol;
                    zoneSymbolEventNames$1[eventName][TRUE_STR] = symbolCapture;
                    symbolEventName = capture ? symbolCapture : symbol;
                }
                else {
                    symbolEventName = symbolEventNames[capture ? TRUE_STR : FALSE_STR];
                }
                var existingTasks = target[symbolEventName];
                var isExisting = false;
                if (existingTasks) {
                    // already have task registered
                    isExisting = true;
                    if (checkDuplicate) {
                        for (var i = 0; i &lt; existingTasks.length; i++) {
                            if (compare(existingTasks[i], delegate)) {
                                // same callback, same capture, same event name, just return
                                return;
                            }
                        }
                    }
                }
                else {
                    existingTasks = target[symbolEventName] = [];
                }
                var source;
                var constructorName = target.constructor[CONSTRUCTOR_NAME];
                var targetSource = globalSources[constructorName];
                if (targetSource) {
                    source = targetSource[eventName];
                }
                if (!source) {
                    source = constructorName + addSource + eventName;
                }
                // do not create a new object as task.data to pass those things
                // just use the global shared one
                taskData.options = options;
                if (once) {
                    // if addEventListener with once options, we don't pass it to
                    // native addEventListener, instead we keep the once setting
                    // and handle ourselves.
                    taskData.options.once = false;
                }
                taskData.target = target;
                taskData.capture = capture;
                taskData.eventName = eventName;
                taskData.isExisting = isExisting;
                var data = useGlobalCallback ? OPTIMIZED_ZONE_EVENT_TASK_DATA : null;
                var task = zone.scheduleEventTask(source, delegate, data, customScheduleFn, customCancelFn);
                // have to save those information to task in case
                // application may call task.zone.cancelTask() directly
                if (once) {
                    options.once = true;
                }
                task.options = options;
                task.target = target;
                task.capture = capture;
                task.eventName = eventName;
                if (isHandleEvent) {
                    // save original delegate for compare to check duplicate
                    task.originalDelegate = delegate;
                }
                if (!prepend) {
                    existingTasks.push(task);
                }
                else {
                    existingTasks.unshift(task);
                }
                if (returnTarget) {
                    return target;
                }
            };
        };
        proto[ADD_EVENT_LISTENER] = makeAddListener(nativeAddEventListener, ADD_EVENT_LISTENER_SOURCE, customSchedule, customCancel, returnTarget);
        if (nativePrependEventListener) {
            proto[PREPEND_EVENT_LISTENER] = makeAddListener(nativePrependEventListener, PREPEND_EVENT_LISTENER_SOURCE, customSchedulePrepend, customCancel, returnTarget, true);
        }
        proto[REMOVE_EVENT_LISTENER] = function () {
            var target = this || _global;
            var eventName = arguments[0];
            var options = arguments[2];
            var capture;
            if (options === undefined) {
                capture = false;
            }
            else if (options === true) {
                capture = true;
            }
            else if (options === false) {
                capture = false;
            }
            else {
                capture = options ? !!options.capture : false;
            }
            var delegate = arguments[1];
            if (!delegate) {
                return nativeRemoveEventListener.apply(this, arguments);
            }
            if (validateHandler &amp;&amp;
                !validateHandler(nativeRemoveEventListener, delegate, target, arguments)) {
                return;
            }
            var symbolEventNames = zoneSymbolEventNames$1[eventName];
            var symbolEventName;
            if (symbolEventNames) {
                symbolEventName = symbolEventNames[capture ? TRUE_STR : FALSE_STR];
            }
            var existingTasks = symbolEventName &amp;&amp; target[symbolEventName];
            if (existingTasks) {
                for (var i = 0; i &lt; existingTasks.length; i++) {
                    var existingTask = existingTasks[i];
                    var typeOfDelegate = typeof delegate;
                    if (compare(existingTask, delegate)) {
                        existingTasks.splice(i, 1);
                        // set isRemoved to data for faster invokeTask check
                        existingTask.isRemoved = true;
                        if (existingTasks.length === 0) {
                            // all tasks for the eventName + capture have gone,
                            // remove globalZoneAwareCallback and remove the task cache from target
                            existingTask.allRemoved = true;
                            target[symbolEventName] = null;
                        }
                        existingTask.zone.cancelTask(existingTask);
                        return;
                    }
                }
            }
        };
        proto[LISTENERS_EVENT_LISTENER] = function () {
            var target = this || _global;
            var eventName = arguments[0];
            var listeners = [];
            var tasks = findEventTasks(target, eventName);
            for (var i = 0; i &lt; tasks.length; i++) {
                var task = tasks[i];
                var delegate = task.originalDelegate ? task.originalDelegate : task.callback;
                listeners.push(delegate);
            }
            return listeners;
        };
        proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER] = function () {
            var target = this || _global;
            var eventName = arguments[0];
            if (!eventName) {
                var keys = Object.keys(target);
                for (var i = 0; i &lt; keys.length; i++) {
                    var prop = keys[i];
                    var match = EVENT_NAME_SYMBOL_REGX.exec(prop);
                    var evtName = match &amp;&amp; match[1];
                    // in nodejs EventEmitter, removeListener event is
                    // used for monitoring the removeListener call,
                    // so just keep removeListener eventListener until
                    // all other eventListeners are removed
                    if (evtName &amp;&amp; evtName !== 'removeListener') {
                        this[REMOVE_ALL_LISTENERS_EVENT_LISTENER].apply(this, [evtName]);
                    }
                }
                // remove removeListener listener finally
                this[REMOVE_ALL_LISTENERS_EVENT_LISTENER].apply(this, ['removeListener']);
            }
            else {
                var symbolEventNames = zoneSymbolEventNames$1[eventName];
                if (symbolEventNames) {
                    var symbolEventName = symbolEventNames[FALSE_STR];
                    var symbolCaptureEventName = symbolEventNames[TRUE_STR];
                    var tasks = target[symbolEventName];
                    var captureTasks = target[symbolCaptureEventName];
                    if (tasks) {
                        var removeTasks = __spread(tasks);
                        for (var i = 0; i &lt; removeTasks.length; i++) {
                            var task = removeTasks[i];
                            var delegate = task.originalDelegate ? task.originalDelegate : task.callback;
                            this[REMOVE_EVENT_LISTENER].apply(this, [eventName, delegate, task.options]);
                        }
                    }
                    if (captureTasks) {
                        var removeTasks = __spread(captureTasks);
                        for (var i = 0; i &lt; removeTasks.length; i++) {
                            var task = removeTasks[i];
                            var delegate = task.originalDelegate ? task.originalDelegate : task.callback;
                            this[REMOVE_EVENT_LISTENER].apply(this, [eventName, delegate, task.options]);
                        }
                    }
                }
            }
        };
        // for native toString patch
        attachOriginToPatched(proto[ADD_EVENT_LISTENER], nativeAddEventListener);
        attachOriginToPatched(proto[REMOVE_EVENT_LISTENER], nativeRemoveEventListener);
        if (nativeRemoveAllListeners) {
            attachOriginToPatched(proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER], nativeRemoveAllListeners);
        }
        if (nativeListeners) {
            attachOriginToPatched(proto[LISTENERS_EVENT_LISTENER], nativeListeners);
        }
        return true;
    }
    var results = [];
    for (var i = 0; i &lt; apis.length; i++) {
        results[i] = patchEventTargetMethods(apis[i], patchOptions);
    }
    return results;
}
function findEventTasks(target, eventName) {
    var foundTasks = [];
    for (var prop in target) {
        var match = EVENT_NAME_SYMBOL_REGX.exec(prop);
        var evtName = match &amp;&amp; match[1];
        if (evtName &amp;&amp; (!eventName || evtName === eventName)) {
            var tasks = target[prop];
            if (tasks) {
                for (var i = 0; i &lt; tasks.length; i++) {
                    foundTasks.push(tasks[i]);
                }
            }
        }
    }
    return foundTasks;
}

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
Zone.__load_patch('EventEmitter', function (global, Zone, api) {
    var callAndReturnFirstParam = function (fn) {
        return function (self, args) {
            fn(self, args);
            return self;
        };
    };
    // For EventEmitter
    var EE_ADD_LISTENER = 'addListener';
    var EE_PREPEND_LISTENER = 'prependListener';
    var EE_REMOVE_LISTENER = 'removeListener';
    var EE_REMOVE_ALL_LISTENER = 'removeAllListeners';
    var EE_LISTENERS = 'listeners';
    var EE_ON = 'on';
    var compareTaskCallbackVsDelegate = function (task, delegate) {
        if (task.callback === delegate || task.callback.listener === delegate) {
            // same callback, same capture, same event name, just return
            return true;
        }
        return false;
    };
    function patchEventEmitterMethods(obj) {
        var result = patchEventTarget(global, [obj], {
            useGlobalCallback: false,
            addEventListenerFnName: EE_ADD_LISTENER,
            removeEventListenerFnName: EE_REMOVE_LISTENER,
            prependEventListenerFnName: EE_PREPEND_LISTENER,
            removeAllFnName: EE_REMOVE_ALL_LISTENER,
            listenersFnName: EE_LISTENERS,
            checkDuplicate: false,
            returnTarget: true,
            compareTaskCallbackVsDelegate: compareTaskCallbackVsDelegate
        });
        if (result &amp;&amp; result[0]) {
            obj[EE_ON] = obj[EE_ADD_LISTENER];
        }
    }
    // EventEmitter
    var events;
    try {
        events = __webpack_require__(6);
    }
    catch (err) {
    }
    if (events &amp;&amp; events.EventEmitter) {
        patchEventEmitterMethods(events.EventEmitter.prototype);
    }
});

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
Zone.__load_patch('fs', function (global, Zone, api) {
    var fs;
    try {
        fs = __webpack_require__(7);
    }
    catch (err) {
    }
    // watch, watchFile, unwatchFile has been patched
    // because EventEmitter has been patched
    var TO_PATCH_MACROTASK_METHODS = [
        'access', 'appendFile', 'chmod', 'chown', 'close', 'exists', 'fchmod',
        'fchown', 'fdatasync', 'fstat', 'fsync', 'ftruncate', 'futimes', 'lchmod',
        'lchown', 'link', 'lstat', 'mkdir', 'mkdtemp', 'open', 'read',
        'readdir', 'readFile', 'readlink', 'realpath', 'rename', 'rmdir', 'stat',
        'symlink', 'truncate', 'unlink', 'utimes', 'write', 'writeFile',
    ];
    if (fs) {
        TO_PATCH_MACROTASK_METHODS.filter(function (name) { return !!fs[name] &amp;&amp; typeof fs[name] === 'function'; })
            .forEach(function (name) {
            patchMacroTask(fs, name, function (self, args) {
                return {
                    name: 'fs.' + name,
                    args: args,
                    callbackIndex: args.length > 0 ? args.length - 1 : -1,
                    target: self
                };
            });
        });
    }
});

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @fileoverview
 * @suppress {missingRequire}
 */
var taskSymbol = zoneSymbol('zoneTask');
function patchTimer(window, setName, cancelName, nameSuffix) {
    var setNative = null;
    var clearNative = null;
    setName += nameSuffix;
    cancelName += nameSuffix;
    var tasksByHandleId = {};
    var NUMBER = 'number';
    var STRING = 'string';
    var FUNCTION = 'function';
    var INTERVAL = 'Interval';
    var TIMEOUT = 'Timeout';
    var NOT_SCHEDULED = 'notScheduled';
    function scheduleTask(task) {
        var data = task.data;
        function timer() {
            try {
                task.invoke.apply(this, arguments);
            }
            finally {
                if (typeof data.handleId === NUMBER) {
                    // in non-nodejs env, we remove timerId
                    // from local cache
                    delete tasksByHandleId[data.handleId];
                }
                else if (data.handleId) {
                    // Node returns complex objects as handleIds
                    // we remove task reference from timer object
                    data.handleId[taskSymbol] = null;
                }
            }
        }
        data.args[0] = timer;
        data.handleId = setNative.apply(window, data.args);
        return task;
    }
    function clearTask(task) {
        return clearNative(task.data.handleId);
    }
    setNative =
        patchMethod(window, setName, function (delegate) { return function (self, args) {
            if (typeof args[0] === FUNCTION) {
                var zone = Zone.current;
                var options = {
                    handleId: null,
                    isPeriodic: nameSuffix === INTERVAL,
                    delay: (nameSuffix === TIMEOUT || nameSuffix === INTERVAL) ? args[1] || 0 : null,
                    args: args
                };
                var task = zone.scheduleMacroTask(setName, args[0], options, scheduleTask, clearTask);
                if (!task) {
                    return task;
                }
                // Node.js must additionally support the ref and unref functions.
                var handle = task.data.handleId;
                if (typeof handle === NUMBER) {
                    // for non nodejs env, we save handleId: task
                    // mapping in local cache for clearTimeout
                    tasksByHandleId[handle] = task;
                }
                else if (handle) {
                    // for nodejs env, we save task
                    // reference in timerId Object for clearTimeout
                    handle[taskSymbol] = task;
                }
                // check whether handle is null, because some polyfill or browser
                // may return undefined from setTimeout/setInterval/setImmediate/requestAnimationFrame
                if (handle &amp;&amp; handle.ref &amp;&amp; handle.unref &amp;&amp; typeof handle.ref === FUNCTION &amp;&amp;
                    typeof handle.unref === FUNCTION) {
                    task.ref = handle.ref.bind(handle);
                    task.unref = handle.unref.bind(handle);
                }
                if (typeof handle === NUMBER || handle) {
                    return handle;
                }
                return task;
            }
            else {
                // cause an error by calling it directly.
                return delegate.apply(window, args);
            }
        }; });
    clearNative =
        patchMethod(window, cancelName, function (delegate) { return function (self, args) {
            var id = args[0];
            var task;
            if (typeof id === NUMBER) {
                // non nodejs env.
                task = tasksByHandleId[id];
            }
            else {
                // nodejs env.
                task = id &amp;&amp; id[taskSymbol];
                // other environments.
                if (!task) {
                    task = id;
                }
            }
            if (task &amp;&amp; typeof task.type === STRING) {
                if (task.state !== NOT_SCHEDULED &amp;&amp;
                    (task.cancelFn &amp;&amp; task.data.isPeriodic || task.runCount === 0)) {
                    if (typeof id === NUMBER) {
                        delete tasksByHandleId[id];
                    }
                    else if (id) {
                        id[taskSymbol] = null;
                    }
                    // Do not cancel already canceled functions
                    task.zone.cancelTask(task);
                }
            }
            else {
                // cause an error by calling it directly.
                delegate.apply(window, args);
            }
        }; });
}

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var set = 'set';
var clear = 'clear';
Zone.__load_patch('node_timers', function (global, Zone, api) {
    // Timers
    var globalUseTimeoutFromTimer = false;
    try {
        var timers = __webpack_require__(8);
        var globalEqualTimersTimeout = global.setTimeout === timers.setTimeout;
        if (!globalEqualTimersTimeout &amp;&amp; !isMix) {
            // 1. if isMix, then we are in mix environment such as Electron
            // we should only patch timers.setTimeout because global.setTimeout
            // have been patched
            // 2. if global.setTimeout not equal timers.setTimeout, check
            // whether global.setTimeout use timers.setTimeout or not
            var originSetTimeout_1 = timers.setTimeout;
            timers.setTimeout = function () {
                globalUseTimeoutFromTimer = true;
                return originSetTimeout_1.apply(this, arguments);
            };
            var detectTimeout = global.setTimeout(function () { }, 100);
            clearTimeout(detectTimeout);
            timers.setTimeout = originSetTimeout_1;
        }
        patchTimer(timers, set, clear, 'Timeout');
        patchTimer(timers, set, clear, 'Interval');
        patchTimer(timers, set, clear, 'Immediate');
    }
    catch (error) {
        // timers module not exists, for example, when we using nativescript
        // timers is not available
    }
    if (isMix) {
        // if we are in mix environment, such as Electron,
        // the global.setTimeout has already been patched,
        // so we just patch timers.setTimeout
        return;
    }
    if (!globalUseTimeoutFromTimer) {
        // 1. global setTimeout equals timers setTimeout
        // 2. or global don't use timers setTimeout(maybe some other library patch setTimeout)
        // 3. or load timers module error happens, we should patch global setTimeout
        patchTimer(global, set, clear, 'Timeout');
        patchTimer(global, set, clear, 'Interval');
        patchTimer(global, set, clear, 'Immediate');
    }
    else {
        // global use timers setTimeout, but not equals
        // this happenes when use nodejs v0.10.x, global setTimeout will
        // use a lazy load version of timers setTimeout
        // we should not double patch timer's setTimeout
        // so we only store the __symbol__ for consistency
        global[Zone.__symbol__('setTimeout')] = global.setTimeout;
        global[Zone.__symbol__('setInterval')] = global.setInterval;
        global[Zone.__symbol__('setImmediate')] = global.setImmediate;
    }
});
// patch process related methods
Zone.__load_patch('nextTick', function (global, Zone, api) {
    // patch nextTick as microTask
    patchMicroTask(process, 'nextTick', function (self, args) {
        return {
            name: 'process.nextTick',
            args: args,
            callbackIndex: (args.length > 0 &amp;&amp; typeof args[0] === 'function') ? 0 : -1,
            target: process
        };
    });
});
Zone.__load_patch('handleUnhandledPromiseRejection', function (global, Zone, api) {
    Zone[api.symbol('unhandledPromiseRejectionHandler')] =
        findProcessPromiseRejectionHandler('unhandledRejection');
    Zone[api.symbol('rejectionHandledHandler')] =
        findProcessPromiseRejectionHandler('rejectionHandled');
    // handle unhandled promise rejection
    function findProcessPromiseRejectionHandler(evtName) {
        return function (e) {
            var eventTasks = findEventTasks(process, evtName);
            eventTasks.forEach(function (eventTask) {
                // process has added unhandledrejection event listener
                // trigger the event listener
                if (evtName === 'unhandledRejection') {
                    eventTask.invoke(e.rejection, e.promise);
                }
                else if (evtName === 'rejectionHandled') {
                    eventTask.invoke(e.promise);
                }
            });
        };
    }
});
// Crypto
Zone.__load_patch('crypto', function (global, Zone, api) {
    var crypto;
    try {
        crypto = __webpack_require__(9);
    }
    catch (err) {
    }
    // use the generic patchMacroTask to patch crypto
    if (crypto) {
        var methodNames = ['randomBytes', 'pbkdf2'];
        methodNames.forEach(function (name) {
            patchMacroTask(crypto, name, function (self, args) {
                return {
                    name: 'crypto.' + name,
                    args: args,
                    callbackIndex: (args.length > 0 &amp;&amp; typeof args[args.length - 1] === 'function') ?
                        args.length - 1 :
                        -1,
                    target: crypto
                };
            });
        });
    }
});
Zone.__load_patch('console', function (global, Zone, api) {
    var consoleMethods = ['dir', 'log', 'info', 'error', 'warn', 'assert', 'debug', 'timeEnd', 'trace'];
    consoleMethods.forEach(function (m) {
        var originalMethod = console[Zone.__symbol__(m)] = console[m];
        if (originalMethod) {
            console[m] = function () {
                var args = Array.prototype.slice.call(arguments);
                if (Zone.current === Zone.root) {
                    return originalMethod.apply(this, args);
                }
                else {
                    return Zone.root.run(originalMethod, this, args);
                }
            };
        }
    });
});

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

})));


/***/ }),
/* 6 */
/***/ (function(module, exports) {

if(typeof __WEBPACK_EXTERNAL_MODULE_6__ === 'undefined') {var e = new Error("Cannot find module \"events\""); e.code = 'MODULE_NOT_FOUND'; throw e;}
module.exports = __WEBPACK_EXTERNAL_MODULE_6__;

/***/ }),
/* 7 */
/***/ (function(module, exports) {

if(typeof __WEBPACK_EXTERNAL_MODULE_7__ === 'undefined') {var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e;}
module.exports = __WEBPACK_EXTERNAL_MODULE_7__;

/***/ }),
/* 8 */
/***/ (function(module, exports) {

if(typeof __WEBPACK_EXTERNAL_MODULE_8__ === 'undefined') {var e = new Error("Cannot find module \"timers\""); e.code = 'MODULE_NOT_FOUND'; throw e;}
module.exports = __WEBPACK_EXTERNAL_MODULE_8__;

/***/ }),
/* 9 */
/***/ (function(module, exports) {

if(typeof __WEBPACK_EXTERNAL_MODULE_9__ === 'undefined') {var e = new Error("Cannot find module \"crypto\""); e.code = 'MODULE_NOT_FOUND'; throw e;}
module.exports = __WEBPACK_EXTERNAL_MODULE_9__;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {// #!/usr/bin/env node
// -*- coding: utf-8 -*-
/** @module angularGeneric *//* !
    region header
    [Project page](http://torben.website/angularGeneric)

    Copyright Torben Sickert (info["~at~"]torben.website) 16.12.2012

    License
    -------

    This library written by torben sickert stand under a creative commons
    naming 3.0 unported license.
    see http://creativecommons.org/licenses/by/3.0/deed.de
    endregion
*/// region imports
Object.defineProperty(exports,'__esModule',{value:true});exports.default=exports.determineProviders=exports.determineDeclarations=exports.determineExports=exports.PaginationComponent=exports.FileInputComponent=exports.TextareaComponent=exports.SimpleInputComponent=exports.InputComponent=exports.CodeEditorComponent=exports.IntervalsInputComponent=exports.IntervalInputComponent=exports.DateTimeValueAccessor=exports.GenericSliderDirective=exports.GenericDateDirective=exports.AbstractValueAccessor=exports.AbstractItemsComponent=exports.AbstractLiveDataComponent=exports.AbstractNativeInputComponent=exports.AbstractInputComponent=exports.AbstractResolver=exports.DataScopeService=exports.DataService=exports.AlertService=exports.ConfirmComponent=exports.CanDeactivateRouteLeaveGuard=exports.defaultAnimation=exports.NumberPercentPipe=exports.StringTemplatePipe=exports.StringStartsWithPipe=exports.StringSliceMatchPipe=exports.StringShowIfPatternMatchesPipe=exports.StringSafeURLPipe=exports.StringSafeStylePipe=exports.StringSafeScriptPipe=exports.StringSafeResourceURLPipe=exports.StringSafeHTMLPipe=exports.StringReplacePipe=exports.StringMaximumLengthPipe=exports.StringMatchPipe=exports.StringHasTimeSuffixPipe=exports.StringEndsWithPipe=exports.ArrayDependentConcatPipe=exports.TypePipe=exports.ReversePipe=exports.ObjectKeysPipe=exports.MapPipe=exports.LimitToPipe=exports.IsDefinedPipe=exports.ExtractRawDataPipe=exports.ExtractDataPipe=exports.AttachmentWithPrefixExistsPipe=exports.GetFilenameByPrefixPipe=exports.AttachmentsAreEqualPipe=exports.determineInjector=exports.InitialDataService=exports.ToolsService=exports.TINY_MCE_DEFAULT_OPTIONS=exports.CODE_MIRROR_DEFAULT_OPTIONS=exports.SYMBOL=exports.currentInstanceToSearchInjectorFor=exports.LAST_KNOWN_DATA=undefined;var _dec,_class,_dec2,_class3,_class4,_temp,_dec3,_class5,_dec4,_class7,_dec5,_class8,_dec6,_class10,_dec7,_class12,_dec8,_class14,_dec9,_class15,_dec10,_class16,_dec11,_class18,_dec12,_class19,_dec13,_class20,_dec14,_class21,_dec15,_class22,_dec16,_class23,_dec17,_class24,_dec18,_class25,_dec19,_class26,_dec20,_class27,_dec21,_class28,_dec22,_class29,_dec23,_class30,_dec24,_class31,_dec25,_class32,_dec26,_class33,_dec27,_class34,_dec28,_class35,_dec29,_class36,_dec30,_class37,_dec31,_dec32,_dec33,_class38,_desc,_value,_class39,_descriptor,_descriptor2,_dec34,_class41,_dec35,_class43,_class44,_temp2,_dec36,_class45,_dec37,_class47,_dec38,_dec39,_dec40,_dec41,_dec42,_dec43,_dec44,_dec45,_dec46,_dec47,_dec48,_dec49,_dec50,_dec51,_dec52,_dec53,_dec54,_dec55,_dec56,_dec57,_desc2,_value2,_class49,_descriptor3,_descriptor4,_descriptor5,_descriptor6,_descriptor7,_descriptor8,_descriptor9,_descriptor10,_descriptor11,_descriptor12,_descriptor13,_descriptor14,_descriptor15,_descriptor16,_descriptor17,_descriptor18,_descriptor19,_descriptor20,_descriptor21,_descriptor22,_class52,_temp3,_dec58,_desc3,_value3,_class54,_descriptor23,_dec59,_dec60,_class56,_desc4,_value4,_class57,_dec61,_dec62,_class59,_desc5,_value5,_class60,_dec63,_class62,_dec64,_dec65,_dec66,_dec67,_dec68,_dec69,_dec70,_dec71,_dec72,_dec73,_dec74,_dec75,_dec76,_dec77,_dec78,_dec79,_dec80,_dec81,_dec82,_dec83,_dec84,_dec85,_dec86,_dec87,_dec88,_class63,_desc6,_value6,_class64,_descriptor24,_descriptor25,_descriptor26,_descriptor27,_descriptor28,_descriptor29,_descriptor30,_descriptor31,_descriptor32,_descriptor33,_descriptor34,_descriptor35,_descriptor36,_descriptor37,_descriptor38,_descriptor39,_descriptor40,_descriptor41,_descriptor42,_descriptor43,_descriptor44,_descriptor45,_descriptor46,_descriptor47,_dec89,_dec90,_dec91,_dec92,_dec93,_dec94,_dec95,_dec96,_dec97,_dec98,_dec99,_dec100,_dec101,_dec102,_dec103,_dec104,_dec105,_dec106,_dec107,_dec108,_dec109,_dec110,_dec111,_dec112,_dec113,_dec114,_dec115,_dec116,_class66,_desc7,_value7,_class67,_descriptor48,_descriptor49,_descriptor50,_descriptor51,_descriptor52,_descriptor53,_descriptor54,_descriptor55,_descriptor56,_descriptor57,_descriptor58,_descriptor59,_descriptor60,_descriptor61,_descriptor62,_descriptor63,_descriptor64,_descriptor65,_descriptor66,_descriptor67,_descriptor68,_descriptor69,_descriptor70,_descriptor71,_descriptor72,_descriptor73,_descriptor74,_dec117,_dec118,_dec119,_dec120,_dec121,_dec122,_dec123,_dec124,_dec125,_class69,_desc8,_value8,_class70,_descriptor75,_descriptor76,_descriptor77,_descriptor78,_descriptor79,_descriptor80,_descriptor81,_descriptor82,_class71,_temp4,_dec126,_dec127,_dec128,_dec129,_dec130,_dec131,_dec132,_dec133,_dec134,_class72,_desc9,_value9,_class73,_descriptor83,_descriptor84,_descriptor85,_descriptor86,_descriptor87,_descriptor88,_descriptor89,_descriptor90,_dec135,_dec136,_dec137,_class75,_desc10,_value10,_class76,_descriptor91,_descriptor92,_dec138,_dec139,_dec140,_dec141,_dec142,_dec143,_dec144,_class78,_desc11,_value11,_class79,_descriptor93,_descriptor94,_descriptor95,_descriptor96,_descriptor97,_descriptor98,_class80,_temp5,_dec145,_dec146,_dec147,_dec148,_dec149,_dec150,_dec151,_dec152,_dec153,_dec154,_dec155,_dec156,_dec157,_dec158,_dec159,_dec160,_dec161,_dec162,_dec163,_dec164,_dec165,_dec166,_dec167,_dec168,_dec169,_dec170,_class81,_desc12,_value12,_class82,_descriptor99,_descriptor100,_descriptor101,_descriptor102,_descriptor103,_descriptor104,_descriptor105,_descriptor106,_descriptor107,_descriptor108,_descriptor109,_descriptor110,_descriptor111,_descriptor112,_descriptor113,_descriptor114,_descriptor115,_descriptor116,_descriptor117,_descriptor118,_descriptor119,_descriptor120,_descriptor121,_descriptor122,_descriptor123,_class83,_temp6,_dec171,_dec172,_dec173,_dec174,_dec175,_dec176,_class84,_desc13,_value13,_class85,_descriptor124,_descriptor125,_descriptor126,_descriptor127,_descriptor128,_dec177,_class87;exports.fadeAnimation=fadeAnimation;var _angularTinymce=__webpack_require__(12);var _blobUtil=__webpack_require__(13);var _clientnode=__webpack_require__(14);var _clientnode2=_interopRequireDefault(_clientnode);var _animations=__webpack_require__(15);var _core=__webpack_require__(0);var _common=__webpack_require__(16);var _forms=__webpack_require__(17);var _material=__webpack_require__(18);var _platformBrowser=__webpack_require__(19);var _router=__webpack_require__(1);var _pouchdb=__webpack_require__(20);var _pouchdb2=_interopRequireDefault(_pouchdb);var _pouchdbFind=__webpack_require__(21);var _pouchdbFind2=_interopRequireDefault(_pouchdbFind);var _pouchdbValidation=__webpack_require__(22);var _pouchdbValidation2=_interopRequireDefault(_pouchdbValidation);var _rxjs=__webpack_require__(2);var _Observable=__webpack_require__(23);var _Subscription=__webpack_require__(24);function _interopRequireDefault(obj){return obj&amp;&amp;obj.__esModule?obj:{default:obj}}function _initDefineProp(target,property,descriptor,context){if(!descriptor)return;Object.defineProperty(target,property,{enumerable:descriptor.enumerable,configurable:descriptor.configurable,writable:descriptor.writable,value:descriptor.initializer?descriptor.initializer.call(context):void 0})}function _applyDecoratedDescriptor(target,property,decorators,descriptor,context){var desc={};Object['ke'+'ys'](descriptor).forEach(function(key){desc[key]=descriptor[key]});desc.enumerable=!!desc.enumerable;desc.configurable=!!desc.configurable;if('value'in desc||desc.initializer){desc.writable=true}desc=decorators.slice().reverse().reduce(function(desc,decorator){return decorator(target,property,desc)||desc},desc);if(context&amp;&amp;desc.initializer!==void 0){desc.value=desc.initializer?desc.initializer.call(context):void 0;desc.initializer=undefined}if(desc.initializer===void 0){Object['define'+'Property'](target,property,desc);desc=null}return desc}function _initializerWarningHelper(descriptor,context){throw new Error('Decorating class property failed. Please ensure that transform-class-properties is enabled.')}function _asyncToGenerator(fn){return function(){var gen=fn.apply(this,arguments);return new Promise(function(resolve,reject){function step(key,arg){try{var info=gen[key](arg);var value=info.value}catch(error){reject(error);return}if(info.done){resolve(value)}else{return Promise.resolve(value).then(function(value){step('next',value)},function(err){step('throw',err)})}}return step('next')})}}// NOTE: Only needed for debugging this file.
try{module.require('source-map-support/register')}catch(error){}// endregion
if(typeof CHANGE_DETECTION_STRATEGY_NAME==='undefined')/* eslint-disable no-var */var CHANGE_DETECTION_STRATEGY_NAME='default';/* eslint-enable no-var */let LAST_KNOWN_DATA=exports.LAST_KNOWN_DATA={data:{},sequence:'now'};let currentInstanceToSearchInjectorFor=exports.currentInstanceToSearchInjectorFor=null;const SYMBOL=exports.SYMBOL=`${new Date().getTime()}/${Math.random()}`;// region configuration
const CODE_MIRROR_DEFAULT_OPTIONS=exports.CODE_MIRROR_DEFAULT_OPTIONS={// region paths
path:{cascadingStyleSheet:'lib/codemirror.css',base:'/codemirror/',mode:'mode/{mode}/{mode}.js',script:'lib/codemirror.js'},// endregion
indentUnit:4,tabSize:4,indentWithTabs:false,lineWrapping:false,lineNumbers:true,scrollbarStyle:'native'};const tinyMCEBasePath='/tinymce/';const TINY_MCE_DEFAULT_OPTIONS=exports.TINY_MCE_DEFAULT_OPTIONS=_clientnode2.default.extendObject(true,_angularTinymce.tinymceDefaultSettings,{/* eslint-disable camelcase */// region paths
baseURL:tinyMCEBasePath,skin_url:`${tinyMCEBasePath}skins/lightgray`,theme_url:`${tinyMCEBasePath}themes/modern/theme.min.js`,tinymceScriptURL:`${tinyMCEBasePath}tinymce.min.js`,// endregion
allow_conditional_comments:false,allow_script_urls:false,cache_suffix:`?version=${1508255358.003}`,convert_fonts_to_spans:true,document_base_url:'/',element_format:'xhtml',entity_encoding:'raw',fix_list_elements:true,forced_root_block:null,hidden_input:false,invalid_elements:'em',invalid_styles:'color font-size line-height',keep_styles:false,menubar:false,/* eslint-disable max-len */plugins:'fullscreen link code hr nonbreaking searchreplace visualblocks',/* eslint-enable max-len */relative_urls:false,remove_script_host:false,remove_trailing_brs:true,schema:'html5',/* eslint-disable max-len */toolbar1:'cut copy paste | undo redo removeformat | styleselect formatselect fontselect fontsizeselect | searchreplace visualblocks fullscreen code',toolbar2:'alignleft aligncenter alignright alignjustify outdent indent | link hr nonbreaking bullist numlist bold italic underline strikethrough',/* eslint-enable max-len */trim:true/* eslint-enable camelcase */});// endregion
// region basic services
// IgnoreTypeCheck
/**
 * Injectable angular service for the tools class.
 * @property $ - Holds an instance of a generic dom abstraction layer like
 * jquery.
 * @property globalContext - Hold a reference to the environment specific
 * global scope.
 * @property tools - Holds a reference to the wrapped tools class.
 */let ToolsService=exports.ToolsService=(_dec=(0,_core.Injectable)(),_dec(_class=class ToolsService{constructor(){this.$=_clientnode.$;this.globalContext=_clientnode.globalContext;this.tools=_clientnode2.default}})||_class);// IgnoreTypeCheck
/**
 * Serves initial data provided via a global variable.
 * @property static:defaultScope - Saves all minimal needed environment
 * variables.
 * @property static:injectors - Saves a set of all root injectors.
 * @property static:removeFoundData - Indicates whether to remove found data to
 * tidy up global scope or free memory (by removing dom node attributes).
 *
 * @property configuration - Expected initial data name.
 * @property tools - Injected or given tools service instance.
 */let InitialDataService=exports.InitialDataService=(_dec2=(0,_core.Injectable)(),_dec2(_class3=(_temp=_class4=class InitialDataService{/**
     * Sets all properties of given initial data as properties to this
     * initializing instance.
     * @param tools - Saves the generic tools service instance.
     * @returns Nothing.
     */constructor(tools){this.configuration=this.configuration;this.tools=this.tools;if(!tools)tools=new ToolsService;this.tools=tools.tools;this.set(this.constructor.defaultScope,tools.globalContext.genericInitialData||{});if(this.constructor.removeFoundData)delete tools.globalContext.genericInitialData;if('document'in tools.globalContext&amp;&amp;'querySelector'in tools.globalContext.document){// TODO how to get right dom node?
const domNode=tools.globalContext.document.querySelector('application');if(domNode&amp;&amp;domNode.getAttribute('initialData')){this.set(JSON.parse(domNode.getAttribute('initialData')));if(this.constructor.removeFoundData)domNode.removeAttribute('initialData')}}}/**
     * Sets initial data.
     * @param parameter - All given data objects will be merged into current
     * scope.
     * @returns Complete generated data.
     */set(...parameter){return this.tools.extendObject(true,this,...parameter)}},_class4.defaultScope={configuration:{database:{connector:{/* eslint-disable camelcase */auto_compaction:true,revs_limit:10/* eslint-enable camelcase */},model:{entities:{},property:{defaultSpecification:{minimum:0,minimumLength:0,minimumNumber:0},name:{reserved:[],special:{allowedRole:'_allowedRoles',attachment:'_attachments',conflict:'_conflicts',constraint:{execution:'_constraintExecutions',expression:'_constraintExpressions'},deleted:'_deleted',deletedConflict:'_deleted_conflicts',extend:'_extends',id:'_id',localSequence:'_local_seq',maximumAggregatedSize:'_maximumAggregatedSize',minimumAggregatedSize:'_minimumAggregatedSize',revision:'_rev',revisions:'_revisions',revisionsInformation:'_revs_info',strategy:'_updateStrategy',type:'-type'},validatedDocumentsCache:'_validatedDocuments'}}},plugins:[],url:'generic'}}},_class4.injectors=new Set,_class4.removeFoundData=true,_temp))||_class3);/**
 * Helper function to easy create abstract classes without tight bounds.
 * @param injector - Application specific injector to use instead auto
 * detected one.
 * @param instance - Instance reference to determine corresponding responsible
 * injector.
 * @param constructor - Matched to given instance to try to inject for each
 * known injector instance.
 * @returns Nothing.
 */Reflect.defineMetadata('design:paramtypes',[ToolsService],InitialDataService);const determineInjector=exports.determineInjector=(injector,instance,constructor)=>{if(injector)return injector.get.bind(injector);if(currentInstanceToSearchInjectorFor===undefined)throw SYMBOL;exports.currentInstanceToSearchInjectorFor=currentInstanceToSearchInjectorFor=undefined;for(const injector of InitialDataService.injectors)try{if(injector.get(constructor,NaN)===instance)return injector.get.bind(injector)}catch(error){exports.currentInstanceToSearchInjectorFor=currentInstanceToSearchInjectorFor=null;if(error===SYMBOL)return injector.get.bind(injector);throw error}exports.currentInstanceToSearchInjectorFor=currentInstanceToSearchInjectorFor=null;if(InitialDataService.injectors.size===1){console.warn('Could not determine injector, but using the only registered '+'one. This will fail an multiple application instances.');const injector=Array.from(InitialDataService.injectors)[0];return injector.get.bind(injector)}throw new Error('No unambiguously injector could be determined automatically.')};// endregion
// region pipes
// / region forwarded methods
// // region configuration
const invert=['array'];const methodGroups={'':['convertCircularObjectToJSON','equals','extendObject','representObject','sort'],array:'*',number:'*',string:'*'// // endregion
};for(const methodTypePrefix in methodGroups)if(methodGroups.hasOwnProperty(methodTypePrefix)){let methodNames=[];if(methodGroups[methodTypePrefix]==='*')/* eslint-disable curly */for(const name of Object.getOwnPropertyNames(_clientnode2.default)){if(_clientnode2.default.hasOwnProperty(name)&amp;&amp;_clientnode2.default.hasOwnProperty(name)&amp;&amp;new RegExp(`^${methodTypePrefix}[A-Z0-9]`).test(name))methodNames.push(name)}/* eslint-enable curly */else methodNames=methodGroups[methodTypePrefix];for(const methodName of methodNames){const pipeName=_clientnode2.default.stringCapitalize(methodName);module.exports[`${pipeName}Pipe`]=class{/**
                 * Performs the concrete conversion logic.
                 * @param parameter - Saves all generic parameter to forward it
                 * for triggering the underlying tools utility.
                 * @returns Whatever the underlying tools function returns.
                 */transform(...parameter){return _core.ReflectiveInjector.resolveAndCreate([ToolsService]).get(ToolsService).tools[methodName](...parameter)}};(0,_core.Pipe)({name:`generic${pipeName}`})(module.exports[`${pipeName}Pipe`]);if(invert.includes(methodTypePrefix)){module.exports[`${pipeName}InvertedPipe`]=class{/**
                     * Performs the concrete conversion logic.
                     * @param parameter - Saves all generic parameter to
                     * forward it for triggering the underlying tools utility.
                     * @returns Whatever the underlying tools function returns.
                     */transform(...parameter){const tools=_core.ReflectiveInjector.resolveAndCreate([ToolsService]).get(ToolsService).tools;// IgnoreTypeCheck
return tools.invertArrayFilter(tools[methodName])(...parameter)}};(0,_core.Pipe)({name:`generic${pipeName}Inverted`})(module.exports[`${pipeName}InvertedPipe`])}}}const ArrayMakeRangePipe=module.exports.ArrayMakeRangePipe;const EqualsPipe=module.exports.EqualsPipe;const ExtendObjectPipe=module.exports.ExtendObjectPipe;const NumberGetUTCTimestampPipe=module.exports.NumberGetUTCTimestampPipe;const RepresentObjectPipe=module.exports.RepresentObjectPipe;const StringCapitalizePipe=module.exports.StringCapitalizePipe;const StringEscapeRegularExpressionsPipe=module.exports.StringEscapeRegularExpressionsPipe;const StringFormatPipe=module.exports.StringFormatPipe;const StringMD5Pipe=module.exports.StringMD5Pipe;// / endregion
// / region object
// IgnoreTypeCheck
/**
 * Determines if given attachments are representing the same data.
 * @property data - Database service instance.
 * @property ngZone - Execution context service instance.
 * @property representObject - Represent object pipe's method.
 * @property specialNames - A mapping to database specific special property
 * names.
 * @property stringMD5 - String md5 pipe's instance transform method.
 */let AttachmentsAreEqualPipe/* implements PipeTransform*/=exports.AttachmentsAreEqualPipe=(_dec3=(0,_core.Pipe)({name:'genericAttachmentsAreEqual'}),_dec3(_class5=class AttachmentsAreEqualPipe{/**
     * Gets needed services injected.
     * @param initialData - Injected initial data service instance.
     * @param injector - Application specific injector instance.
     * @param ngZone - Injected execution context service instance.
     * @param representObjectPipe - Represent object pipe instance.
     * @param stringMD5Pipe - Injected string md5 pipe instance.
     * @returns Nothing.
     */constructor(initialData,injector,ngZone,representObjectPipe,stringMD5Pipe){this.data=this.data;this.ngZone=this.ngZone;this.representObject=this.representObject;this.specialNames=this.specialNames;this.stringMD5=this.stringMD5;this.data=injector.get(DataService);this.ngZone=ngZone;this.representObject=representObjectPipe.transform.bind(representObjectPipe);this.specialNames=initialData.configuration.database.model.property.name.special;this.stringMD5=stringMD5Pipe.transform.bind(stringMD5Pipe)}/**
     * Performs the actual transformations process.
     * @param first - First attachment to compare.
     * @param second - Second attachment to compare.
     * @returns Comparison result.
     */transform(first,second){var _this=this;return _asyncToGenerator(function*(){/*
            Identical implies equality and should be checked first for
            performance.
        */if(first===second)return true;// Normalize properties.
const data={first:{given:first},second:{given:second}};for(const type of['first','second']){if(typeof data[type].given!=='object'||data[type].given===null)return false;/* eslint-disable camelcase */data[type].content_type=data[type].given.type||data[type].given.content_type;/* eslint-enable camelcase */data[type].data=('data'in data[type].given?data[type].given.data:data[type].given)||NaN;data[type].hash=data[type].given.digest||data[type].given.hash||NaN;data[type].size=data[type].given.size||data[type].given.length}// Search for an exclusion criterion.
for(const type of['content_type','size'])if(![data.first[type],data.second[type]].includes(undefined)&amp;&amp;data.first[type]!==data.second[type])return false;// Check for a sufficient criterion.
if(data.first.data===data.second.data)return true;for(const type of['first','second'])if(!data[type].hash){if(data[type].data===null||!['object','string'].includes(typeof data[type].data))return false;const name='genericTemp';const databaseConnection=new _this.data.database(name);try{yield databaseConnection.put({[_this.specialNames.id]:name,[_this.specialNames.attachment]:{[name]:{data:data[type].data,/* eslint-disable camelcase */content_type:'application/octet-stream'/* eslint-enable camelcase */}}});data[type].hash=(yield databaseConnection.get(name))[_this.specialNames.attachment][name].digest}catch(error){let message='unknown';try{message=_this.representObject(error)}catch(error){}console.warn('Given attachments for equality check are not '+`valid: ${message}`);return false}finally{yield databaseConnection.destroy()}}return data.first.hash===data.second.hash})()}})||_class5);// IgnoreTypeCheck
Reflect.defineMetadata('design:paramtypes',[InitialDataService,_core.Injector,_core.NgZone,RepresentObjectPipe,StringMD5Pipe],AttachmentsAreEqualPipe);/**
 * Retrieves a matching filename by given filename prefix.
 */let GetFilenameByPrefixPipe/* implements PipeTransform*/=exports.GetFilenameByPrefixPipe=(_dec4=(0,_core.Pipe)({name:'genericGetFilenameByPrefix'}),_dec4(_class7=class GetFilenameByPrefixPipe{/**
     * Performs the actual transformations process.
     * @param attachments - Documents attachments object to determine file with
     * matching file name prefix.
     * @param prefix - Prefix or nothing to search for. If nothing given first
     * file name will be returned.
     * @returns Matching file name or null if no file matches.
     */transform(attachments,prefix){if(prefix){for(const name in attachments)if(attachments.hasOwnProperty(name)&amp;&amp;name.startsWith(prefix))return name}else{const keys=Object.keys(attachments);if(keys.length)return keys[0]}return null}})||_class7);// IgnoreTypeCheck
/**
 * Retrieves if a filename with given prefix exists.
 * @property attachmentName - Name of attachment property.
 * @property getFilenameByPrefix - Filename by prefix pipe's transformation
 * function.
 */let AttachmentWithPrefixExistsPipe/* implements PipeTransform*/=exports.AttachmentWithPrefixExistsPipe=(_dec5=(0,_core.Pipe)({name:'genericAttachmentWithPrefixExists'}),_dec5(_class8=class AttachmentWithPrefixExistsPipe{/**
     * Gets needed file name by prefix pipe injected.
     * @param getFilenameByPrefixPipe - Filename by prefix pipe instance.
     * @param initialData - Injected initial data service.
     * @returns Nothing.
     */constructor(getFilenameByPrefixPipe,initialData){this.attachmentName=this.attachmentName;this.getFilenameByPrefix=this.getFilenameByPrefix;this.attachmentName=initialData.configuration.database.model.property.name.special.attachment;this.getFilenameByPrefix=getFilenameByPrefixPipe.transform.bind(getFilenameByPrefixPipe)}/**
     * Performs the actual transformations process.
     * @param document - Documents with attachments to analyse.
     * @param namePrefix - Prefix or nothing to search for. If nothing given
     * "false" will be returned either.
     * @returns Boolean indication if given file name prefix exists.
     */transform(document,namePrefix){if(document.hasOwnProperty(this.attachmentName)){const name=this.getFilenameByPrefix(document[this.attachmentName],namePrefix);if(name)return document[this.attachmentName][name].hasOwnProperty('data')&amp;&amp;![undefined,null].includes(document[this.attachmentName][name].data)}return false}})||_class8);// IgnoreTypeCheck
Reflect.defineMetadata('design:paramtypes',[GetFilenameByPrefixPipe,InitialDataService],AttachmentWithPrefixExistsPipe);/**
 * Removes all meta data from a document recursively.
 * @property modelConfiguration - Model configuration object.
 */let ExtractDataPipe/* implements PipeTransform*/=exports.ExtractDataPipe=(_dec6=(0,_core.Pipe)({name:'genericExtractData'}),_dec6(_class10=class ExtractDataPipe{/**
     * Gets injected services.
     * @param initialData - Initial data service instance.
     * @returns Nothing.
     */constructor(initialData){this.modelConfiguration=this.modelConfiguration;this.modelConfiguration=initialData.configuration.database.model}/**
     * Extracts raw data from given scope item.
     * @param item - Item to extract data from.
     * @returns Given extracted data.
     */transform(item){if(Array.isArray(item)){const result=[];for(const subItem of item)result.push(this.transform(subItem));return result}else if(typeof item==='object'&amp;&amp;item!==null){const specialNames=this.modelConfiguration.property.name.special;if(item.hasOwnProperty('value')){if(typeof item.value==='object'&amp;&amp;item.value!==null&amp;&amp;specialNames.type in item.value&amp;&amp;this.modelConfiguration.entities.hasOwnProperty(item.value[specialNames.type]))return this._extractFromObject(item.value);return this.transform(item.value)}else if(specialNames.type in item&amp;&amp;this.modelConfiguration.entities.hasOwnProperty(item[specialNames.type]))return this._extractFromObject(item);return item}return item}/**
     * Retrieves raw data (without meta data) for given scope recursively.
     * @param object - Object to use to determine data from.
     * @returns Resolved data.
     */_extractFromObject(object){const specialNames=this.modelConfiguration.property.name.special;const result={};for(const key in object)if(object.hasOwnProperty(key)&amp;&amp;(!object.hasOwnProperty(specialNames.type)||this.modelConfiguration.entities[object[specialNames.type]].hasOwnProperty(key)||this.modelConfiguration.entities[object[specialNames.type]].hasOwnProperty(specialNames.additional))&amp;&amp;!['_metaData',specialNames.additional,specialNames.allowedRole,// NOTE: Will be handled later.
specialNames.attachment,specialNames.conflict,specialNames.constraint.execution,specialNames.constraint.expression,specialNames.deletedConflict,specialNames.extend,specialNames.localSequence,specialNames.maximumAggregatedSize,specialNames.minimumAggregatedSize,specialNames.revisions,specialNames.revisionsInformations].includes(key))result[key]=this.transform(object[key]);if(object.hasOwnProperty(specialNames.attachment)&amp;&amp;object[specialNames.attachment])for(const key in object[specialNames.attachment])if(object[specialNames.attachment].hasOwnProperty(key)&amp;&amp;typeof object[specialNames.attachment][key]==='object'&amp;&amp;object[specialNames.attachment][key]!==null&amp;&amp;'hasOwnProperty'in object[specialNames.attachment]&amp;&amp;object[specialNames.attachment][key].hasOwnProperty('value')&amp;&amp;object[specialNames.attachment][key].value){if(!result[specialNames.attachment])result[specialNames.attachment]={};result[specialNames.attachment][object[specialNames.attachment][key].value.name]=object[specialNames.attachment][key].value}return result}})||_class10);// IgnoreTypeCheck
Reflect.defineMetadata('design:paramtypes',[InitialDataService],ExtractDataPipe);/**
 * Removes all meta data and already existing data (compared to an old
 * document) from a document recursively.
 * @property attachmentsAreEqual - Attachments are equal pip's transformation
 * method.
 * @property dataScope - Date scope service instance.
 * @property equals - Equals pipe transform function.
 * @property modelConfiguration - Model configuration object.
 * @property numberGetUTCTimestamp - Date (and time) to unix timstamp converter
 * pipe transform function.
 * @property specialnames - A mapping to database specific special property
 * names.
 * @property tools - Holds the tools class from the tools service.
 */let ExtractRawDataPipe/* implements PipeTransform*/=exports.ExtractRawDataPipe=(_dec7=(0,_core.Pipe)({name:'genericExtractRawData'}),_dec7(_class12=class ExtractRawDataPipe{/**
     * Gets injected services.
     * @param attachmentsAreEqualPipe - Injected attachments are equal pipe
     * instance.
     * @param equalsPipe - Equals pipe instance.
     * @param initialData - Initial data service instance.
     * @param injector - Injector service instance.
     * @param numberGetUTCTimestampPipe - Date (and time) to unix timestamp
     * conversion.
     * @param tools - Injected tools service instance.
     * @returns Nothing.
     */constructor(attachmentsAreEqualPipe,equalsPipe,initialData,injector,numberGetUTCTimestampPipe,tools){this.attachmentsAreEqual=this.attachmentsAreEqual;this.equals=this.equals;this.modelConfiguration=this.modelConfiguration;this.numberGetUTCTimestamp=this.numberGetUTCTimestamp;this.specialNames=this.specialNames;this.tools=this.tools;this.attachmentsAreEqual=attachmentsAreEqualPipe.transform.bind(attachmentsAreEqualPipe);this.dataScope=injector.get(DataScopeService);this.equals=equalsPipe.transform.bind(equalsPipe);this.modelConfiguration=initialData.configuration.database.model;this.numberGetUTCTimestamp=numberGetUTCTimestampPipe.transform.bind(numberGetUTCTimestampPipe);this.specialNames=this.modelConfiguration.property.name.special;this.tools=tools.tools}/**
     * Converts all (nested) date object in given data structure to their
     * corresponding utc timestamps in milliseconds.
     * @param value - Given data structure to convert.
     * @returns Given converted object.
     */convertDateToTimestampRecursively(value){if(typeof value==='object'&amp;&amp;value!==null){if(value instanceof Date)return this.numberGetUTCTimestamp(value);if(Array.isArray(value)){const result=[];for(const subValue of value)result.push(this.convertDateToTimestampRecursively(subValue));return result}if(Object.getPrototypeOf(value)===Object.prototype){const result={};for(const name in value)if(value.hasOwnProperty(name))result[name]=this.convertDateToTimestampRecursively(value[name]);return result}}return value}/**
     * Slices already existing attachment content from given new document
     * compared to given existing document.
     * @param newDocument - New document to take into account.
     * @param oldDocument - Old document to take into account for comparison.
     * @param specification - Specification object to check for expected
     * attachment types.
     * @returns An object indicating existing data and sliced given attachment
     * data wrapped in a promise (to asynchronous compare attachment content).
     */getNotAlreadyExistingAttachmentData(newDocument,oldDocument,specification){var _this2=this;return _asyncToGenerator(function*(){const result={};if(specification&amp;&amp;specification.hasOwnProperty(_this2.specialNames.attachment))for(const type in specification[_this2.specialNames.attachment])if(specification[_this2.specialNames.attachment].hasOwnProperty(type)){// region retrieve all type specific existing attachments
const oldAttachments={};if(oldDocument.hasOwnProperty(_this2.specialNames.attachment)&amp;&amp;oldDocument[_this2.specialNames.attachment])for(const fileName in oldDocument[_this2.specialNames.attachment])if(oldDocument[_this2.specialNames.attachment].hasOwnProperty(fileName)&amp;&amp;new RegExp(type).test(fileName))oldAttachments[fileName]=oldDocument[_this2.specialNames.attachment][fileName];// endregion
if(newDocument.hasOwnProperty(_this2.specialNames.attachment))for(const fileName in newDocument[_this2.specialNames.attachment])if(newDocument[_this2.specialNames.attachment].hasOwnProperty(fileName)&amp;&amp;new RegExp(type).test(fileName))// region determine latest attachment
if(newDocument[_this2.specialNames.attachment][fileName].hasOwnProperty('data')||newDocument[_this2.specialNames.attachment][fileName].hasOwnProperty('stub')){// Insert new attachment.
result[fileName]=newDocument[_this2.specialNames.attachment][fileName];// region remove already existing data
if(oldAttachments.hasOwnProperty(fileName)){if(yield _this2.attachmentsAreEqual(newDocument[_this2.specialNames.attachment][fileName],oldAttachments[fileName]))/*
                                                Existing attachment has not
                                                been changed.
                                            */delete result[fileName];delete oldAttachments[fileName]}else if(Object.keys(oldAttachments).length&amp;&amp;specification[_this2.specialNames.attachment][type].maximumNumber===1){const firstOldAttachmentName=Object.keys(oldAttachments)[0];if(yield _this2.attachmentsAreEqual(newDocument[_this2.specialNames.attachment][fileName],oldAttachments[firstOldAttachmentName])){/*
                                                Existing attachment has been
                                                renamed.
                                            */result[fileName]=_this2.tools.copyLimitedRecursively(oldAttachments[firstOldAttachmentName]);result[fileName].name=fileName}}// endregion
}else if(oldAttachments.hasOwnProperty(fileName))// Existing attachment has not been changed.
delete oldAttachments[fileName];else if(Object.keys(oldAttachments).length&amp;&amp;specification[_this2.specialNames.attachment][type].maximumNumber===1){// Existing attachment has been renamed.
const firstOldAttachmentName=Object.keys(oldAttachments)[0];result[fileName]=_this2.tools.copyLimitedRecursively(oldAttachments[firstOldAttachmentName]);result[fileName].name=fileName;delete oldAttachments[firstOldAttachmentName]}// endregion
// region mark all not mentioned old attachments as removed
for(const fileName in oldAttachments)if(oldAttachments.hasOwnProperty(fileName))result[fileName]={data:null// endregion
}}return{payloadExists:Object.keys(result).length!==0,result}})()}/**
     * Remove already existing values and mark removed or truncated values
     * (only respect values if specified in model).
     * @param newData - Data to consider.
     * @param oldData - Old data to use for checking for equality.
     * @param specification - Specification object for given document.
     * @returns An object holding new data and boolean indicating if there
     * exists any payload.
     */removeAlreadyExistingData(newData,oldData,specification){let payloadExists=false;if(Array.isArray(newData)){/*
                NOTE: We do not have to take any specification data into
                account for an array since any change in any item breaks
                complete array equality.
            */if(!this.equals(newData,oldData))payloadExists=true}else if(specification&amp;&amp;typeof newData==='object'&amp;&amp;newData!==null&amp;&amp;typeof oldData==='object'&amp;&amp;oldData!==null){const newPropertyNames=Object.keys(newData);for(const name in oldData)if(oldData.hasOwnProperty(name)){const index=newPropertyNames.indexOf(name);if(index!==-1)newPropertyNames.splice(index,1);if(!this.modelConfiguration.property.name.reserved.concat(this.specialNames.deleted,this.specialNames.id,this.specialNames.revision,this.specialNames.type).includes(name))if(newData.hasOwnProperty(name)){const result=this.removeAlreadyExistingData(newData[name],oldData[name],this.dataScope.determineNestedSpecifcation(name,specification));if(result.payloadExists){payloadExists=true;newData[name]=result.newData}else if(specification.hasOwnProperty(name))delete newData[name]}else{payloadExists=true;newData[name]=null}}if(newPropertyNames.length)payloadExists=true}else if(!this.equals(newData,this.convertDateToTimestampRecursively(oldData)))payloadExists=true;return{newData,payloadExists}}/**
     * Removes all special property names with meta data from given document.
     * @param data - To trim.
     * @param specification - Specification object for given document.
     * @returns Sliced given document.
     */removeMetaData(data,specification){if(data instanceof Date)return this.numberGetUTCTimestamp(data);if(Array.isArray(data)){let index=0;for(const item of data){data[index]=this.removeMetaData(item,specification);index+=1}return data}if(typeof data==='object'&amp;&amp;data!==null){const result={};for(const name in data)if(data.hasOwnProperty(name)){const emptyEqualsToNull=Boolean((specification&amp;&amp;(specification.hasOwnProperty(name)&amp;&amp;specification[name]||specification.hasOwnProperty(this.specialNames.additional)&amp;&amp;specification[this.specialNames.additional])||{}).emptyEqualsToNull);if(![undefined,null].includes(data[name])&amp;&amp;!(emptyEqualsToNull&amp;&amp;(data[name]===''||Array.isArray(data[name])&amp;&amp;data[name].length===0||typeof data[name]==='object'&amp;&amp;!(data[name]instanceof Date)&amp;&amp;Object.keys(data[name]).length===0)))if(this.modelConfiguration.property.name.reserved.concat(this.specialNames.deleted,this.specialNames.id,this.specialNames.revision,this.specialNames.type).includes(name))result[name]=data[name];else if(name===this.specialNames.attachment){if(typeof data[name]==='object'&amp;&amp;data[name]!==null){result[name]={};for(const fileName in data[name]){if(data[name].hasOwnProperty(fileName))result[name][fileName]={/* eslint-disable camelcase */content_type:data[name][fileName].content_type||'application/octet-stream'/* eslint-enable camelcase */};if(data[name][fileName].hasOwnProperty('data'))result[name][fileName].data=data[name][fileName].data;else for(const type of['digest','stub'])if(data[name][fileName].hasOwnProperty(type))result[name][fileName][type]=data[name][fileName][type]}}}else if(![this.specialNames.additional,this.specialNames.allowedRole,this.specialNames.conflict,this.specialNames.constraint.execution,this.specialNames.constraint.expression,this.specialNames.deletedConflict,this.specialNames.extend,this.specialNames.localSequence,this.specialNames.maximumAggregatedSize,this.specialNames.minimumAggregatedSize,this.specialNames.revisions,this.specialNames.revisionsInformations].includes(name)&amp;&amp;(!specification||specification.hasOwnProperty(name)||specification.hasOwnProperty(this.specialNames.additional)))result[name]=this.removeMetaData(data[name],this.dataScope.determineNestedSpecifcation(name,specification))}return result}return data}/**
     * Implements the meta data removing of given document.
     * @param newDocument - Document to slice meta data from.
     * @param oldDocument - Optionally existing old document to take into
     * account.
     * @returns The copied sliced version of given document if changes exists
     * (checked against given old document) and "null" otherwise. Result is
     * wrapped into a promise to process binary data asynchronous.
     */transform(newDocument,oldDocument){var _this3=this;return _asyncToGenerator(function*(){let specification=null;if(_this3.specialNames.type in newDocument&amp;&amp;_this3.modelConfiguration.entities.hasOwnProperty(newDocument[_this3.specialNames.type]))specification=_this3.modelConfiguration.entities[newDocument[_this3.specialNames.type]];let result=_this3.removeMetaData(newDocument,specification);let payloadExists=false;if(oldDocument){const attachmentDifference=yield _this3.getNotAlreadyExistingAttachmentData(result,oldDocument,specification);if(attachmentDifference.payloadExists){result[_this3.specialNames.attachment]=attachmentDifference.result;payloadExists=attachmentDifference.payloadExists}if(_this3.removeAlreadyExistingData(result,_this3.removeMetaData(oldDocument,specification),specification).payloadExists)payloadExists=true}// Check if real payload exists in currently determined raw data.
if(!payloadExists)/*
                NOTE: We have to check first level only since all unneeded
                nested values should have been already removed if not
                necessary.
            */for(const name in result)if(result.hasOwnProperty(name)&amp;&amp;!_this3.modelConfiguration.property.name.reserved.concat(_this3.specialNames.deleted,_this3.specialNames.id,_this3.specialNames.revision,_this3.specialNames.type).includes(name)){payloadExists=true;break}return payloadExists?result:null})()}})||_class12);// IgnoreTypeCheck
Reflect.defineMetadata('design:paramtypes',[AttachmentsAreEqualPipe,EqualsPipe,InitialDataService,_core.Injector,NumberGetUTCTimestampPipe,ToolsService],ExtractRawDataPipe);/**
 * Checks if given reference is defined.
 */let IsDefinedPipe/* implements PipeTransform*/=exports.IsDefinedPipe=(_dec8=(0,_core.Pipe)({name:'genericIsDefined'}),_dec8(_class14=class IsDefinedPipe{/**
     * Performs the actual comparison.
     * @param object - Object to compare against "undefined" or "null".
     * @param nullIsUndefined - Indicates whether "null" should be handles as
     * "undefined".
     * @returns The comparison result.
     */transform(object,nullIsUndefined=false){return!(object===undefined||nullIsUndefined&amp;&amp;object===null)}})||_class14);// IgnoreTypeCheck
/**
 * Retrieves a matching filename by given filename prefix.
 */let LimitToPipe/* implements PipeTransform*/=exports.LimitToPipe=(_dec9=(0,_core.Pipe)({name:'genericLimitTo'}),_dec9(_class15=class LimitToPipe{/**
     * Limits number of items of given string, Object (keys) or Array.
     * @param input - Object to retrieve key names from.
     * @param limit - Number of needed items.
     * @param begin - Starting point to slice from.
     * @returns Copy of given sliced object.
     */transform(input,limit,begin){limit=Math.abs(Number(limit))===Infinity?Number(limit):parseInt(limit);if(isNaN(limit))return input;if(typeof input==='number')input=input.toString();else if(typeof input==='object'&amp;&amp;input!==null&amp;&amp;!Array.isArray(input))input=Object.keys(input).sort();if(!(Array.isArray(input)||typeof input==='string'))return input;begin=!begin||isNaN(begin)?0:parseInt(begin);if(begin&lt;0)begin=Math.max(0,input.length+begin);if(limit>=0)return input.slice(begin,begin+limit);else if(begin===0)return input.slice(limit,input.length);return input.slice(Math.max(0,begin+limit),begin)}})||_class15);// IgnoreTypeCheck
/**
 * Returns a copy of given object where each item was processed through given
 * function.
 * @property injector - Pipe specific injector to determine pipe dynamically at
 * runtime.
 */let MapPipe/* implements PipeTransform*/=exports.MapPipe=(_dec10=(0,_core.Pipe)({name:'genericMap'}),_dec10(_class16=class MapPipe{/**
     * Injects the injector and saves as instance property.
     * @param injector - Pipe injector service instance.
     * @returns Nothing.
     */constructor(injector){this.injector=this.injector;this.injector=injector}/**
     * Performs the actual transformation.
     * @param object - Iterable item where given pipe should be applied to each
     * value.
     * @param pipeName - Pipe to apply to each value.
     * @param additionalArguments - All additional arguments will be forwarded
     * to given pipe (after the actual value).
     * @returns Given transform copied object.
     */transform(object,pipeName,...additionalArguments){const pipe=this.injector.get(pipeName);if(Array.isArray(object)){const result=[];for(const item of object)result.push(pipe.transform(item,...additionalArguments));return result}const result={};for(const key in object)if(object.hasOwnProperty(key))result[key]=pipe.transform.transform(object[key],key,...additionalArguments);return result}})||_class16);// IgnoreTypeCheck
Reflect.defineMetadata('design:paramtypes',[_core.Injector],MapPipe);/**
 * Retrieves a matching filename by given filename prefix.
 */let ObjectKeysPipe/* implements PipeTransform*/=exports.ObjectKeysPipe=(_dec11=(0,_core.Pipe)({name:'genericObjectKeys'}),_dec11(_class18=class ObjectKeysPipe{/**
     * Performs the "Object" native "keys()" method.
     * @param object - Object to retrieve key names from.
     * @param sort - Indicates whether sorting should be enabled. If an array
     * is provided it will be interpreted as arguments given to the array's
     * sort method.
     * @param reverse - Reverses sorted list.
     * @param asNumber - Sort number aware.
     * @returns Arrays of key names.
     */transform(object,sort=false,reverse=false,asNumber=false){if(typeof object==='object'&amp;&amp;object!==null){const result=Object.keys(object);if(sort){if(!Array.isArray(sort))sort=asNumber?[(first,second)=>{first=parseInt(first);second=parseInt(second);if(isNaN(first))return isNaN(second)?0:+1;else if(isNaN(second))return-1;return first-second}]:[];result.sort(...sort);if(reverse)result.reverse();return result}return result}return[]}})||_class18);// IgnoreTypeCheck
/**
 * Reverses a given list.
 */let ReversePipe/* implements PipeTransform*/=exports.ReversePipe=(_dec12=(0,_core.Pipe)({name:'genericReverse'}),_dec12(_class19=class ReversePipe{/**
     * Performs the "Arrays" native "reverse()" method.
     * @param list - List to reverse.
     * @param copy - Indicates whether a reversed copy should be created or
     * reversion can be done in place.
     * @returns Reverted arrays.
     */transform(list,copy=false){if(list){if(copy)list=list.slice()}else list=[];if('reverse'in list)list.reverse();return list}})||_class19);// IgnoreTypeCheck
/**
 * Determines type of given object.
 */let TypePipe/* implements PipeTransform*/=exports.TypePipe=(_dec13=(0,_core.Pipe)({name:'genericType'}),_dec13(_class20=class TypePipe{/**
     * Returns type of given object.
     * @param object - Object to determine type of.
     * @returns Type name.
     */transform(object){return typeof object}})||_class20);// / endregion
// region array
// IgnoreTypeCheck
/**
 * Dependently concatenate given data to piped data.
 */let ArrayDependentConcatPipe/* immplements PipeTransform*/=exports.ArrayDependentConcatPipe=(_dec14=(0,_core.Pipe)({name:'genericArrayDependentConcat'}),_dec14(_class21=class ArrayDependentConcatPipe{/**
     * Does the given array transformation logic.
     * @param array - Array to transform.
     * @param indicator - Indicator to decide if concatenation should be done.
     * @param item - Object(s) to concatenate.
     * @returns Transformed given array.
     */transform(array,indicator,item){if(indicator)return array.concat(item);return array}})||_class21);// endregion
// region string
// IgnoreTypeCheck
/**
 * Forwards javaScript's native "stringEndsWith" method.
 */let StringEndsWithPipe/* implements PipeTransform*/=exports.StringEndsWithPipe=(_dec15=(0,_core.Pipe)({name:'genericStringEndsWith'}),_dec15(_class22=class StringEndsWithPipe{/**
     * Performs the actual indicator method.
     * @param string - To check.
     * @param needle - Suffix to search for.
     * @returns The boolean result.
     */transform(string,needle){return typeof string==='string'&amp;&amp;typeof needle==='string'&amp;&amp;string.endsWith(needle)}})||_class22);// IgnoreTypeCheck
/**
 * Determines if given string has a time indicating suffix.
 */let StringHasTimeSuffixPipe/* implements PipeTransform*/=exports.StringHasTimeSuffixPipe=(_dec16=(0,_core.Pipe)({name:'genericStringHasTimeSuffix'}),_dec16(_class23=class StringHasTimeSuffixPipe{/**
     * Performs the actual string suffix check.
     * @param string - To search in.
     * @returns The boolean result.
     */transform(string){if(typeof string!=='string')return false;return string.endsWith('Date')||string.endsWith('Time')||string==='timestamp'}})||_class23);// IgnoreTypeCheck
/**
 * Tests if given pattern matches against given subject.
 */let StringMatchPipe/* implements PipeTransform*/=exports.StringMatchPipe=(_dec17=(0,_core.Pipe)({name:'genericStringMatch'}),_dec17(_class24=class StringMatchPipe{/**
     * Performs the actual matching.
     * @param pattern - String or regular expression to search for.
     * @param subject - String to search in.
     * @param modifier - Regular expression modifier (second argument to the
     * "RegExp" constructor).
     * @returns Boolean test result.
     */transform(pattern,subject,modifier=''){// IgnoreTypeCheck
return new RegExp(pattern,modifier).test(subject)}})||_class24);// IgnoreTypeCheck
/**
 * Trims given string if it is longer then given length.
 */let StringMaximumLengthPipe/* implements PipeTransform*/=exports.StringMaximumLengthPipe=(_dec18=(0,_core.Pipe)({name:'genericStringMaximumLength'}),_dec18(_class25=class StringMaximumLengthPipe{/**
     * Performs the actual indicator method.
     * @param string - To check.
     * @param maximumLength - Maximum number of symbols in given string.
     * @param suffix - Suffix to append if given string has to bee trimmed.
     * @returns The potentially trimmed given string.
     */transform(string,maximumLength=100,suffix='...'){if(string){if(string.length>maximumLength&amp;&amp;string.length-1>suffix.length)string=string.substring(0,Math.max(1,maximumLength-suffix.length))+suffix;return string}return''}})||_class25);// IgnoreTypeCheck
/**
 * Provides javascript's native string replacement method as pipe.
 */let StringReplacePipe/* implements PipeTransform*/=exports.StringReplacePipe=(_dec19=(0,_core.Pipe)({name:'genericStringReplace'}),_dec19(_class26=class StringReplacePipe{/**
     * Performs the actual replacement.
     * @param string - String to replace content.
     * @param search - String or regular expression to us as matcher.
     * @param replacement - String to replace with matching parts in given
     * "string".
     * @param modifier - Regular expression modifier (second argument to the
     * "RegExp" constructor).
     * @returns A new string with replacements done.
     */transform(string,search,replacement='',modifier='g'){// IgnoreTypeCheck
return string.replace(new RegExp(search,modifier),replacement)}})||_class26);// IgnoreTypeCheck
/**
 * Provides angular dom html sanitizer.
 * @property transform - Binded dom sanitizer's validation marker.
 */let StringSafeHTMLPipe/* implements PipeTransform*/=exports.StringSafeHTMLPipe=(_dec20=(0,_core.Pipe)({name:'genericStringSafeHTML'}),_dec20(_class27=class StringSafeHTMLPipe{/**
     * @param domSanitizer - Injected dom sanitizer service instance.
     * @returns Nothing.
     */constructor(domSanitizer){this.transform=domSanitizer.bypassSecurityTrustHtml.bind(this.domSanitizer)}})||_class27);// IgnoreTypeCheck
Reflect.defineMetadata('design:paramtypes',[_platformBrowser.DomSanitizer],StringSafeHTMLPipe);/**
 * Provides angular dom html sanitizer.
 * @property transform - Binded dom sanitizer's validation marker.
 */let StringSafeResourceURLPipe/* implements PipeTransform*/=exports.StringSafeResourceURLPipe=(_dec21=(0,_core.Pipe)({name:'genericStringSafeResourceURL'}),_dec21(_class28=class StringSafeResourceURLPipe{/**
     * @param domSanitizer - Injected dom sanitizer service instance.
     * @returns Nothing.
     */constructor(domSanitizer){this.transform=domSanitizer.bypassSecurityTrustResourceUrl.bind(this.domSanitizer)}})||_class28);// IgnoreTypeCheck
Reflect.defineMetadata('design:paramtypes',[_platformBrowser.DomSanitizer],StringSafeResourceURLPipe);/**
 * Provides angular dom html sanitizer.
 * @property transform - Binded dom sanitizer's validation marker.
 */let StringSafeScriptPipe/* implements PipeTransform*/=exports.StringSafeScriptPipe=(_dec22=(0,_core.Pipe)({name:'genericStringSafeScript'}),_dec22(_class29=class StringSafeScriptPipe{/**
     * @param domSanitizer - Injected dom sanitizer service instance.
     * @returns Nothing.
     */constructor(domSanitizer){this.transform=domSanitizer.bypassSecurityTrustScript.bind(this.domSanitizer)}})||_class29);// IgnoreTypeCheck
Reflect.defineMetadata('design:paramtypes',[_platformBrowser.DomSanitizer],StringSafeScriptPipe);/**
 * Provides angular dom html sanitizer.
 * @property transform - Binded dom sanitizer's validation marker.
 */let StringSafeStylePipe/* implements PipeTransform*/=exports.StringSafeStylePipe=(_dec23=(0,_core.Pipe)({name:'genericStringSafeStyle'}),_dec23(_class30=class StringSafeStylePipe{/**
     * @param domSanitizer - Injected dom sanitizer service instance.
     * @returns Nothing.
     */constructor(domSanitizer){this.transform=domSanitizer.bypassSecurityTrustStyle.bind(this.domSanitizer)}})||_class30);// IgnoreTypeCheck
Reflect.defineMetadata('design:paramtypes',[_platformBrowser.DomSanitizer],StringSafeStylePipe);/**
 * Provides angular dom html sanitizer.
 * @property transform - Binded dom sanitizer's validation marker.
 */let StringSafeURLPipe/* implements PipeTransform*/=exports.StringSafeURLPipe=(_dec24=(0,_core.Pipe)({name:'genericStringSafeURL'}),_dec24(_class31=class StringSafeURLPipe{/**
     * @param domSanitizer - Injected dom sanitizer service instance.
     * @returns Nothing.
     */constructor(domSanitizer){this.transform=domSanitizer.bypassSecurityTrustUrl.bind(this.domSanitizer)}})||_class31);// IgnoreTypeCheck
Reflect.defineMetadata('design:paramtypes',[_platformBrowser.DomSanitizer],StringSafeURLPipe);/**
 * Returns given string if it matches given pattern.
 */let StringShowIfPatternMatchesPipe/* implements PipeTransform*/=exports.StringShowIfPatternMatchesPipe=(_dec25=(0,_core.Pipe)({name:'genericStringShowIfPatternMatches'}),_dec25(_class32=class StringShowIfPatternMatchesPipe{/**
     * Performs the actual matching.
     * @param string - String to replace content.
     * @param pattern - String or regular expression to us as matcher.
     * @param invert - Indicates whether given string should be shown if given
     * pattern matches or not.
     * @param modifier - Regular expression modifier (second argument to the
     * "RegExp" constructor).
     * @returns Given string if matching indicator was successful.
     */transform(string,pattern,invert=false,modifier=''){// IgnoreTypeCheck
let indicator=new RegExp(pattern,modifier).test(string);if(invert)indicator=!indicator;return indicator?string:''}})||_class32);// IgnoreTypeCheck
/**
 * Returns a matched part of given subject with given pattern. Default is the
 * whole (zero) matched part.
 */let StringSliceMatchPipe/* implements PipeTransform*/=exports.StringSliceMatchPipe=(_dec26=(0,_core.Pipe)({name:'genericStringSliceMatch'}),_dec26(_class33=class StringSliceMatchPipe{/**
     * Performs the actual matching.
     * @param subject - String to search in.
     * @param pattern - String or regular expression to search for.
     * @param index - Match group to extract.
     * @param modifier - Regular expression modifier (second argument to the
     * "RegExp" constructor).
     * @returns Matching group.
     */transform(subject,pattern,index=0,modifier=''){if(typeof subject==='string'){const match=subject.match(new RegExp(// IgnoreTypeCheck
pattern,modifier));if(match&amp;&amp;typeof match[index]==='string')return match[index]}return''}})||_class33);// IgnoreTypeCheck
/**
 * Forwards javascript's native "stringStartsWith" method.
 */let StringStartsWithPipe/* implements PipeTransform*/=exports.StringStartsWithPipe=(_dec27=(0,_core.Pipe)({name:'genericStringStartsWith'}),_dec27(_class34=class StringStartsWithPipe{/**
     * Performs the actual indicator method.
     * @param string - To check.
     * @param needle - Prefix to search for.
     * @returns The boolean result.
     */transform(string,needle){return typeof string==='string'&amp;&amp;typeof needle==='string'&amp;&amp;string.startsWith(needle)}})||_class34);// IgnoreTypeCheck
/**
 * Provides angular's template engine as pipe.
 */let StringTemplatePipe/* implements PipeTransform*/=exports.StringTemplatePipe=(_dec28=(0,_core.Pipe)({name:'genericStringTemplate'}),_dec28(_class35=class StringTemplatePipe{/**
     * Performs the actual indicator method.
     * @param string - To check.
     * @param scope - Scope to render given string again.
     * @returns The rendered result.
     */transform(string='',scope={}){return new Function(Object.keys(scope),`return \`${string}\``)(...Object.values(scope))}})||_class35);// / endregion
// / region number
// IgnoreTypeCheck
/**
 * Returns part in percent of all.
 */let NumberPercentPipe/* implements PipeTransform*/=exports.NumberPercentPipe=(_dec29=(0,_core.Pipe)({name:'genericNumberPercent'}),_dec29(_class36=class NumberPercentPipe{/**
     * Performs the actual calculation.
     * @param part - Part to divide "all" through.
     * @param all - Reference value to calculate part of.
     * @returns The calculated part.
     */transform(part,all){return part/all*100}})||_class36);// / endregion
// endregion
// region animations
/**
 * Fade in/out animation factory.
 * @param options - Animations meta data options.
 * @returns Animations meta data object.
 */function fadeAnimation(options={}){if(typeof options==='string')options={name:options};options=_clientnode2.default.extendObject({duration:'.3s',enterState:':enter',leaveState:':leave',name:'fadeAnimation'},options);return(0,_animations.trigger)(options.name,[(0,_animations.transition)(options.enterState,[(0,_animations.style)({opacity:0}),(0,_animations.animate)(options.duration,(0,_animations.style)({opacity:1}))]),(0,_animations.transition)(options.leaveState,[(0,_animations.style)({opacity:1}),(0,_animations.animate)(options.duration,(0,_animations.style)({opacity:0}))])])}const defaultAnimation=exports.defaultAnimation=fadeAnimation.bind({},'defaultAnimation');// endregion
// region services
// IgnoreTypeCheck
/**
 * A generic guard which prevents from switching to route if its component's
 * "canDeactivate()" method returns "false", a promise or observable wrapping
 * a boolean.
 */let CanDeactivateRouteLeaveGuard/* implements CanDeactivate&lt;Object>*/=exports.CanDeactivateRouteLeaveGuard=(_dec30=(0,_core.Injectable)(),_dec30(_class37=class CanDeactivateRouteLeaveGuard{/**
     * Calls the component specific "canDeactivate()" method.
     * @param component - Component instance of currently selected route.
     * @returns A boolean, promise or observable which wraps the indicator.
     */canDeactivate(component){return'canDeactivate'in component?component.canDeactivate():true}})||_class37);// / region confirm
// IgnoreTypeCheck
/**
 * Provides a generic confirmation component.
 * @property cancelText - Text to use as cancel button label.
 * @property dialogReference - Reference to the dialog component instance.
 * @property okText - Text to use as confirm button label.
 */let ConfirmComponent=exports.ConfirmComponent=(_dec31=(0,_core.Component)({animations:[defaultAnimation()],changeDetection:_core.ChangeDetectionStrategy.OnPush,selector:'generic-confirm',template:`
        &lt;h2 @defaultAnimation mat-dialog-title *ngIf="title">{{title}}&lt;/h2>
        &lt;mat-dialog-content @defaultAnimation *ngIf="message">
            {{message}}
        &lt;/mat-dialog-content>
        &lt;mat-dialog-actions>
            &lt;button (click)="dialogReference.close(true)" mat-raised-button>
                {{okText}}
            &lt;/button>
            &lt;button (click)="dialogReference.close(false)" mat-raised-button>
                {{cancelText}}
            &lt;/button>
        &lt;/mat-dialog-actions>
    `}),_dec32=(0,_core.Input)(),_dec33=(0,_core.Input)(),_dec31(_class38=(_class39=class ConfirmComponent{/**
     * Gets needed component data injected.
     * NOTE: The "@Optional" decorator makes test instances possible.
     * NOTE: Don't set default values for theses optional parameter since the
     * would overwrite an injected value.
     * @param data - Data to provide for the dialog component instance.
     * @param dialogReference - Dialog component instance.
     * @returns Nothing.
     */constructor(data,dialogReference/* eslint-enable indent */){_initDefineProp(this,'cancelText',_descriptor,this);this.dialogReference=null;_initDefineProp(this,'okText',_descriptor2,this);this.dialogReference=dialogReference;if(typeof data==='object'&amp;&amp;data!==null)for(const key in data)if(data.hasOwnProperty(key))this[key]=data[key]}},(_descriptor=_applyDecoratedDescriptor(_class39.prototype,'cancelText',[_dec32],{enumerable:true,initializer:function(){return'Cancel'}}),_descriptor2=_applyDecoratedDescriptor(_class39.prototype,'okText',[_dec33],{enumerable:true,initializer:function(){return'OK'}})),_class39))||_class38);// IgnoreTypeCheck
(0,_core.Optional)()(ConfirmComponent,null,0);(0,_core.Inject)(_material.MAT_DIALOG_DATA)(ConfirmComponent,null,0);(0,_core.Optional)()(ConfirmComponent,null,1);Reflect.defineMetadata('design:paramtypes',[,_material.MatDialogRef],ConfirmComponent);/**
 * Alert service to trigger a dialog window which can be confirmed.
 * @property dialog - Reference to the dialog component instance.
 * @property dialogReference - Reference to the dialog service instance.
 */let AlertService=exports.AlertService=(_dec34=(0,_core.Injectable)(),_dec34(_class41=class AlertService{/**
     * Gets needed component dialog service instance injected.
     * @param dialog - Reference to the dialog component instance.
     * @returns Nothing.
     */constructor(dialog){this.dialog=this.dialog;this.dialogReference=this.dialogReference;this.dialog=dialog}/**
     * Triggers a confirmation dialog to show.
     * @param data - Data to provide for the confirmations component instance.
     * @returns A promise resolving when confirmation window where confirmed or
     * rejected due to user interaction. A promised wrapped boolean indicates
     * which decision was made.
     */confirm(data){if(typeof data==='string')data={data:{message:data}};else if(typeof data!=='object'||data===null||!data.hasOwnProperty('data'))data={data};this.dialogReference=this.dialog.open(ConfirmComponent,data);return this.dialogReference.afterClosed().toPromise()}})||_class41);// / endregion
// IgnoreTypeCheck
Reflect.defineMetadata('design:paramtypes',[_material.MatDialog],AlertService);/**
 * A generic database connector.
 * @property static:revisionNumberRegularExpression - Compiled regular
 * expression to retrieve revision number from revision hash.
 * @property static:wrappableMethodNames - Saves a list of method names which
 * can be intercepted.
 *
 * @property connection - The current database connection instance.
 * @property database - The entire database constructor.
 * @property equals - Hilds the equals pipe transformation method.
 * @property extendObject - Holds the extend object's pipe transformation
 * method.
 * @property interceptSynchronisationPromise - Promise which have to be
 * resolved before synchronisation for local database starts.
 * @property middlewares - Mapping of post and pre callback arrays to trigger
 * before or after each database transaction.
 * @property ngZone - Execution service instance.
 * @property platformID - Platform identification string.
 * @property remoteConnection - The current remote database connection
 * instance.
 * @property stringFormat - Holds the string format's pipe transformation
 * method.
 * @property synchronisation - This synchronisation instance represents the
 * active synchronisation process if a local offline database is in use.
 * @property tools - Holds the tools class from the tools service.
 */let DataService=exports.DataService=(_dec35=(0,_core.Injectable)(),_dec35(_class43=(_temp2=_class44=class DataService{/**
     * Creates the database constructor applies all plugins instantiates
     * the connection instance and registers all middlewares.
     * @param equalsPipe - Equals pipe service instance.
     * @param extendObjectPipe - Injected extend object pipe instance.
     * @param initialData - Injected initial data service instance.
     * @param ngZone - Injected execution context service instance.
     * @param platformID - Platform identification string.
     * @param stringFormatPipe - Injected string format pipe instance.
     * @param tools - Injected tools service instance.
     * @returns Nothing.
     */constructor(equalsPipe,extendObjectPipe,initialData,ngZone,platformID,stringFormatPipe,tools){this.connection=this.connection;this.configuration=this.configuration;this.database=this.database;this.equals=this.equals;this.extendObject=this.extendObject;this.interceptSynchronisationPromise=null;this.ngZone=this.ngZone;this.middlewares={post:{},pre:{}};this.platformID=this.platformID;this.remoteConnection=null;this.runningRequests=[];this.runningRequestsStream=new _rxjs.Subject;this.stringFormat=this.stringFormat;this.synchronisation=this.synchronisation;this.tools=this.tools;this.configuration=initialData.configuration;if(this.configuration.database.hasOwnProperty('publicURL'))this.configuration.database.url=this.configuration.database.publicURL;this.database=_pouchdb2.default;this.equals=equalsPipe.transform.bind(equalsPipe);this.extendObject=extendObjectPipe.transform.bind(extendObjectPipe);this.ngZone=ngZone;this.platformID=platformID;this.stringFormat=stringFormatPipe.transform.bind(stringFormatPipe);this.tools=tools.tools;const idName=this.configuration.database.model.property.name.special.id;const revisionName=this.configuration.database.model.property.name.special.revision;const nativeBulkDocs=this.database.prototype.bulkDocs;const self=this;this.database.plugin({bulkDocs:(()=>{var _ref=_asyncToGenerator(function*(firstParameter,...parameter){/*
                Implements a generic retry mechanism for "upsert" and "latest"
                updates and optionally supports to ignore "NoChange" errors.
            */if(!Array.isArray(firstParameter)&amp;&amp;typeof firstParameter==='object'&amp;&amp;firstParameter!==null&amp;&amp;firstParameter.hasOwnProperty(idName))firstParameter=[firstParameter];let result=[];try{result=yield nativeBulkDocs.call(this,firstParameter,...parameter)}catch(error){/*
                    NOTE: We retrieve lastest revision in an additional request
                    if backend doesn't support the "latest" or "upsert" syntax.
                */if(error.name==='bad_request'){for(const item of firstParameter)if(['latest','upsert'].includes(item[revisionName]))try{item[revisionName]=(yield this.get(item[idName]))[revisionName]}catch(error){if(error.name==='not_found')delete item[revisionName];else throw error}try{result=yield nativeBulkDocs.call(this,firstParameter,...parameter)}catch(error){throw error}}else throw error}const conflictingIndexes=[];const conflicts=[];let index=0;for(const item of result){if(typeof firstParameter[index]==='object'&amp;&amp;firstParameter!==null)if(revisionName in firstParameter[index]&amp;&amp;item.name==='conflict'&amp;&amp;['latest','upsert'].includes(firstParameter[index][revisionName])){conflicts.push(item);conflictingIndexes.push(index)}else if(idName in firstParameter[index]&amp;&amp;self.configuration.database.ignoreNoChangeError&amp;&amp;'name'in item&amp;&amp;item.name==='forbidden'&amp;&amp;'message'in item&amp;&amp;item.message.startsWith('NoChange:')){result[index]={id:firstParameter[index][idName],ok:true};try{result[index].rev=revisionName in firstParameter[index]&amp;&amp;!['latest','upsert'].includes(firstParameter[index][revisionName])?firstParameter[index][revisionName]:(yield this.get(result[index].id))[revisionName]}catch(error){throw error}}index+=1}if(conflicts.length){firstParameter=conflicts;const retriedResults=yield this.bulkDocs(firstParameter,...parameter);for(const retriedResult of retriedResults)result[conflictingIndexes.shift()]=retriedResult}return result});return function bulkDocs(_x){return _ref.apply(this,arguments)}})()});this.database.plugin(_pouchdbFind2.default).plugin(_pouchdbValidation2.default);for(const plugin of this.configuration.database.plugins)this.database.plugin(plugin)}/**
     * Determines all property names which are indexable in a generic manner.
     * @param modelConfiguration - Model specification object.
     * @param model - Model to determine property names from.
     * @returns The mapping object.
     */static determineGenericIndexablePropertyNames(modelConfiguration,model){const specialNames=modelConfiguration.property.name.special;return Object.keys(model).filter(name=>model[name].index||!(modelConfiguration.property.name.reserved.concat(specialNames.additional,specialNames.allowedRole,specialNames.attachment,specialNames.conflict,specialNames.constraint.execution,specialNames.constraint.expression,specialNames.deleted,specialNames.deleted_conflict,specialNames.extend,specialNames.id,specialNames.maximumAggregatedSize,specialNames.minimumAggregatedSize,specialNames.revision,specialNames.revisions,specialNames.revisionsInformation,specialNames.type).includes(name)||model[name].type&amp;&amp;(typeof model[name].type==='string'&amp;&amp;model[name].type.endsWith('[]')||Array.isArray(model[name].type)&amp;&amp;model[name].type.length&amp;&amp;Array.isArray(model[name].type[0])||modelConfiguration.entities.hasOwnProperty(model[name].type)))).concat(specialNames.id,specialNames.revision)}/**
     * Initializes database connection and synchronisation if needed.
     * @returns A promise resolving when initialisation has finished.
     */initialize(){var _this4=this;return _asyncToGenerator(function*(){const options=_this4.extendObject(/* eslint-disable camelcase */true,{skip_setup:true},/* eslint-enable camelcase */_this4.configuration.database.connector||{});const databaseName=_this4.configuration.name||'generic';if(!(0,_common.isPlatformServer)(_this4.platformID))_this4.remoteConnection=new _this4.database(_this4.stringFormat(_this4.configuration.database.url,'')+`/${databaseName}`,options);if(_this4.configuration.database.local||(0,_common.isPlatformServer)(_this4.platformID))_this4.connection=new _this4.database(databaseName,options);else _this4.connection=_this4.remoteConnection;// region apply "latest/upsert" and ignore "NoChange" error feature
/*
            NOTE: A "bulkDocs" plugin does not get called for every "put" and
            "post" call so we have to wrap runtime generated methods.
        */const configuration=_this4.configuration;const idName=_this4.configuration.database.model.property.name.special.id;const revisionName=_this4.configuration.database.model.property.name.special.revision;for(const pluginName of['post','put']){const nativeMethod=_this4.connection[pluginName].bind(_this4.connection);_this4.connection[pluginName]=(()=>{var _ref2=_asyncToGenerator(function*(firstParameter,secondParameter,...parameter){try{return yield nativeMethod(firstParameter,secondParameter,...parameter)}catch(error){const id=typeof firstParameter==='object'&amp;&amp;idName in firstParameter?firstParameter[idName]:firstParameter;if(id&amp;&amp;configuration.database.ignoreNoChangeError&amp;&amp;'name'in error&amp;&amp;error.name==='forbidden'&amp;&amp;'message'in error&amp;&amp;error.message.startsWith('NoChange:')){const result={id,ok:true};const revision=typeof secondParameter==='object'&amp;&amp;revisionName in secondParameter?secondParameter[revisionName]:secondParameter;try{result.rev=revisionName in firstParameter&amp;&amp;!['latest','upsert'].includes(revision)?revision:(yield this.get(result.id))[revisionName]}catch(error){throw error}return result}throw error}});return function(_x2,_x3){return _ref2.apply(this,arguments)}})()}// endregion
for(const name in _this4.connection)if(_this4.constructor.wrappableMethodNames.includes(name)&amp;&amp;typeof _this4.connection[name]==='function'){const method=_this4.connection[name];_this4.connection[name]=(()=>{var _ref3=_asyncToGenerator(function*(...parameter){const request={name,parameter};_this4.runningRequests.push(request);_this4.runningRequestsStream.next(_this4.runningRequests);const clear=function(){const index=_this4.runningRequests.indexOf(request);if(index!==-1)_this4.runningRequests.splice(index,1);_this4.runningRequestsStream.next(_this4.runningRequests)};for(const methodName of[name,'_all'])if(_this4.middlewares.pre.hasOwnProperty(methodName))for(const interceptor of _this4.middlewares.pre[methodName]){parameter=interceptor.apply(_this4.connection,parameter.concat(methodName==='_all'?name:[]));if('then'in parameter)try{parameter=yield parameter}catch(error){clear();throw error}}request.wrappedParameter=parameter;const action=function(context=_this4.connection,givenParameter=parameter){return method.apply(context,givenParameter)};let result=action();for(const methodName of[name,'_all'])if(_this4.middlewares.post.hasOwnProperty(methodName))for(const interceptor of _this4.middlewares.post[methodName]){result=interceptor.call(_this4.connection,result,action,...parameter.concat(methodName==='_all'?name:[]));if('then'in result)try{result=yield result}catch(error){clear();throw error}}if('then'in result)try{result=yield result}catch(error){clear();throw error}clear();return result});return function(){return _ref3.apply(this,arguments)}})()}_this4.connection.installValidationMethods();if(_this4.configuration.database.local&amp;&amp;_this4.remoteConnection)/*
                NOTE: We want to allow other services to integrate an
                interception promise.
            */// IgnoreTypeCheck
_this4.tools.timeout(_asyncToGenerator(function*(){if(_this4.interceptSynchronisationPromise)yield _this4.interceptSynchronisationPromise;_this4.startSynchronisation()}));if((0,_common.isPlatformServer)(_this4.platformID)&amp;&amp;_this4.configuration.database.createGenericFlatIndex){// region create/remove needed/unneeded generic indexes
for(const modelName in _this4.configuration.database.model.entities)if(_this4.configuration.database.model.entities.hasOwnProperty(modelName)&amp;&amp;new RegExp(_this4.configuration.database.model.property.name.typeRegularExpressionPattern.public).test(modelName))for(const name of DataService.determineGenericIndexablePropertyNames(_this4.configuration.database.model,_this4.configuration.database.model.entities[modelName]))try{yield _this4.connection.createIndex({index:{ddoc:`${modelName}-${name}-GenericIndex`,fields:[_this4.configuration.database.model.property.name.special.type,name],name:`${modelName}-${name}-GenericIndex`}})}catch(error){throw error}let indexes;try{indexes=(yield _this4.connection.getIndexes()).indexes}catch(error){throw error}for(const index of indexes)if(index.name.endsWith('-GenericIndex')){let exists=false;for(const modelName in _this4.configuration.database.model.entities)if(index.name.startsWith(`${modelName}-`)){for(const name of DataService.determineGenericIndexablePropertyNames(_this4.configuration.database.model,_this4.configuration.database.model.entities[modelName]))if(index.name===`${modelName}-${name}-GenericIndex`)exists=true;break}if(!exists)try{yield _this4.connection.deleteIndex(index)}catch(error){throw error}}}// endregion
})()}/**
     * Creates a database index.
     * @param parameter - All parameter will be forwarded to the underlining
     * pouchdb-find's "createIndex()" method.
     * @returns Whatever pouchdb-find's "createIndex()" method returns.
     */createIndex(...parameter){return this.connection.createIndex(...parameter)}/**
     * Creates or updates given data.
     * @param parameter - All parameter will be forwarded to the underlining
     * pouchdb's "bulkDocs()" method.
     * @returns Whatever pouchdb's method returns.
     */bulkDocs(...parameter){return this.connection.bulkDocs(...parameter)}/**
     * Removes current active database.
     * @param parameter - All parameter will be forwarded to the underlining
     * pouchdb's "destroy()" method.
     * @returns Whatever pouchdb's method returns.
     */destroy(...parameter){if(this.synchronisation)this.synchronisation.cancel();const result=this.connection.destroy(...parameter);this.middlewares={post:{},pre:{}};return result}/**
     * Retrieves a database resource determined by given selector.
     * @param selector - Selector object in mango.
     * @param options - Options to use during selecting items.
     * @returns A promise with resulting array of retrieved resources.
     */find(selector,options={}){var _this5=this;return _asyncToGenerator(function*(){return(yield _this5.connection.find(_this5.extendObject(true,{selector},options))).docs})()}/**
     * Retrieves a resource by id.
     * @param parameter - All parameter will be forwarded to the underlining
     * pouchdb's "get()" method.
     * @returns Whatever pouchdb's method returns.
     */get(...parameter){var _this6=this;return _asyncToGenerator(function*(){const idName=_this6.configuration.database.model.property.name.special.id;const revisionName=_this6.configuration.database.model.property.name.special.revision;const result=yield _this6.connection.get(...parameter);if(LAST_KNOWN_DATA.data.hasOwnProperty(result[idName])&amp;&amp;parameter.length>1&amp;&amp;(_this6.equals(parameter[1],{rev:'latest'})||_this6.equals(parameter[1],{latest:true})||_this6.equals(parameter[1],{latest:true,rev:'latest'}))&amp;&amp;parseInt(result[revisionName].match(_this6.constructor.revisionNumberRegularExpression)[1])&lt;parseInt(LAST_KNOWN_DATA.data[result[idName]][revisionName].match(_this6.constructor.revisionNumberRegularExpression)[1]))return LAST_KNOWN_DATA.data[result[idName]];return result})()}/**
     * Retrieves an attachment by given id.
     * @param parameter - All parameter will be forwarded to the underlining
     * pouchdb's "get()" method.
     * @returns Whatever pouchdb's method returns.
     */getAttachment(...parameter){return this.connection.getAttachment(...parameter)}/**
     * Creates or updates given data.
     * @param parameter - All parameter will be forwarded to the underlining
     * pouchdb's "put()" method.
     * @returns Whatever pouchdb's method returns.
     */put(...parameter){return this.connection.put(...parameter)}/**
     * Creates or updates given attachment.
     * @param parameter - All parameter will be forwarded to the underlining
     * pouchdb's "put()" method.
     * @returns Whatever pouchdb's method returns.
     */putAttachment(...parameter){return this.connection.putAttachment(...parameter)}/**
     * Registers a new middleware.
     * @param names - Event names to intercept.
     * @param callback - Callback function to trigger when specified event
     * happens.
     * @param type - Specifies whether callback should be triggered before or
     * after specified event has happened.
     * @returns A cancel function which will deregister given middleware.
     */register(names,callback,type='post'){if(!Array.isArray(names))names=[names];for(const name of names){if(!this.middlewares[type].hasOwnProperty(name))this.middlewares[type][name]=[];this.middlewares[type][name].push(callback)}return()=>{for(const name of names){const index=this.middlewares[type][name].indexOf(callback);if(index!==-1)this.middlewares[type][name].splice(index,1);if(this.middlewares[type][name].length===0)delete this.middlewares[type][name]}}}/**
     * Removes specified entities in database.
     * @param parameter - All parameter will be forwarded to the underlining
     * pouchdb's "remove()" method.
     * @returns Whatever pouchdb's "remove()" method return.
     */remove(...parameter){return this.connection.remove(...parameter)}/**
     * Removes specified attachment from entity in database.
     * @param parameter - All parameter will be forwarded to the underlining
     * pouchdb's "removeAttachment()" method.
     * @returns Whatever pouchdb's "removeAttachment()" method return.
     */removeAttachment(...parameter){return this.connection.removeAttachment(...parameter)}/**
     * Starts synchronisation between a local and remote database.
     * @returns Nothing.
     */startSynchronisation(){return this.synchronisation=this.connection.sync(this.remoteConnection,{live:true,retry:true}).on('change',info=>console.info('change',info)).on('paused',()=>console.info('paused')).on('active',()=>console.info('active')).on('denied',error=>console.warn('denied',error)).on('complete',info=>console.info('complete',info)).on('error',error=>console.error('error',error))}},_class44.revisionNumberRegularExpression=/^([0-9]+)-/,_class44.wrappableMethodNames=['allDocs','bulkDocs','bulkGet','close','compact','compactDocument','createIndex','deleteIndexs','destroy','find','get','getAttachment','getIndexes','info','post','put','putAttachment','query','remove','removeAttachment'],_temp2))||_class43);// IgnoreTypeCheck
(0,_core.Inject)(_core.PLATFORM_ID)(DataService,null,4);Reflect.defineMetadata('design:paramtypes',[EqualsPipe,ExtendObjectPipe,InitialDataService,_core.NgZone,String,StringFormatPipe,ToolsService],DataService);/**
 * Auto generates a components scope environment for a specified model.
 * @property attachmentWithPrefixExists - Hold the attachment with prefix
 * exists pipe transformation method.
 * @property configuration - Holds the configuration service instance.
 * @property data - Holds the data exchange service instance.
 * @property extendObject - Holds the extend object's pipe transformation
 * method.
 * @property extractData - Holds the xtract object's pipe transformation
 * method.
 * @property getFilenameByPrefix - Holds the get file name by prefix's pipe
 * transformation method.
 * @property numberGetUTCTimestamp - Holds a date (and time) to unix timestamp
 * converter pipe transform method.
 * @property representObject - Represent object pipe's method.
 * @property tools - Holds the tools class from the tools service.
 */let DataScopeService=exports.DataScopeService=(_dec36=(0,_core.Injectable)(),_dec36(_class45=class DataScopeService{/**
     * Saves alle needed services as property values.
     * @param attachmentWithPrefixExistsPipe - Attachment by prefix checker
     * pipe instance.
     * @param data - Injected data service instance.
     * @param extendObjectPipe - Injected extend object pipe instance.
     * @param extractDataPipe - Injected extract data pipe instance.
     * @param getFilenameByPrefixPipe - Saves the file name by prefix retriever
     * pipe instance.
     * @param initialData - Injected initial data service instance.
     * @param numberGetUTCTimestampPipe - Date (and time) to unix timestamp
     * converter pipe instance.
     * @param representObjectPipe - Represent object pipe instance.
     * @param tools - Injected tools service instance.
     * @returns Nothing.
     */constructor(attachmentWithPrefixExistsPipe,data,extendObjectPipe,extractDataPipe,getFilenameByPrefixPipe,initialData,numberGetUTCTimestampPipe,representObjectPipe,tools){this.attachmentWithPrefixExists=this.attachmentWithPrefixExists;this.configuration=this.configuration;this.data=this.data;this.extendObject=this.extendObject;this.extractData=this.extractData;this.getFilenameByPrefix=this.getFilenameByPrefix;this.numberGetUTCTimestamp=this.numberGetUTCTimestamp;this.representObject=this.representObject;this.tools=this.tools;this.attachmentWithPrefixExists=attachmentWithPrefixExistsPipe.transform.bind(attachmentWithPrefixExistsPipe);this.configuration=initialData.configuration;this.data=data;this.extendObject=extendObjectPipe.transform.bind(extendObjectPipe);this.extractData=extractDataPipe.transform.bind(extractDataPipe);this.getFilenameByPrefix=getFilenameByPrefixPipe.transform.bind(getFilenameByPrefixPipe);this.numberGetUTCTimestamp=numberGetUTCTimestampPipe.transform.bind(numberGetUTCTimestampPipe);this.representObject=representObjectPipe.transform.bind(representObjectPipe);this.tools=tools.tools}/**
     * Useful to sets route specific data in a resolver.
     * @param modelName - Name of model to retrieve data from.
     * @param id - ID of an entity to retrieve data from.
     * @param propertyNames - List of property names to retrieve data from.
     * @param revision - Revision to use for retrieving needed data from data
     * service.
     * @param revisionHistory - Indicates whether the revision history should
     * be included.
     * @returns A promise wrapping requested data.
     */determine(modelName,id=null,propertyNames=null,revision='latest',revisionHistory=false){var _this7=this;return _asyncToGenerator(function*(){let data={};if(id){const options={};if(revision==='latest'){options.latest=true;if(revisionHistory)/* eslint-disable camelcase */options.revs_info=true;/* eslint-enable camelcase */}else options.rev=revision;try{data=yield _this7.data.get(id,options)}catch(error){throw new Error(`Document with given id "${id}" and revision "`+`${revision}" isn't available: `+('message'in error?error.message:_this7.representObject(error)))}if(revisionHistory){const revisionsInformationName=_this7.configuration.database.model.property.name.special.revisionsInformation;let revisions;let latestData;if(revision!=='latest'){delete options.rev;/* eslint-disable camelcase */options.revs_info=true;/* eslint-enable camelcase */try{latestData=yield _this7.data.get(id,options)}catch(error){throw new Error(`Document with given id "${id}" and revision "`+`${revision}" isn't available: `+('message'in error?error.message:_this7.representObject(error)))}revisions=latestData[revisionsInformationName];delete latestData[revisionsInformationName]}else revisions=data[revisionsInformationName];data[revisionsInformationName]={};let first=true;for(const item of revisions)if(item.status==='available'){data[revisionsInformationName][first?'latest':item.rev]={revision:item.rev};first=false}if(latestData)data[revisionsInformationName].latest.scope=_this7.generate(modelName,propertyNames,latestData)}}return _this7.generate(modelName,propertyNames,data)})()}// TODO test
/**
     * Determines a nested specification object for given property name and
     * corresponding specification object where given property is bound to.
     * @param name - Property name to search specification for.
     * @param specification - Parents object specification.
     * @returns New specification object or null if it could not be determined.
     */determineNestedSpecifcation(name,specification){const entities=this.configuration.database.model.entities;const additionalName=this.configuration.database.model.property.name.special.additional;if(specification)if(specification.hasOwnProperty(name)){if(entities.hasOwnProperty(specification[name].type))return entities[specification[name].type]}else if(specification.hasOwnProperty(additionalName)&amp;&amp;entities.hasOwnProperty(specification[additionalName].type))return entities[specification[additionalName].type];return null}/**
     * Determines a recursive resolved specification object for given (flat)
     * model object.
     * @param modelSpecification - Specification object to traverse.
     * @param propertyNames - List of property names to consider.
     * @param propertyNamesToIgnore - List of property names to skip.
     * @returns Resolved specification object.
     */determineSpecificationObject(modelSpecification,propertyNames,propertyNamesToIgnore=[]){if(!propertyNames)propertyNames=Object.keys(modelSpecification);const result={};for(const name of propertyNames)if(modelSpecification.hasOwnProperty(name)&amp;&amp;!propertyNamesToIgnore.includes(name))if(name===this.configuration.database.model.property.name.special.attachment){result[name]={};for(const fileType in modelSpecification[name])if(modelSpecification[name].hasOwnProperty(fileType))result[name][fileType]=this.extendObject(true,this.tools.copyLimitedRecursively(this.configuration.database.model.property.defaultSpecification),modelSpecification[name][fileType])}else{result[name]=this.extendObject(true,this.tools.copyLimitedRecursively(this.configuration.database.model.property.defaultSpecification),modelSpecification[name]);if(this.configuration.database.model.entities.hasOwnProperty(result[name].type))result[name].value=this.determineSpecificationObject(this.configuration.database.model.entities[result[name].type])}return result}/**
     * Generates a scope object for given model with given property names and
     * property value mapping data.
     * @param modelName - Name of model to generate scope for.
     * @param propertyNames - List of property names to generate meta data in
     * scope for. If "null" is given all properties in given model will be
     * taken into account.
     * @param data - Data to use for given properties.
     * @param propertyNamesToIgnore - Property names ti skip.
     * @returns The generated scope object.
     */generate(modelName,propertyNames,data={},propertyNamesToIgnore){const entities=this.configuration.database.model.entities;const modelSpecification=entities[modelName];const specialNames=this.configuration.database.model.property.name.special;if(!propertyNamesToIgnore)propertyNamesToIgnore=modelName.startsWith('_')?[specialNames.id,specialNames.attachment]:[];const reservedNames=this.configuration.database.model.property.name.reserved.concat(specialNames.conflict,specialNames.deleted,specialNames.deletedConflict,specialNames.localSequence,specialNames.revision,specialNames.revisions,specialNames.revisionsInformation,specialNames.type);const specification=this.determineSpecificationObject(modelSpecification,propertyNames,propertyNamesToIgnore.concat(reservedNames));if(!propertyNames){propertyNames=Object.keys(specification).filter(key=>typeof specification[key]==='object'&amp;&amp;typeof specification[key]!==null&amp;&amp;!Array.isArray(specification[key]));propertyNames=propertyNames.concat(Object.keys(data).filter(name=>!propertyNames.concat(reservedNames).includes(name)))}const result={};for(const name of propertyNames){if(propertyNamesToIgnore.includes(name))continue;if(specification.hasOwnProperty(name))result[name]=this.tools.copyLimitedRecursively(specification[name]);else result[name]=this.tools.copyLimitedRecursively('additional'in specialNames&amp;&amp;specialNames.additional?specification[specialNames.additional]:{});const now=new Date;const nowUTCTimestamp=this.numberGetUTCTimestamp(now);if(name===specialNames.attachment){for(const type in specification[name])if(specification[name].hasOwnProperty(type)){result[name][type].name=type;result[name][type].value=null;if(Object.keys(data).length===0)for(const hookType of['onCreateExecution','onCreateExpression'])if(result[name][type].hasOwnProperty(hookType)&amp;&amp;result[name][type][hookType]){result[name][type].value=new Function('newDocument','oldDocument','userContext','securitySettings','name','models','modelConfiguration','serialize','modelName','model','propertySpecification','now','nowUTCTimestamp','getFilenameByPrefix','attachmentWithPrefixExists',(hookType.endsWith('Expression')?'return ':'')+result[name][type][hookType])(data,null,{},{},type,entities,this.configuration.database.model,object=>JSON.stringify(object,null,4),modelName,modelSpecification,result[name][type],now,nowUTCTimestamp,this.getFilenameByPrefix,this.attachmentWithPrefixExists.bind(data,data),result[name][type]);if(result[name][type].hasOwnProperty('value')&amp;&amp;result[name][type].value===undefined)delete result[name][type].value}let fileFound=false;if(data.hasOwnProperty(name)&amp;&amp;![undefined,null].includes(data[name]))for(const fileName in data[name])if(result[name].hasOwnProperty(type)&amp;&amp;new RegExp(type).test(fileName)){fileFound=true;result[name][type].value=data[name][fileName];result[name][type].value.name=fileName;break}if(!fileFound&amp;&amp;result[name][type].hasOwnProperty('default')&amp;&amp;![undefined,null].includes(result[name][type].default))result[name][type].value=this.tools.copyLimitedRecursively({},result[name][type].default)}}else{result[name].name=name;result[name].value=null;if(Object.keys(data).length===0)for(const type of['onCreateExpression','onCreateExecution'])if(result[name].hasOwnProperty(type)&amp;&amp;result[name][type]){result[name].value=new Function('newDocument','oldDocument','userContext','securitySettings','name','models','modelConfiguration','serialize','modelName','model','propertySpecification','now','nowUTCTimestamp','getFilenameByPrefix','attachmentWithPrefixExists',(type.endsWith('Expression')?'return ':'')+result[name][type])(data,null,{},{},name,entities,this.configuration.database.model,object=>JSON.stringify(object,null,4),modelName,modelSpecification,result[name],now,nowUTCTimestamp,this.getFilenameByPrefix,this.attachmentWithPrefixExists.bind(data,data),result[name]);if(result[name].value===undefined)result[name].value=null}if(data.hasOwnProperty(name)&amp;&amp;![undefined,null].includes(data[name]))result[name].value=data[name];else if(result[name].hasOwnProperty('default')&amp;&amp;![undefined,null].includes(result[name].default))result[name].value=this.tools.copyLimitedRecursively(result[name].default);else if(result[name].hasOwnProperty('selection')&amp;&amp;Array.isArray(result[name].selection)&amp;&amp;result[name].selection.length)result[name].value=result[name].selection[0];if(typeof result[name].value==='number'&amp;&amp;result[name].hasOwnProperty('type')&amp;&amp;(result[name].type.endsWith('Date')||result[name].type.endsWith('Time')))// NOTE: We interpret given value as an utc timestamp.
result[name].value=new Date(result[name].value*1000);else if(result[name].hasOwnProperty('type'))if(entities.hasOwnProperty(result[name].type))result[name].value=this.generate(result[name].type,null,result[name].value||{},[specialNames.attachment,specialNames.id]);else if(result[name].type.endsWith('[]')){const type=result[name].type.substring(0,result[name].type.length-2);if(Array.isArray(result[name].value)&amp;&amp;entities.hasOwnProperty(type)){let index=0;for(const item of result[name].value){result[name].value[index]=this.generate(type,null,item||{},[specialNames.attachment,specialNames.id]);index+=1}}}}}for(const name of reservedNames)if(data.hasOwnProperty(name))result[name]=data[name];else if(name===specialNames.type)result[name]=modelName;result._metaData={submitted:false};return result}})||_class45);// / region abstract
// IgnoreTypeCheck
Reflect.defineMetadata('design:paramtypes',[AttachmentWithPrefixExistsPipe,DataService,ExtendObjectPipe,ExtractDataPipe,GetFilenameByPrefixPipe,InitialDataService,NumberGetUTCTimestampPipe,RepresentObjectPipe,ToolsService],DataScopeService);/**
 * Helper class to extend from to have some basic methods to deal with database
 * entities.
 * @property data - Holds currently retrieved data.
 * @property databaseBaseURL - Determined database base url.
 * @property databaseURL - Determined database url.
 * @property domSanitizer - Dom sanitizer service instance.
 * @property escapeRegularExpressions - Holds the escape regular expressions's
 * pipe transformation method.
 * @property extendObject - Holds the extend object's pipe transformation
 * method.
 * @property message - Message box service.
 * @property messageConfiguration - Plain message box configuration object.
 * @property modelConfiguration - Saves a mapping from all available model
 * names to their specification.
 * @property relevantKeys - Saves a list of relevant key names to take into
 * account during resolving.
 * @property relevantSearchKeys - Saves a list of relevant key names to take
 * into during searching.
 * @property representObject - Represent object pipe transformation function.
 * @property specialNames - mapping of special database field names.
 * @property type - Model name to handle. Should be overwritten in concrete
 * implementations.
 */let AbstractResolver/* implements Resolve&lt;PlainObject>*/=exports.AbstractResolver=(_dec37=(0,_core.Injectable)(),_dec37(_class47=class AbstractResolver{/**
     * Sets all needed injected services as instance properties.
     * @param injector - Application specific injector to use instead auto
     * detected one.
     * @returns Nothing.
     */constructor(injector){this.data=this.data;this.databaseBaseURL=this.databaseBaseURL;this.databaseURL=this.databaseURL;this.databaseURLCache={};this.domSanitizer=this.domSanitizer;this.escapeRegularExpressions=this.escapeRegularExpressions;this.extendObject=this.extendObject;this.message=this.message;this.messageConfiguration=new _material.MatSnackBarConfig;this.modelConfiguration=this.modelConfiguration;this.relevantKeys=null;this.relevantSearchKeys=null;this.representObject=this.representObject;this.specialNames=this.specialNames;this.type='Item';const get=determineInjector(injector,this,this.constructor);this.data=get(DataService);this.domSanitizer=get(_platformBrowser.DomSanitizer);const databaseBaseURL=get(StringFormatPipe).transform(get(InitialDataService).configuration.database.url,'')+'/';this.databaseBaseURL=`${databaseBaseURL}_utils/#/database/`+`${get(InitialDataService).configuration.name}/`;this.databaseURL=databaseBaseURL+get(InitialDataService).configuration.name;this.escapeRegularExpressions=get(StringEscapeRegularExpressionsPipe).transform.bind(get(StringEscapeRegularExpressionsPipe));this.extendObject=get(ExtendObjectPipe).transform.bind(get(ExtendObjectPipe));this.messageConfiguration.duration=5*1000;this.message=message=>get(_material.MatSnackBar).open(message,false,this.messageConfiguration);this.modelConfiguration=get(InitialDataService).configuration.database.model;this.representObject=get(RepresentObjectPipe).transform.bind(get(RepresentObjectPipe));this.specialNames=get(InitialDataService).configuration.database.model.property.name.special}/**
     * Determines item specific database url by given item data object.
     * @param item - Given item object.
     * @returns Determined url.
     */getDatabaseURL(item){const url=this.databaseBaseURL+(typeof item[this.specialNames.id]==='object'?item[this.specialNames.id].value:item[this.specialNames.id]);// NOTE: We cache sanitized urls to avoid reloads.
if(!this.databaseURLCache.hasOwnProperty(url))this.databaseURLCache[url]=this.domSanitizer.bypassSecurityTrustResourceUrl(url);return this.databaseURLCache[url]}/**
     * List items which matches given filter criteria.
     * @param sort - List of items.
     * @param page - Page to show.
     * @param limit - Maximal number of entities to retrieve.
     * @param searchTerm - String query to search for.
     * @param additionalSelector - Custom filter criteria.
     * @returns A promise wrapping retrieved data.
     */list(sort=[{[InitialDataService.defaultScope.configuration.database.model.property.name.special.id]:'asc'}],page=1,limit=10,searchTerm='',additionalSelector={}){if(!this.relevantSearchKeys){this.relevantSearchKeys=DataService.determineGenericIndexablePropertyNames(this.modelConfiguration,this.modelConfiguration.entities[this.type]);this.relevantSearchKeys.splice(this.relevantSearchKeys.indexOf(this.specialNames.revision),1)}const selector={[this.specialNames.type]:this.type};if(searchTerm||Object.keys(additionalSelector).length){if(sort.length)selector[Object.keys(sort[0])[0]]={$gt:null};selector.$or=[];for(const name of this.relevantSearchKeys)selector.$or.push({[name]:{$regex:searchTerm}});if(additionalSelector.hasOwnProperty('$or')&amp;&amp;additionalSelector.$or.length){/*
                    NOTE: We have to integrate search expression into existing
                    selector.
                */for(const item of selector.$or)item.$or=additionalSelector.$or;delete additionalSelector.$or}}/*
            NOTE: We can't use "limit" here since we want to provide total data
            set size for pagination.
        */const options={skip:Math.max(page-1,0)*limit};if(this.relevantKeys)options.fields=this.relevantKeys;if(options.skip===0)delete options.skip;if(sort.length)options.sort=[{[this.specialNames.type]:'asc'}].concat(sort);return this.data.find(this.extendObject(true,selector,additionalSelector),options)}/**
     * Removes given item.
     * @param item - Item or id to delete.
     * @param message - Message to show after successful removement.
     * @returns Nothing.
     */remove(item,message=''){return this.update(item,{[this.specialNames.deleted]:true},message)}/* eslint-disable no-unused-vars *//**
     * Implements the resolver method which converts route informations into
     * "list()" method parameter and forward their result as result in an
     * observable.
     * @param route - Current route informations.
     * @param state - Current state informations.
     * @returns Promise with data filtered by current route informations.
     */resolve(route,state){/* eslint-enable no-unused-vars */let searchTerm='';if('searchTerm'in route.params){const term=decodeURIComponent(route.params.searchTerm);if(term.startsWith('exact-'))searchTerm=this.escapeRegularExpressions(term.substring('exact-'.length));else if(term.startsWith('regex-')){searchTerm=term.substring('regex-'.length);try{new RegExp(searchTerm)}catch(error){searchTerm=''}}}let sort=[];if('sort'in route.params)sort=route.params.sort.split(',').map(name=>{const lastIndex=name.lastIndexOf('-');let type='asc';if(lastIndex!==-1){name=name.substring(0,lastIndex);type=name.substring(lastIndex+1)||type}return{[name]:type}});return this.list(sort,parseInt(route.params.page||1),parseInt(route.params.limit||10),searchTerm)}/**
     * Updates given item.
     * @param item - Item to update.
     * @param data - Optional given data to update into given item.
     * @param message - Message to should if process was successfully.
     * @returns A boolean indicating if requested update was successful.
     */update(item,data,message=''){var _this8=this;return _asyncToGenerator(function*(){let newData;if(data)newData=_this8.extendObject({[_this8.specialNames.id]:typeof item[_this8.specialNames.id]==='object'?item[_this8.specialNames.id].value:item[_this8.specialNames.id],[_this8.specialNames.revision]:'latest',[_this8.specialNames.type]:item[_this8.specialNames.type]},data);else newData=item;try{item[_this8.specialNames.revision]=(yield _this8.data.put(newData)).rev}catch(error){_this8.message('message'in error?error.message:_this8.representObject(error));return false}if(message)_this8.message(message);return true})()}})||_class47);// / endregion
// endregion
// region components/directives
// / region abstract
/**
 * Generic input component.
 * @property declaration - Declaration info text.
 * @property description - Description to use instead of those coming from
 * model specification.
 * @property disabled - Sets disabled state.
 * @property maximum - Maximum allowed number value.
 * @property maximumLength - Maximum allowed number of symbols.
 * @property maximumLengthText - Maximum length validation text.
 * @property maximumText - Maximum number validation text.
 * @property minimum - Minimum allowed number.
 * @property minimumLength - Minimum allowed number of symbols.
 * @property minimumLengthText - Minimum number validation text.
 * @property minimumText - Minimum number validation text.
 * @property model - Holds model informations including actual value and
 * metadata.
 * @property modelChange - Model event emitter emitting events on each model
 * change.
 * @property pattern - Allowed pattern to match against given input.
 * @property patternText - Pattern validation text.
 * @property required - Indicates whether this inputs have to be filled.
 * @property requiredText - Required validation text.
 * @property showDeclarationText - Info text to click for more informations.
 * @property showValidationErrorMessages - Indicates whether validation errors
 * should be suppressed or be shown automatically. Useful to prevent error
 * component from showing error messages before the user has submit the form.
 * @property type - Type of given input.
 */(0,_core.Optional)()(AbstractResolver,null,0);Reflect.defineMetadata('design:paramtypes',[_core.Injector],AbstractResolver);let AbstractInputComponent/* implements OnInit*/=exports.AbstractInputComponent=(_dec38=(0,_core.Input)(),_dec39=(0,_core.Input)(),_dec40=(0,_core.Input)(),_dec41=(0,_core.Input)(),_dec42=(0,_core.Input)(),_dec43=(0,_core.Input)(),_dec44=(0,_core.Input)(),_dec45=(0,_core.Input)(),_dec46=(0,_core.Input)(),_dec47=(0,_core.Input)(),_dec48=(0,_core.Input)(),_dec49=(0,_core.Input)(),_dec50=(0,_core.Output)(),_dec51=(0,_core.Input)(),_dec52=(0,_core.Input)(),_dec53=(0,_core.Input)(),_dec54=(0,_core.Input)(),_dec55=(0,_core.Input)(),_dec56=(0,_core.Input)(),_dec57=(0,_core.Input)(),(_class49=class AbstractInputComponent{constructor(){_initDefineProp(this,'declaration',_descriptor3,this);_initDefineProp(this,'description',_descriptor4,this);_initDefineProp(this,'disabled',_descriptor5,this);_initDefineProp(this,'maximum',_descriptor6,this);_initDefineProp(this,'maximumLength',_descriptor7,this);_initDefineProp(this,'maximumLengthText',_descriptor8,this);_initDefineProp(this,'maximumText',_descriptor9,this);_initDefineProp(this,'minimum',_descriptor10,this);_initDefineProp(this,'minimumLength',_descriptor11,this);_initDefineProp(this,'minimumLengthText',_descriptor12,this);_initDefineProp(this,'minimumText',_descriptor13,this);_initDefineProp(this,'model',_descriptor14,this);_initDefineProp(this,'modelChange',_descriptor15,this);_initDefineProp(this,'pattern',_descriptor16,this);_initDefineProp(this,'patternText',_descriptor17,this);_initDefineProp(this,'required',_descriptor18,this);_initDefineProp(this,'requiredText',_descriptor19,this);_initDefineProp(this,'showDeclarationText',_descriptor20,this);_initDefineProp(this,'showValidationErrorMessages',_descriptor21,this);_initDefineProp(this,'type',_descriptor22,this)}},(_descriptor3=_applyDecoratedDescriptor(_class49.prototype,'declaration',[_dec38],{enumerable:true,initializer:function(){return null}}),_descriptor4=_applyDecoratedDescriptor(_class49.prototype,'description',[_dec39],{enumerable:true,initializer:function(){return null}}),_descriptor5=_applyDecoratedDescriptor(_class49.prototype,'disabled',[_dec40],{enumerable:true,initializer:function(){return null}}),_descriptor6=_applyDecoratedDescriptor(_class49.prototype,'maximum',[_dec41],{enumerable:true,initializer:function(){return null}}),_descriptor7=_applyDecoratedDescriptor(_class49.prototype,'maximumLength',[_dec42],{enumerable:true,initializer:function(){return null}}),_descriptor8=_applyDecoratedDescriptor(_class49.prototype,'maximumLengthText',[_dec43],{enumerable:true,initializer:function(){return'Please type less or equal than ${model.maximumLength} symbols.'}}),_descriptor9=_applyDecoratedDescriptor(_class49.prototype,'maximumText',[_dec44],{enumerable:true,initializer:function(){return'Please give a number less or equal than ${model.maximum}.'}}),_descriptor10=_applyDecoratedDescriptor(_class49.prototype,'minimum',[_dec45],{enumerable:true,initializer:function(){return null}}),_descriptor11=_applyDecoratedDescriptor(_class49.prototype,'minimumLength',[_dec46],{enumerable:true,initializer:function(){return null}}),_descriptor12=_applyDecoratedDescriptor(_class49.prototype,'minimumLengthText',[_dec47],{enumerable:true,initializer:function(){return'Please type at least or equal ${model.minimumLength} symbols.'}}),_descriptor13=_applyDecoratedDescriptor(_class49.prototype,'minimumText',[_dec48],{enumerable:true,initializer:function(){return'Please given a number at least or equal to {{model.minimum}}.'}}),_descriptor14=_applyDecoratedDescriptor(_class49.prototype,'model',[_dec49],{enumerable:true,initializer:function(){return{}}}),_descriptor15=_applyDecoratedDescriptor(_class49.prototype,'modelChange',[_dec50],{enumerable:true,initializer:function(){return new _core.EventEmitter}}),_descriptor16=_applyDecoratedDescriptor(_class49.prototype,'pattern',[_dec51],{enumerable:true,initializer:function(){return this.pattern}}),_descriptor17=_applyDecoratedDescriptor(_class49.prototype,'patternText',[_dec52],{enumerable:true,initializer:function(){return'Your string have to match the regular expression: "'+'${model.regularExpressionPattern}".'}}),_descriptor18=_applyDecoratedDescriptor(_class49.prototype,'required',[_dec53],{enumerable:true,initializer:function(){return null}}),_descriptor19=_applyDecoratedDescriptor(_class49.prototype,'requiredText',[_dec54],{enumerable:true,initializer:function(){return'Please fill this field.'}}),_descriptor20=_applyDecoratedDescriptor(_class49.prototype,'showDeclarationText',[_dec55],{enumerable:true,initializer:function(){return'\u2139'}}),_descriptor21=_applyDecoratedDescriptor(_class49.prototype,'showValidationErrorMessages',[_dec56],{enumerable:true,initializer:function(){return false}}),_descriptor22=_applyDecoratedDescriptor(_class49.prototype,'type',[_dec57],{enumerable:true,initializer:function(){return this.type}})),_class49));/* eslint-disable brace-style *//**
 * Generic input component.
 * @property _attachmentWithPrefixExists - Holds the attachment by prefix
 * checker pipe instance
 * @property _extendObject - Holds the extend object's pipe transformation
 * @property _getFilenameByPrefix - Holds the get file name by prefix's pipe
 * transformation method.
 * @property _modelConfiguration - All model configurations.
 * @property _numberGetUTCTimestamp - Date (and time) to unix timstamp
 * converter pipe transform method.
 */let AbstractNativeInputComponent=exports.AbstractNativeInputComponent=class AbstractNativeInputComponent extends AbstractInputComponent/* implements OnInit*/{/**
     * Sets needed services as property values.
     * @param injector - Application specific injector to use instead auto
     * detected one.
     * @returns Nothing.
     */constructor(injector){super(injector);this._attachmentWithPrefixExists=this._attachmentWithPrefixExists;this._extendObject=this._extendObject;this._getFilenameByPrefix=this._getFilenameByPrefix;this._modelConfiguration=this._modelConfiguration;this._numberGetUTCTimestamp=this._numberGetUTCTimestamp;const get=determineInjector(injector,this,this.constructor);this._attachmentWithPrefixExists=get(AttachmentWithPrefixExistsPipe).transform.bind(get(AttachmentWithPrefixExistsPipe));this._extendObject=get(ExtendObjectPipe).transform.bind(get(ExtendObjectPipe));this._getFilenameByPrefix=get(GetFilenameByPrefixPipe).transform.bind(get(GetFilenameByPrefixPipe));this._modelConfiguration=get(InitialDataService).configuration.database.model;this._numberGetUTCTimestamp=get(NumberGetUTCTimestampPipe).transform.bind(get(NumberGetUTCTimestampPipe))}/**
     * Triggers after input values have been resolved.
     * @returns Nothing.
     *//* eslint-enable brace-style */ngOnInit(){this._extendObject(this.model,this._extendObject({disabled:false,emptyEqualsToNull:true,maximum:Infinity,minimum:0,maximumLength:Infinity,minimumLength:0,nullable:true,regularExpressionPattern:'.*',state:{},trim:true,type:'string'},this.model));if(typeof this.model.value==='string'&amp;&amp;this.model.trim)this.model.value===this.model.value.trim();for(const hookType of['onUpdateExpression','onUpdateExecution'])if(this.model.hasOwnProperty(hookType)&amp;&amp;this.model[hookType]&amp;&amp;typeof this.model[hookType]!=='function')this.model[hookType]=new Function('newDocument','oldDocument','userContext','securitySettings','name','models','modelConfiguration','serialize','modelName','model','propertySpecification','now','nowUTCTimestamp','getFilenameByPrefix','attachmentWithPrefixExists',(hookType.endsWith('Expression')?'return ':'')+this.model[hookType])}/**
     * Triggers when ever a change to current model happens inside this
     * component.
     * @param newValue - Value to use to update model with.
     * @param state - Saves the current model state.
     * @returns Nothing.
     */onChange(newValue,state){if(this.model.type==='integer')newValue=parseInt(newValue);else if(this.model.type==='number')newValue=parseFloat(newValue);else if(newValue&amp;&amp;this.model.type==='string'&amp;&amp;this.model.trim)newValue=newValue.trim();const now=new Date;const nowUTCTimestamp=this._numberGetUTCTimestamp(now);const newData={[this.model.name]:newValue};for(const hookType of['onUpdateExpression','onUpdateExecution'])if(this.model.hasOwnProperty(hookType)&amp;&amp;this.model[hookType]&amp;&amp;typeof this.model[hookType]==='function'){newValue=this.model[hookType](newData,null,{},{},this.model.name,this._modelConfiguration.entities,this._modelConfiguration,object=>JSON.stringify(object,null,4),'generic',{generic:{[this.model.name]:this.model}},this.model,now,nowUTCTimestamp,this._getFilenameByPrefix,this._attachmentWithPrefixExists.bind(newData,newData),newValue);if(!(newValue instanceof Date)&amp;&amp;(this.model.type.endsWith('Date')||this.model.type.endsWith('Time')))newValue*=1000}this.model.state=state;return newValue}};/**
 * Observes database for any data changes and triggers corresponding methods
 * on corresponding events.
 * @property static:defaultLiveUpdateOptions - Options for database
 * observation.
 *
 * @property actions - Array if actions which have happen.
 * @property autoRestartOnError - Indicates whether we should re-initialize
 * the changes stream on errors.
 *
 * @property _canceled - Indicates whether current view has been destroyed and
 * data observation should bee canceled.
 * @property _changeDetectorReference - Current views change detector reference
 * service instance.
 * @property _changesStream - Database observation representation.
 * @property _data - Data service instance.
 * @property _extendObject - Extend object pipe's transformation method.
 * @property _liveUpdateOptions - Options for database observation.
 * @property _stringCapitalize - String capitalize pipe transformation
 * function.
 * @property _tools - Holds the tools class from the tools service.
 */(0,_core.Optional)()(AbstractNativeInputComponent,null,0);Reflect.defineMetadata('design:paramtypes',[_core.Injector],AbstractNativeInputComponent);let AbstractLiveDataComponent/* implements OnDestroy, OnInit*/=exports.AbstractLiveDataComponent=(_temp3=_class52=class AbstractLiveDataComponent{/**
     * Saves injected service instances as instance properties.
     * @param injector - Application specific injector to use instead auto
     * detected one.
     * @returns Nothing.
     */constructor(injector){this.actions=[];this.autoRestartOnError=true;this._canceled=false;this._changeDetectorReference=this._changeDetectorReference;this._changesStream=this._changesStream;this._data=this._data;this._extendObject=this._extendObject;this._liveUpdateOptions={};this._stringCapitalize=this._stringCapitalize;this._tools=this._tools;const get=determineInjector(injector,this,this.constructor);this._changeDetectorReference=get(_core.ChangeDetectorRef);this._data=get(DataService);this._extendObject=get(ExtendObjectPipe).transform.bind(get(ExtendObjectPipe));this._stringCapitalize=get(StringCapitalizePipe).transform.bind(get(StringCapitalizePipe));this._tools=get(ToolsService).tools}/**
     * Initializes data observation when view has been initialized.
     * @returns Nothing.
     */ngOnInit(){var _this9=this;const initialize=this._tools.debounce(()=>{this._changesStream=this._data.connection.changes(this._extendObject(true,{},{since:LAST_KNOWN_DATA.sequence},this.constructor.defaultLiveUpdateOptions,this._liveUpdateOptions));for(const type of['change','complete','error'])this._changesStream.on(type,(()=>{var _ref5=_asyncToGenerator(function*(action){if(_this9._canceled)return;if(type==='change'){if('seq'in action&amp;&amp;typeof action.seq==='number')LAST_KNOWN_DATA.sequence=action.seq;LAST_KNOWN_DATA.data[action.id]=action.doc}action.name=type;_this9.actions.unshift(action);// IgnoreTypeCheck
let result=_this9[`onData${_this9._stringCapitalize(type)}`](action);if(result!==null&amp;&amp;typeof result==='object'&amp;&amp;'then'in result)result=yield result;if(result)_this9._changeDetectorReference.detectChanges();if(type==='error'&amp;&amp;_this9.autoRestartOnError){console.log('EE');initialize()}});return function(_x4){return _ref5.apply(this,arguments)}})())},3000);/*
            NOTE: We have to break out of the "zone.js" since long polling
            themes to confuse its mocked environment.
        */this._tools.timeout(initialize)}/**
     * Marks current live data observation as canceled and closes initially
     * requested update stream.
     * @returns Nothing.
     */ngOnDestroy(){this._canceled=true;if(this._changesStream)this._changesStream.cancel()}/**
     * Triggers on any data changes.
     * @returns A boolean indicating whether a view update should be triggered
     * or not.
     */onDataChange(){return true}/**
     * Triggers on completed data change observation.
     * @returns A boolean indicating whether a view update should be triggered
     * or not.
     */onDataComplete(){return false}/**
     * Triggers on data change observation errors.
     * @returns A boolean indicating whether a view update should be triggered
     * or not.
     */onDataError(){return false}},_class52.defaultLiveUpdateOptions={heartbeat:10000,/* eslint-disable camelcase */include_docs:true,/* eslint-enable camelcase */live:true,since:'now',timeout:false},_temp3);/* eslint-disable brace-style *//**
 * A generic abstract component to edit, search, navigate and filter a list of
 * entities.
 * @property allItems - Current list of items.
 * @property allItemsChecked - Indicates whether all currently selected items
 * are checked via select all selector.
 * @property items - Current list of visible items.
 * @property limit - Maximal number of visible items.
 * @property page - Current page number of each item list part.#
 * @property preventedDataUpdate - Saves null or arguments to a prevented data
 * updates.
 * @property regularExpression - Indicator whether searching via regular
 * expressions should be used.
 * @property searchTerm - Search string to filter visible item list.
 * @property searchTermStream - Search term stream which debounces and caches
 * search results.
 * @property selectedItems - List of currently selected items for group editing
 * purposes.
 * @property sort - Sorting informations.
 *
 * @property _currentParameter - Saves current route url parameter.
 * @property _itemPath - Routing path to a specific item.
 * @property _itemsPath - Routing path to the items overview.
 * @property _route - Current route configuration.
 * @property _router - Router service instance.
 * @property _toolsInstance - Instance of tools service instance property.
 */(0,_core.Optional)()(AbstractLiveDataComponent,null,0);Reflect.defineMetadata('design:paramtypes',[_core.Injector],AbstractLiveDataComponent);let AbstractItemsComponent=exports.AbstractItemsComponent=class AbstractItemsComponent extends AbstractLiveDataComponent/* implements AfterContentChecked, OnDestroy*/{/**
     * Saves injected service instances as instance properties.
     * @param injector - Application specific injector to use instead auto
     * detected one.
     * @returns Nothing.
     *//* eslint-enable brace-style */constructor(injector){super(injector);this.allItems=this.allItems;this.allItemsChecked=false;this.debouncedUpdate=this.debouncedUpdate;this.items=this.items;this.limit=this.limit;this.navigateAway=false;this.page=this.page;this.preventedDataUpdate=null;this.regularExpression=false;this.searchTerm='';this.searchTermStream=new _rxjs.Subject;this.selectedItems=new Set;this.sort={[InitialDataService.defaultScope.configuration.database.model.property.name.special.id]:'asc'};this._currentParameter=this._currentParameter;this._itemPath='item';this._itemsPath='items';this._route=this._route;this._router=this._router;this._subscriptions=[];this._toolsInstance=this._toolsInstance;const get=determineInjector(injector);this.idName=get(InitialDataService).configuration.database.model.property.name.special.id;this.revisionName=get(InitialDataService).configuration.database.model.property.name.special.revision;this.keyCode=this._tools.keyCode;this._route=get(_router.ActivatedRoute);this._router=get(_router.Router);// IgnoreTypeCheck
this._toolsInstance=new this._tools;/*
            NOTE: Parameter have to be read before data to ensure that all page
            constraints have been set correctly before item slicing.
        */this._subscriptions.push(this._route.params.subscribe(data=>{this._currentParameter=data;this.limit=parseInt(this._currentParameter.limit);this.page=parseInt(this._currentParameter.page);const match=/(regex|exact)-(.*)/.exec(this._currentParameter.searchTerm);if(match){this.regularExpression=match[1]==='regex';this.searchTerm=decodeURIComponent(match[2])}}));this._subscriptions.push(this._route.data.subscribe(data=>{this.limit=Math.max(1,this.limit||1);const total=data.items.length+(Math.max(1,this.page||1)-1)*this.limit;this.allItems=data.items.slice();if(data.items.length>this.limit)data.items.splice(this.limit,data.items.length-this.limit);this.items=data.items;this.items.total=total;if(this.applyPageConstraints())this.update()}));this._subscriptions.push(this.searchTermStream.debounceTime(200).distinctUntilChanged().subscribe(()=>{this.page=1;return this.update()}));this.debouncedUpdate=this._tools.debounce(this.update.bind(this))}/**
     * Updates constraints between limit, page number and number of total
     * available items.
     * @returns A boolean indicating if something has changed to fulfill page
     * constraints.
     */applyPageConstraints(){const oldPage=this.page;const oldLimit=this.limit;this.limit=Math.max(1,this.limit||1);this.page=Math.max(1,Math.min(this.page,Math.ceil(// IgnoreTypeCheck
this.items.total/this.limit)));return this.page!==oldPage||this.limit!==oldLimit}/**
     * A function factory to generate functions which updates current view if
     * no route change happened between an asynchronous process.
     * @param callback - Function to wrap.
     * @returns Given function wrapped.
     */changeItemWrapperFactory(callback){var _this10=this;return(()=>{var _ref6=_asyncToGenerator(function*(...parameter){let update=true;const subscription=_this10._router.events.subscribe(function(event){if(event instanceof NavigationEnd){update=false;subscription.unsubscribe()}});_this10._subscriptions.push(subscription);const result=callback(...parameter);if(typeof result==='object'&amp;&amp;result!==null&amp;&amp;'then'in result)yield result;if(update)yield _this10.update(true);return result});return function(){return _ref6.apply(this,arguments)}})()}/**
     * Clear all currently selected items.
     * @returns Nothing.
     */clearSelectedItems(){for(const item of this.items){this.selectedItems.delete(item);item.selected=false}}/**
     * Switches section to item which has given id.
     * @param itemID - ID of item to switch to.
     * @param itemVersion - Version of item to switch to.
     * @returns A promise wrapping the navigation result.
     */goToItem(itemID,itemVersion='latest'){this.navigateAway=true;return this._router.navigate([this._itemPath,itemID,itemVersion])}/**
     * Checks if selection has changed.
     * @returns Nothing.
     */ngAfterContentChecked(){if(this.preventedDataUpdate)this.onDataChange(...this.preventedDataUpdate)}/**
     * Triggers on any data changes and updates item constraints.
     * @param parameter - Parameter to save for delayed update.
     * @returns False so their wont be a view update since a complete route
     * reload will be triggered.
     */onDataChange(...parameter){/*
            NOTE: We have to avoid that unexpected view changes do not happen
            on remote data changes.
        */if(this.selectedItems.size||![0,1].includes(parseInt(this._currentParameter.page)))this.preventedDataUpdate=parameter;else{this.preventedDataUpdate=null;this.debouncedUpdate(true)}/*
            NOTE: We want to avoid another reload if page is already violating
            page constraints which indicates a page reload.
        */return false}/**
     * Unsubscribes all subscriptions when this component should be disposed.
     * @param parameter - List of all parameter to forward to super method.
     * @returns Returns the super values return value.
     */ngOnDestroy(...parameter){const result=super.ngOnDestroy(...parameter);for(const subscription of this._subscriptions)subscription.unsubscribe();return result}/**
     * Select all available items.
     * @returns Nothing.
     */selectAllItems(){for(const item of this.items){this.selectedItems.add(item);item.selected=true}}/**
     * Determines an items content specific hash value combined from id and
     * revision.
     * @param item - Item with id and revision property.
     * @returns Indicator string.
     */trackByIDAndRevision(item){return`${item[this.idName]}/${item[this.revisionName]}`}/**
     * Applies current filter criteria to current visible item set.
     * @param reload - Indicates whether a simple reload should be made because
     * a changed list of available items is expected for example.
     * @returns A boolean indicating whether route change was successful.
     */update(reload=false){var _this11=this;return _asyncToGenerator(function*(){let result=false;yield _this11._toolsInstance.acquireLock(`${_this11.constructor.name}Update`);if(!_this11.navigateAway){_this11.applyPageConstraints();if(reload&amp;&amp;parseInt(_this11._currentParameter.page)!==0)/*
                    NOTE: Will be normalised to "1" after route reload (hack to
                    enforce route reloading).
                */_this11.page=0;let sort='';for(const name in _this11.sort)if(_this11.sort.hasOwnProperty(name))sort+=`${sort?',':''}${name}-${_this11.sort[name]}`;result=yield _this11._router.navigate([_this11._itemsPath,sort,_this11.page,_this11.limit,`${_this11.regularExpression?'regex':'exact'}-`+encodeURIComponent(_this11.searchTerm)],{preserveFragment:true,replaceUrl:parseInt(_this11._currentParameter.page)===0,skipLocationChange:_this11.page===0});if(result)_this11.allItemsChecked=false}_this11._toolsInstance.releaseLock(`${_this11.constructor.name}Update`);return result})()}/**
     * Applies current search term to the search term stream.
     * @returns Nothing.
     */updateSearch(){this.searchTermStream.next(this.searchTerm)}};/**
 * Generic value accessor with "ngModel" support.
 * @property onChangeCallback - Saves current on change callback.
 * @property onTouchedCallback - Saves current on touch callback.
 * @property type - Saves current input type.
 */(0,_core.Optional)()(AbstractItemsComponent,null,0);Reflect.defineMetadata('design:paramtypes',[_core.Injector],AbstractItemsComponent);let AbstractValueAccessor=exports.AbstractValueAccessor=(_dec58=(0,_core.Input)(),(_class54=class AbstractValueAccessor extends _forms.DefaultValueAccessor{/**
     * Initializes and forwards needed services to the default value accessor
     * constructor.
     * @param injector - Application specific injector to use instead auto
     * detected one.
     * @returns Nothing.
     */constructor(injector){super(injector.get(_core.Renderer2),injector.get(_core.ElementRef),null);this.onChangeCallback=_clientnode2.default.noop;this.onTouchedCallback=_clientnode2.default.noop;_initDefineProp(this,'type',_descriptor23,this)}/**
     * Manipulates editable value representation.
     * @param value - Value to manipulate.
     * @returns Given and transformed value.
     */export(value){return value}/**
     * Reads internal value representation.
     * @param value - Value to convert to its internal representation.
     * @returns Given and transformed value.
     */import(value){return value}/**
     * Needed implementation for an angular control value accessor.
     * @param callback - Callback function to register.
     * @param additionalParameter - Additional parameter will be forwarded to
     * inherited super method.
     * @returns What inherited method returns.
     */registerOnChange(callback,...additionalParameter){this.onChangeCallback=callback;return super.registerOnChange(callback,...additionalParameter)}/**
     * Needed implementation for an angular control value accessor.
     * @param callback - Callback function to register.
     * @param additionalParameter - Additional parameter will be forwarded to
     * inherited super method.
     * @returns What inherited method returns.
     */registerOnTouched(callback,...additionalParameter){this.onTouchedCallback=callback;return super.registerOnTouched(callback,...additionalParameter)}/**
     * Overridden inherited function for value export.
     * @param value - Value to export.
     * @param additionalParameter - Additional arguments will be forwarded to
     * the overridden method invocation.
     * @returns The transformed give value.
     */writeValue(value,...additionalParameter){return super.writeValue(this.export(value,...additionalParameter),...additionalParameter)}/**
     * Overridden inherited function for value import.
     * @param value - Value to import.
     * @param additionalParameter - Additional arguments will be forwarded to
     * the overridden method invocation.
     * @returns The transformed give value.
     */_handleInput(value,...additionalParameter){return super._handleInput(this.import(value,...additionalParameter),...additionalParameter)}},(_descriptor23=_applyDecoratedDescriptor(_class54.prototype,'type',[_dec58],{enumerable:true,initializer:function(){return this.type}})),_class54));// / endregion
// // region date/time
// IgnoreTypeCheck
Reflect.defineMetadata('design:paramtypes',[_core.Injector],AbstractValueAccessor);/**
 * Displays dates and/or times formated with markup and through angular date
 * pipe.
 * @property dateFormatter - Angular's date pipe transformation method.
 * @property extendObject - Extend object pipe's transform method.
 * @property options - Given formatting and update options.
 * @property templateReference - Reference to given template.
 * @property timerID - Interval id to cancel it on destroy life cycle hook.
 * @property viewContainerReference - View container reference to embed
 * rendered template instance into.
 */let GenericDateDirective=exports.GenericDateDirective=(_dec59=(0,_core.Directive)({selector:'[genericDate]'}),_dec60=(0,_core.Input)('genericDate'),_dec59(_class56=(_class57=class GenericDateDirective{/**
     * Saves injected services as instance properties.
     * @param datePipe - Injected date pipe service instance.
     * @param extendObjectPipe - Injected extend object pipe service instance.
     * @param templateReference - Specified template reference.
     * @param viewContainerReference - Injected view container reference.
     * @returns Nothing.
     */constructor(datePipe,extendObjectPipe,templateReference,viewContainerReference){this.dateFormatter=this.dateFormatter;this.extendObject=this.extendObject;this.options={dateTime:'now',format:'HH:mm:ss',freeze:false,updateIntervalInMilliseconds:1000};this.templateReference=this.templateReference;this.timerID=this.timerID;this.viewContainerReference=this.viewContainerReference;this.dateFormatter=datePipe.transform.bind(datePipe);this.extendObject=extendObjectPipe.transform.bind(extendObjectPipe);this.templateReference=templateReference;this.viewContainerReference=viewContainerReference}/**
     * Options setter to merge into options interactively.
     * @param options - Options object to merge into.
     * @returns Nothing.
     */set insertOptions(options={}){if(['string','number'].includes(typeof options)||[null,undefined].includes(options)||typeof options==='object'&amp;&amp;options instanceof Date)options={dateTime:options};this.extendObject(true,this.options,options)}/**
     * Inserts a rendered template instance into current view.
     * @returns Nothing.
     */insert(){let dateTime=this.options.dateTime;if(['now','',null,undefined].includes(dateTime)||isNaN(dateTime))dateTime=Date.now();else if(typeof dateTime==='string'&amp;&amp;`${parseFloat(dateTime)}`===dateTime)dateTime=parseFloat(dateTime)*1000;this.viewContainerReference.createEmbeddedView(this.templateReference,{dateTime:this.dateFormatter(dateTime,this.options.format)})}/**
     * On destroy life cycle hook to cancel initialized interval timer.
     * @returns Nothing.
     */ngOnDestroy(){if(this.timerID)clearInterval(this.timerID)}/**
     * Initializes interval timer and inserts initial template instance into
     * current view.
     * @returns Nothing.
     */ngOnInit(){this.timerID=setInterval(()=>{if(!this.options.freeze){this.viewContainerReference.remove();this.insert()}},this.options.updateIntervalInMilliseconds);this.insert()}},(_applyDecoratedDescriptor(_class57.prototype,'insertOptions',[_dec60],Object.getOwnPropertyDescriptor(_class57.prototype,'insertOptions'),_class57.prototype)),_class57))||_class56);// IgnoreTypeCheck
Reflect.defineMetadata('design:paramtypes',[_common.DatePipe,ExtendObjectPipe,_core.TemplateRef,_core.ViewContainerRef],GenericDateDirective);/**
 * TODO
 */let GenericSliderDirective=exports.GenericSliderDirective=(_dec61=(0,_core.Directive)({selector:'[genericSlider]'}),_dec62=(0,_core.Input)('genericSlider'),_dec61(_class59=(_class60=class GenericSliderDirective{/**
     * Saves injected services as instance properties.
     * @param extendObjectPipe - Injected extend object pipe service instance.
     * @param templateReference - Specified template reference.
     * @param viewContainerReference - Injected view container reference.
     * @returns Nothing.
     */constructor(extendObjectPipe,templateReference,viewContainerReference){this.extendObject=this.extendObject;this.index=0;this.options={freeze:false,startIndex:0,step:1,slides:[],updateIntervalInMilliseconds:6000};this.templateReference=this.templateReference;this.timerID=this.timerID;this.viewContainerReference=this.viewContainerReference;this.extendObject=extendObjectPipe.transform.bind(extendObjectPipe);this.templateReference=templateReference;this.viewContainerReference=viewContainerReference}/**
     * Calculates next index from given reference point.
     * @param startIndex - Reference index.
     * @returns New calculated index.
     */getNextIndex(startIndex=-1){if(startIndex===-1)startIndex=this.index;return(startIndex+this.options.step)%this.options.slides.length}/**
     * Options setter to merge into options interactively.
     * @param options - Options object to merge into.
     * @returns Nothing.
     */set insertOptions(options={}){if(Array.isArray(options))options={slides:options};this.extendObject(true,this.options,options)}/**
     * Inserts a rendered template instance into current view.
     * @returns Nothing.
     */update(){if(this.options.slides.length)this.viewContainerReference.createEmbeddedView(this.templateReference,{getNextIndex:this.getNextIndex.bind(this),index:this.index,options:this.options,slide:this.options.slides[this.index],slides:this.options.slides})}/**
     * On destroy life cycle hook to cancel initialized interval timer.
     * @returns Nothing.
     */ngOnDestroy(){if(this.timerID)clearInterval(this.timerID)}/**
     * Initializes interval timer and inserts initial template instance into
     * current view.
     * @returns Nothing.
     */ngOnInit(){this.timerID=setInterval(()=>{const newIndex=(this.index+this.options.step)%this.options.slides.length;if(this.options.freeze!==true&amp;&amp;newIndex!==this.index&amp;&amp;!(typeof this.options.freeze==='number'&amp;&amp;this.options.freeze>=this.options.slides.length)){this.viewContainerReference.remove();this.index=this.getNextIndex();this.update()}},this.options.updateIntervalInMilliseconds);this.index=this.options.startIndex;this.update()}},(_applyDecoratedDescriptor(_class60.prototype,'insertOptions',[_dec62],Object.getOwnPropertyDescriptor(_class60.prototype,'insertOptions'),_class60.prototype)),_class60))||_class59);// IgnoreTypeCheck
Reflect.defineMetadata('design:paramtypes',[ExtendObjectPipe,_core.TemplateRef,_core.ViewContainerRef],GenericSliderDirective);/**
 * Time value accessor with "ngModel" support.
 */let DateTimeValueAccessor=exports.DateTimeValueAccessor=(_dec63=(0,_core.Directive)(_clientnode2.default.extendObject(true,{},_forms.DefaultValueAccessor.decorators[0].args[0],{providers:[{provide:_forms.NG_VALUE_ACCESSOR,useExisting:(0,_core.forwardRef)(()=>DateTimeValueAccessor),multi:true}]})),_dec63(_class62=class DateTimeValueAccessor extends AbstractValueAccessor{/**
     * Delegates injected injector service instance to the super constructor.
     * @param injector - Injected injector service instance.
     * @returns Nothing.
     */constructor(injector){super(injector)}/**
     * Manipulates editable value representation.
     * @param value - Value to manipulate.
     * @returns Given and transformed value.
     */export(value){if(![undefined,null].includes(value)&amp;&amp;['date','time'].includes(this.type)){const date=new Date(value);if(isNaN(date.getDate()))return;else if(this.type==='time'){let hours=`${date.getHours()}`;if(hours.length===1)hours=`0${hours}`;let minutes=`${date.getMinutes()}`;if(minutes.length===1)minutes=`0${minutes}`;return`${hours}:${minutes}`}else if(this.type==='date'){let month=`${date.getMonth()+1}`;if(month.length===1)month=`0${month}`;let day=`${date.getDate()}`;if(day.length===1)day=`0${day}`;return`${date.getFullYear()}-${month}-${day}`}}return value}/**
     * Reads internal value representation.
     * @param value - Value to convert to its internal representation.
     * @returns Given and transformed value.
     */import(value){if(typeof value==='string')if(this.type==='time'){const match=/^([0-9]{2}):([0-9]{2})$/.exec(value);if(match)return new Date(1970,0,1,parseInt(match[1]),parseInt(match[2]))}else if(this.type==='date'){const match=/^([0-9]{4})-([0-9]{2})-([0-9]{2})$/.exec(value);if(match)return new Date(parseInt(match[1]),parseInt(match[2])-1,parseInt(match[3]))}return value}})||_class62);// // / region interval
// IgnoreTypeCheck
Reflect.defineMetadata('design:paramtypes',[_core.Injector],DateTimeValueAccessor);/**
 * Represents an interval input.
 * @property endDeclaration - End declaration info text.
 * @property startDeclaration - End declaration info text.
 *
 * @property endDescription - Description for end input.
 * @property startDescription - Description for start input.
 *
 * @property endDisabled - Sets end disabled state.
 * @property startDisabled - Sets start disabled state.
 *
 * @property endMaximum - Maximum allowed number end value.
 * @property startMaximum - Maximum allowed number start value.
 *
 * @property endMaximumText - Maximum number validation end text.
 * @property startMaximumText - Maximum number validation start text.
 *
 * @property endMinimum - Minimum allowed end number.
 * @property endMinimum - Minimum allowed start number.
 *
 * @property endMinimumText - Minimum end number validation text.
 * @property startMinimumText - Minimum start number validation text.
 *
 * @property endRequired - Indicates whether end input have to be filled.
 * @property startRequired - Indicates whether start input have to be filled.
 *
 * @property endRequiredText - Required validation end text.
 * @property startRequiredText - Required validation start text.
 *
 * @property endShowDeclarationText - Info text to click for more end input
 * informations.
 * @property startShowDeclarationText - Info text to click for more start input
 * informations.
 *
 * @property endShowDeclarationText - Info text to click for more end input
 * informations.
 * @property startShowDeclarationText - Info text to click for more
 * start input informations.
 *
 * @property endShowValidationErrorMessages - Indicates whether validation
 * errors should be suppressed or be shown automatically for end input.
 * @property startShowValidationErrorMessages - Indicates whether validation
 * errors should be suppressed or be shown automatically for start input.
 *
 * @property model - Object that saves start and end time as unix timestamp in
 * milliseconds.*
 * @property modelChange - Model event emitter emitting events on each model
 * change.
 */let IntervalInputComponent=exports.IntervalInputComponent=(_dec64=(0,_core.Component)({animations:[defaultAnimation()],changeDetection:_core.ChangeDetectionStrategy[CHANGE_DETECTION_STRATEGY_NAME],selector:'generic-interval-input',template:`
        &lt;generic-input
            [declaration]="startDeclaration"
            [description]="startDescription"
            [disabled]="startDisabled"
            [showDeclarationText]="startShowDeclarationText"
            [maximum]="startMaximum"
            [maximumText]="startMaximumText"
            [minimum]="startMinimum"
            [required]="startRequired"
            [requiredText]="startRequiredText"
            [minimumText]="startMinimumText"
            [model]="model.start"
            (model)="change($event, 'start')"
            [showValidationErrorMessages]="startShowValidationErrorMessages"
            type="time"
        >&lt;/generic-input>
        &lt;ng-content>&lt;/ng-content>
        &lt;generic-input
            [declaration]="endDeclaration"
            [description]="endDescription"
            [disabled]="endDisabled"
            [showDeclarationText]="endShowDeclarationText"
            [maximum]="endMaximum"
            [maximumText]="endMaximumText"
            [minimum]="endMinimum"
            [required]="endRequired"
            [requiredText]="endRequiredText"
            [minimumText]="endMinimumText"
            [model]="model.end"
            (model)="change($event, 'end')"
            [showValidationErrorMessages]="endShowValidationErrorMessages"
            type="time"
        >&lt;/generic-input>
    `}),_dec65=(0,_core.Input)(),_dec66=(0,_core.Input)(),_dec67=(0,_core.Input)(),_dec68=(0,_core.Input)(),_dec69=(0,_core.Input)(),_dec70=(0,_core.Input)(),_dec71=(0,_core.Input)(),_dec72=(0,_core.Input)(),_dec73=(0,_core.Input)(),_dec74=(0,_core.Input)(),_dec75=(0,_core.Input)(),_dec76=(0,_core.Input)(),_dec77=(0,_core.Input)(),_dec78=(0,_core.Input)(),_dec79=(0,_core.Input)(),_dec80=(0,_core.Input)(),_dec81=(0,_core.Input)(),_dec82=(0,_core.Input)(),_dec83=(0,_core.Input)(),_dec84=(0,_core.Input)(),_dec85=(0,_core.Input)(),_dec86=(0,_core.Input)(),_dec87=(0,_core.Input)(),_dec88=(0,_core.Output)(),_dec64(_class63=(_class64=class IntervalInputComponent{constructor(){_initDefineProp(this,'endDeclaration',_descriptor24,this);_initDefineProp(this,'startDeclaration',_descriptor25,this);_initDefineProp(this,'endDescription',_descriptor26,this);_initDefineProp(this,'startDescription',_descriptor27,this);_initDefineProp(this,'endDisabled',_descriptor28,this);_initDefineProp(this,'startDisabled',_descriptor29,this);_initDefineProp(this,'endMaximum',_descriptor30,this);_initDefineProp(this,'startMaximum',_descriptor31,this);_initDefineProp(this,'endMaximumText',_descriptor32,this);_initDefineProp(this,'startMaximumText',_descriptor33,this);_initDefineProp(this,'endMinimum',_descriptor34,this);_initDefineProp(this,'startMinimum',_descriptor35,this);_initDefineProp(this,'endMinimumText',_descriptor36,this);_initDefineProp(this,'startMinimumText',_descriptor37,this);_initDefineProp(this,'endRequired',_descriptor38,this);_initDefineProp(this,'startRequired',_descriptor39,this);_initDefineProp(this,'endRequiredText',_descriptor40,this);_initDefineProp(this,'startRequiredText',_descriptor41,this);_initDefineProp(this,'endShowDeclarationText',_descriptor42,this);_initDefineProp(this,'startShowDeclarationText',_descriptor43,this);_initDefineProp(this,'endShowValidationErrorMessages',_descriptor44,this);_initDefineProp(this,'startShowValidationErrorMessages',_descriptor45,this);_initDefineProp(this,'model',_descriptor46,this);_initDefineProp(this,'modelChange',_descriptor47,this)}/**
     * Triggers on any change events of any nested input.
     * @param event - Events payload data.
     * @param type - Indicates which input field has changed.
     * @returns Nothing.
     */change(event,type){this.modelChange.emit({value:event,type})}},(_descriptor24=_applyDecoratedDescriptor(_class64.prototype,'endDeclaration',[_dec65],{enumerable:true,initializer:function(){return null}}),_descriptor25=_applyDecoratedDescriptor(_class64.prototype,'startDeclaration',[_dec66],{enumerable:true,initializer:function(){return null}}),_descriptor26=_applyDecoratedDescriptor(_class64.prototype,'endDescription',[_dec67],{enumerable:true,initializer:function(){return null}}),_descriptor27=_applyDecoratedDescriptor(_class64.prototype,'startDescription',[_dec68],{enumerable:true,initializer:function(){return null}}),_descriptor28=_applyDecoratedDescriptor(_class64.prototype,'endDisabled',[_dec69],{enumerable:true,initializer:function(){return null}}),_descriptor29=_applyDecoratedDescriptor(_class64.prototype,'startDisabled',[_dec70],{enumerable:true,initializer:function(){return null}}),_descriptor30=_applyDecoratedDescriptor(_class64.prototype,'endMaximum',[_dec71],{enumerable:true,initializer:function(){return null}}),_descriptor31=_applyDecoratedDescriptor(_class64.prototype,'startMaximum',[_dec72],{enumerable:true,initializer:function(){return null}}),_descriptor32=_applyDecoratedDescriptor(_class64.prototype,'endMaximumText',[_dec73],{enumerable:true,initializer:function(){return'Please give a number less or equal than ${model.maximum}.'}}),_descriptor33=_applyDecoratedDescriptor(_class64.prototype,'startMaximumText',[_dec74],{enumerable:true,initializer:function(){return'Please give a number less or equal than ${model.maximum}.'}}),_descriptor34=_applyDecoratedDescriptor(_class64.prototype,'endMinimum',[_dec75],{enumerable:true,initializer:function(){return null}}),_descriptor35=_applyDecoratedDescriptor(_class64.prototype,'startMinimum',[_dec76],{enumerable:true,initializer:function(){return null}}),_descriptor36=_applyDecoratedDescriptor(_class64.prototype,'endMinimumText',[_dec77],{enumerable:true,initializer:function(){return'Please given a number at least or equal to {{model.minimum}}.'}}),_descriptor37=_applyDecoratedDescriptor(_class64.prototype,'startMinimumText',[_dec78],{enumerable:true,initializer:function(){return'Please given a number at least or equal to {{model.minimum}}.'}}),_descriptor38=_applyDecoratedDescriptor(_class64.prototype,'endRequired',[_dec79],{enumerable:true,initializer:function(){return null}}),_descriptor39=_applyDecoratedDescriptor(_class64.prototype,'startRequired',[_dec80],{enumerable:true,initializer:function(){return null}}),_descriptor40=_applyDecoratedDescriptor(_class64.prototype,'endRequiredText',[_dec81],{enumerable:true,initializer:function(){return'Please fill this field.'}}),_descriptor41=_applyDecoratedDescriptor(_class64.prototype,'startRequiredText',[_dec82],{enumerable:true,initializer:function(){return'Please fill this field.'}}),_descriptor42=_applyDecoratedDescriptor(_class64.prototype,'endShowDeclarationText',[_dec83],{enumerable:true,initializer:function(){return'\u2139'}}),_descriptor43=_applyDecoratedDescriptor(_class64.prototype,'startShowDeclarationText',[_dec84],{enumerable:true,initializer:function(){return'\u2139'}}),_descriptor44=_applyDecoratedDescriptor(_class64.prototype,'endShowValidationErrorMessages',[_dec85],{enumerable:true,initializer:function(){return false}}),_descriptor45=_applyDecoratedDescriptor(_class64.prototype,'startShowValidationErrorMessages',[_dec86],{enumerable:true,initializer:function(){return false}}),_descriptor46=_applyDecoratedDescriptor(_class64.prototype,'model',[_dec87],{enumerable:true,initializer:function(){return{end:{value:new Date(1970,0,1)},start:{value:new Date(1970,0,1)}}}}),_descriptor47=_applyDecoratedDescriptor(_class64.prototype,'modelChange',[_dec88],{enumerable:true,initializer:function(){return new _core.EventEmitter}})),_class64))||_class63);// IgnoreTypeCheck
/**
 * Represents an editable list of intervals.
 * @property additionalObjectData - Additional object data to save with current
 * interval object.
 * @property contentTemplate - Reference to transcluded node.
 * @property description - Interval description to use as label.
 *
 * @property endDeclaration - End declaration info text.
 * @property startDeclaration - End declaration info text.
 *
 * @property endDescription - Description for end input.
 * @property startDescription - Description for start input.
 *
 * @property endDisabled - Sets end disabled state.
 * @property startDisabled - Sets start disabled state.
 *
 * @property endMaximum - Maximum allowed number end value.
 * @property startMaximum - Maximum allowed number start value.
 *
 * @property endMaximumText - Maximum number validation end text.
 * @property startMaximumText - Maximum number validation start text.
 *
 * @property endMinimum - Minimum allowed end number.
 * @property endMinimum - Minimum allowed start number.
 *
 * @property endMinimumText - Minimum end number validation text.
 * @property startMinimumText - Minimum start number validation text.
 *
 * @property endRequired - Indicates whether end input have to be filled.
 * @property startRequired - Indicates whether start input have to be filled.
 *
 * @property endRequiredText - Required validation end text.
 * @property startRequiredText - Required validation start text.
 *
 * @property endShowDeclarationText - Info text to click for more end input
 * informations.
 * @property startShowDeclarationText - Info text to click for more start input
 * informations.
 *
 * @property endShowDeclarationText - Info text to click for more end input
 * informations.
 * @property startShowDeclarationText - Info text to click for more
 * start input informations.
 *
 * @property endShowValidationErrorMessages - Indicates whether validation
 * errors should be suppressed or be shown automatically for end input.
 * @property startShowValidationErrorMessages - Indicates whether validation
 * errors should be suppressed or be shown automatically for start input.
 *
 * @property model - Saves current list of intervals.
 * @property modelChange - Event emitter for interval list changes.
 *
 * @property _dataScope - Data scope service instance.
 * @property _extendObject - Holds the extend object pipe instance's transform
 * method.
 */let IntervalsInputComponent=exports.IntervalsInputComponent=(_dec89=(0,_core.Component)({animations:[defaultAnimation()],changeDetection:_core.ChangeDetectionStrategy[CHANGE_DETECTION_STRATEGY_NAME],selector:'generic-intervals-input',/* eslint-disable max-len */template:`
        &lt;div
            *ngIf="description !== '' &amp;&amp; (description || model.description || model.name)"
        >{{description || model.description || model.name}}&lt;/div>
        &lt;div
            @defaultAnimation
            *ngFor="let interval of (model.value || []); let first = first; let index = index"
        >
            &lt;generic-interval-input
                [endDisabled]="endDisabled"
                [startDisabled]="startDisabled"

                [endShowDeclarationText]="endShowDeclarationText"
                [startShowDeclarationText]="startShowDeclarationText"

                [endMaximum]="endMaximum"
                [startMaximum]="startMaximum"

                [endMaximumText]="endMaximumText"
                [startMaximumText]="startMaximumText"

                [endMinimum]="endMinimum"
                [startMinimum]="startMinimum"

                [endRequired]="endRequired"
                [startRequired]="startRequired"

                [endRequiredText]="endRequiredText"
                [startRequiredText]="startRequiredText"

                [endMinimumText]="endMinimumText"
                [startMinimumText]="startMinimumText"

                [endDescription]="first ? endDescription : ''"
                [startDescription]="first ? startDescription : ''"

                [model]="interval"
                (model)="change($event, index)"

                [endDeclaration]="endDeclaration"
                [startDeclaration]="startDeclaration"

                [endShowValidationErrorMessages]="endShowValidationErrorMessages"
                [startShowValidationErrorMessages]="startShowValidationErrorMessages"
            >
                &lt;ng-container *ngIf="contentTemplate; else fallback">
                    &lt;ng-container
                        *ngTemplateOutlet="contentTemplate; context: {\$implicit:interval}"
                    >&lt;/ng-container>
                &lt;/ng-container>
            &lt;/generic-interval-input>
            &lt;a
                class="remove"
                (click)="$event.preventDefault(); $event.stopPropagation(); remove(interval)"
                href=""
                *ngIf="model.minimumNumber === null || model.value.length > model.minimumNumber"
            >-&lt;/a>
        &lt;/div>
        &lt;a
            class="add"
            (click)="$event.preventDefault(); $event.stopPropagation(); add()"
            href=""
            *ngIf="model.maximumNumber === null || (model.value?.length || 0) &lt; model.maximumNumber"
        >+&lt;/a>
        &lt;ng-template #fallback>--&lt;/ng-template>
    `/* eslint-enable max-len */}),_dec90=(0,_core.Input)(),_dec91=(0,_core.ContentChild)(_core.TemplateRef),_dec92=(0,_core.Input)(),_dec93=(0,_core.Input)(),_dec94=(0,_core.Input)(),_dec95=(0,_core.Input)(),_dec96=(0,_core.Input)(),_dec97=(0,_core.Input)(),_dec98=(0,_core.Input)(),_dec99=(0,_core.Input)(),_dec100=(0,_core.Input)(),_dec101=(0,_core.Input)(),_dec102=(0,_core.Input)(),_dec103=(0,_core.Input)(),_dec104=(0,_core.Input)(),_dec105=(0,_core.Input)(),_dec106=(0,_core.Input)(),_dec107=(0,_core.Input)(),_dec108=(0,_core.Input)(),_dec109=(0,_core.Input)(),_dec110=(0,_core.Input)(),_dec111=(0,_core.Input)(),_dec112=(0,_core.Input)(),_dec113=(0,_core.Input)(),_dec114=(0,_core.Input)(),_dec115=(0,_core.Input)(),_dec116=(0,_core.Output)(),_dec89(_class66=(_class67=class IntervalsInputComponent{/**
     * Constructs the interval list component.
     * @param dataScope - Data scope service instance.
     * @param extendObjectPipe - Injected extend object pipe instance.
     * @returns Nothing.
     */constructor(dataScope,extendObjectPipe){_initDefineProp(this,'additionalObjectData',_descriptor48,this);_initDefineProp(this,'contentTemplate',_descriptor49,this);_initDefineProp(this,'description',_descriptor50,this);_initDefineProp(this,'endDeclaration',_descriptor51,this);_initDefineProp(this,'startDeclaration',_descriptor52,this);_initDefineProp(this,'endDescription',_descriptor53,this);_initDefineProp(this,'startDescription',_descriptor54,this);_initDefineProp(this,'endDisabled',_descriptor55,this);_initDefineProp(this,'startDisabled',_descriptor56,this);_initDefineProp(this,'endMaximum',_descriptor57,this);_initDefineProp(this,'startMaximum',_descriptor58,this);_initDefineProp(this,'endMaximumText',_descriptor59,this);_initDefineProp(this,'startMaximumText',_descriptor60,this);_initDefineProp(this,'endMinimum',_descriptor61,this);_initDefineProp(this,'startMinimum',_descriptor62,this);_initDefineProp(this,'endMinimumText',_descriptor63,this);_initDefineProp(this,'startMinimumText',_descriptor64,this);_initDefineProp(this,'endRequired',_descriptor65,this);_initDefineProp(this,'startRequired',_descriptor66,this);_initDefineProp(this,'endRequiredText',_descriptor67,this);_initDefineProp(this,'startRequiredText',_descriptor68,this);_initDefineProp(this,'endShowDeclarationText',_descriptor69,this);_initDefineProp(this,'startShowDeclarationText',_descriptor70,this);_initDefineProp(this,'endShowValidationErrorMessages',_descriptor71,this);_initDefineProp(this,'startShowValidationErrorMessages',_descriptor72,this);_initDefineProp(this,'model',_descriptor73,this);_initDefineProp(this,'modelChange',_descriptor74,this);this._dataScope=this._dataScope;this._extendObject=this._extendObject;this._dataScope=dataScope;this._extendObject=extendObjectPipe.transform.bind(extendObjectPipe)}/**
     * Triggers on any change events of any nested input.
     * @param event - Events payload data.
     * @param index - Indicates which input field has changed.
     * @returns Nothing.
     */change(event,index){this.modelChange.emit({value:event,index})}/**
     * Extends additional model data with default one if nothing is provided.
     * @returns Nothing.
     */ngOnInit(){if(!this.additionalObjectData)this.additionalObjectData=this._dataScope.generate('_interval');if(this.model.value)this.model.value.sort((first,second)=>first.start.value-second.start.value);else this.model.value=[]}/**
     * Adds a new interval.
     * @param data - Additional data to use for newly created entity.
     * @returns Nothing.
     */add(data={}){if(!this.model.value)this.model.value=[];const lastEnd=this.model.value.length?new Date(this.model.value[this.model.value.length-1].end.value).getTime():0;this.model.value.push(this._extendObject(true,{},this.additionalObjectData,{// NOTE: We add one hour in milliseconds as default interval.
end:{value:new Date(lastEnd+Math.pow(60,2)*1000)},start:{value:new Date(lastEnd)}},data));this.modelChange.emit(this.model)}/**
     * Removes given interval.
     * @param interval - Interval to remove from current list.
     * @returns Nothing.
     */remove(interval){const index=this.model.value.indexOf(interval);if(index!==-1){this.model.value.splice(index,1);this.modelChange.emit(this.model)}}},(_descriptor48=_applyDecoratedDescriptor(_class67.prototype,'additionalObjectData',[_dec90],{enumerable:true,initializer:function(){return this.additionalObjectData}}),_descriptor49=_applyDecoratedDescriptor(_class67.prototype,'contentTemplate',[_dec91],{enumerable:true,initializer:function(){return this.contentTemplate}}),_descriptor50=_applyDecoratedDescriptor(_class67.prototype,'description',[_dec92],{enumerable:true,initializer:function(){return null}}),_descriptor51=_applyDecoratedDescriptor(_class67.prototype,'endDeclaration',[_dec93],{enumerable:true,initializer:function(){return null}}),_descriptor52=_applyDecoratedDescriptor(_class67.prototype,'startDeclaration',[_dec94],{enumerable:true,initializer:function(){return null}}),_descriptor53=_applyDecoratedDescriptor(_class67.prototype,'endDescription',[_dec95],{enumerable:true,initializer:function(){return null}}),_descriptor54=_applyDecoratedDescriptor(_class67.prototype,'startDescription',[_dec96],{enumerable:true,initializer:function(){return null}}),_descriptor55=_applyDecoratedDescriptor(_class67.prototype,'endDisabled',[_dec97],{enumerable:true,initializer:function(){return null}}),_descriptor56=_applyDecoratedDescriptor(_class67.prototype,'startDisabled',[_dec98],{enumerable:true,initializer:function(){return null}}),_descriptor57=_applyDecoratedDescriptor(_class67.prototype,'endMaximum',[_dec99],{enumerable:true,initializer:function(){return null}}),_descriptor58=_applyDecoratedDescriptor(_class67.prototype,'startMaximum',[_dec100],{enumerable:true,initializer:function(){return null}}),_descriptor59=_applyDecoratedDescriptor(_class67.prototype,'endMaximumText',[_dec101],{enumerable:true,initializer:function(){return'Please give a number less or equal than ${model.maximum}.'}}),_descriptor60=_applyDecoratedDescriptor(_class67.prototype,'startMaximumText',[_dec102],{enumerable:true,initializer:function(){return'Please give a number less or equal than ${model.maximum}.'}}),_descriptor61=_applyDecoratedDescriptor(_class67.prototype,'endMinimum',[_dec103],{enumerable:true,initializer:function(){return null}}),_descriptor62=_applyDecoratedDescriptor(_class67.prototype,'startMinimum',[_dec104],{enumerable:true,initializer:function(){return null}}),_descriptor63=_applyDecoratedDescriptor(_class67.prototype,'endMinimumText',[_dec105],{enumerable:true,initializer:function(){return'Please given a number at least or equal to {{model.minimum}}.'}}),_descriptor64=_applyDecoratedDescriptor(_class67.prototype,'startMinimumText',[_dec106],{enumerable:true,initializer:function(){return'Please given a number at least or equal to {{model.minimum}}.'}}),_descriptor65=_applyDecoratedDescriptor(_class67.prototype,'endRequired',[_dec107],{enumerable:true,initializer:function(){return null}}),_descriptor66=_applyDecoratedDescriptor(_class67.prototype,'startRequired',[_dec108],{enumerable:true,initializer:function(){return null}}),_descriptor67=_applyDecoratedDescriptor(_class67.prototype,'endRequiredText',[_dec109],{enumerable:true,initializer:function(){return'Please fill this field.'}}),_descriptor68=_applyDecoratedDescriptor(_class67.prototype,'startRequiredText',[_dec110],{enumerable:true,initializer:function(){return'Please fill this field.'}}),_descriptor69=_applyDecoratedDescriptor(_class67.prototype,'endShowDeclarationText',[_dec111],{enumerable:true,initializer:function(){return'\u2139'}}),_descriptor70=_applyDecoratedDescriptor(_class67.prototype,'startShowDeclarationText',[_dec112],{enumerable:true,initializer:function(){return'\u2139'}}),_descriptor71=_applyDecoratedDescriptor(_class67.prototype,'endShowValidationErrorMessages',[_dec113],{enumerable:true,initializer:function(){return false}}),_descriptor72=_applyDecoratedDescriptor(_class67.prototype,'startShowValidationErrorMessages',[_dec114],{enumerable:true,initializer:function(){return false}}),_descriptor73=_applyDecoratedDescriptor(_class67.prototype,'model',[_dec115],{enumerable:true,initializer:function(){return{value:[]}}}),_descriptor74=_applyDecoratedDescriptor(_class67.prototype,'modelChange',[_dec116],{enumerable:true,initializer:function(){return new _core.EventEmitter}})),_class67))||_class66);// // / endregion
// // endregion
// // region text/selection
Reflect.defineMetadata('design:paramtypes',[DataScopeService,ExtendObjectPipe],IntervalsInputComponent);/* eslint-disable brace-style *//**
 * Provides a generic code editor.
 * @property static:applicationInterfaceLoad - Promise which resolves when
 * code editor is fully loaded.
 * @property static:modesLoad - Mapping from mode to their loading state.
 *
 * @property blur - Blur event emitter.
 * @property codeMirror - Current code mirror constructor.
 * @property configuration - Code mirror configuration.
 * @property focus - Focus event emitter.
 * @property hostDomNode - Host textarea dom element to bind editor to.
 * @property initialized - Initialized event emitter.
 * @property instance - Currently active code editor instance.
 * @property model - Current editable text string.
 * @property modelChange - Change event emitter.
 */let CodeEditorComponent=exports.CodeEditorComponent=(_dec117=(0,_core.Component)({animations:[defaultAnimation()],changeDetection:_core.ChangeDetectionStrategy[CHANGE_DETECTION_STRATEGY_NAME],providers:[{provide:_forms.NG_VALUE_ACCESSOR,useExisting:(0,_core.forwardRef)(()=>CodeEditorComponent),multi:true}],selector:'code-editor',template:'&lt;textarea #hostDomNode>&lt;/textarea>'}),_dec118=(0,_core.Output)(),_dec119=(0,_core.Input)(),_dec120=(0,_core.Input)(),_dec121=(0,_core.Output)(),_dec122=(0,_core.ViewChild)('hostDomNode'),_dec123=(0,_core.Output)(),_dec124=(0,_core.Input)(),_dec125=(0,_core.Output)(),_dec117(_class69=(_class70=(_temp4=_class71=class CodeEditorComponent extends AbstractValueAccessor/* implements AfterViewInit*/{/**
     * Initializes the code mirror resource loading if not available yet.
     * @param extendObjectPipe - Injected extend object pipe instance.
     * @param injector - Application specific injector to use instead auto
     * detected one.
     * @param tools - Tools service instance.
     * @returns Nothing.
     *//* eslint-enable brace-style */constructor(extendObjectPipe,injector,tools){super(injector);_initDefineProp(this,'blur',_descriptor75,this);this.codeMirror=this.codeMirror;_initDefineProp(this,'configuration',_descriptor76,this);_initDefineProp(this,'disabled',_descriptor77,this);this.extendObject=this.extendObject;_initDefineProp(this,'focus',_descriptor78,this);_initDefineProp(this,'hostDomNode',_descriptor79,this);_initDefineProp(this,'initialized',_descriptor80,this);this.instance=null;_initDefineProp(this,'model',_descriptor81,this);_initDefineProp(this,'modelChange',_descriptor82,this);this.tools=this.tools;this.extendObject=extendObjectPipe.transform.bind(extendObjectPipe);this.tools=tools;if(this.tools.globalContext.CodeMirror)this.codeMirror=this.tools.globalContext.CodeMirror;else if(typeof this.constructor.applicationInterfaceLoad!=='object')this.constructor.applicationInterfaceLoad=Promise.all([new Promise(resolve=>this.tools.$(`&lt;link
                    href="${CODE_MIRROR_DEFAULT_OPTIONS.path.base}`+`${CODE_MIRROR_DEFAULT_OPTIONS.path.cascadingStyleSheet}"
                    rel="stylesheet"
                    type="text/css"
                />`).appendTo('head').on('load',resolve)),new Promise((resolve,reject)=>this.tools.$.ajax({cache:true,dataType:'script',error:reject,success:()=>{this.codeMirror=this.tools.globalContext.CodeMirror;resolve(this.codeMirror)},url:CODE_MIRROR_DEFAULT_OPTIONS.path.base+CODE_MIRROR_DEFAULT_OPTIONS.path.script}))])}/**
     * Initializes the code editor element.
     * @returns Nothing.
     */ngAfterViewInit(){var _this12=this;return _asyncToGenerator(function*(){if(_this12.codeMirror)/*
                NOTE: We have to do a dummy timeout to avoid an event emit in
                first initializing call stack.
            */yield _this12.tools.tools.timeout();else try{yield _this12.constructor.applicationInterfaceLoad}catch(error){throw error}if(_this12.configuration.mode)if(_this12.constructor.modesLoad.hasOwnProperty(_this12.configuration.mode)){if(_this12.constructor.modesLoad[_this12.configuration.mode]!==true)try{yield _this12.constructor.modesLoad[_this12.configuration.mode]}catch(error){throw error}}else{_this12.constructor.modesLoad[_this12.configuration.mode]=new Promise(function(resolve,reject){return _this12.tools.$.ajax({cache:true,dataType:'script',error:reject,success:resolve,url:_this12.configuration.path.base+_this12.configuration.path.mode.replace(/{mode}/g,_this12.configuration.mode)})});try{yield _this12.constructor.modesLoad[_this12.configuration.mode]}catch(error){throw error}}const configuration=_this12.extendObject({},_this12.configuration,{readOnly:_this12.disabled===null?_this12.model.disabled||model.mutable===false||model.writable===false:_this12.disabled});delete configuration.path;_this12.instance=_this12.codeMirror.fromTextArea(_this12.hostDomNode.nativeElement,configuration);_this12.instance.setValue(_this12.model);_this12.instance.on('blur',function(instance,event){return _this12.blur.emit({event,instance})});_this12.instance.on('change',function(){_this12.model=_this12.onChangeCallback(_this12.import(_this12.instance.getValue()));_this12.modelChange.emit(_this12.model)});_this12.instance.on('focus',function(instance,event){return _this12.focus.emit({event,instance})});_this12.initialized.emit(_this12.codeMirror)})()}/**
     * Synchronizes given value into internal code mirror instance.
     * @param value - Given value to set in code editor.
     * @param additionalParameter - Additional arguments will be forwarded to
     * the overridden method invocation.
     * @returns What inherited method returns.
     */export(value,...additionalParameter){this.model=value||'';if(this.instance)this.instance.setValue(this.model);return super.export(value,...additionalParameter)}/**
     * Triggers disabled state changes.
     * @param isDisabled - Indicates disabled state.
     * @returns Nothing.
     */setDisabledState(isDisabled){if(this.instance)this.instance.setOption('readOnly',isDisabled)}},_class71.modesLoad={},_temp4),(_descriptor75=_applyDecoratedDescriptor(_class70.prototype,'blur',[_dec118],{enumerable:true,initializer:function(){return new _core.EventEmitter}}),_descriptor76=_applyDecoratedDescriptor(_class70.prototype,'configuration',[_dec119],{enumerable:true,initializer:function(){return{}}}),_descriptor77=_applyDecoratedDescriptor(_class70.prototype,'disabled',[_dec120],{enumerable:true,initializer:function(){return null}}),_descriptor78=_applyDecoratedDescriptor(_class70.prototype,'focus',[_dec121],{enumerable:true,initializer:function(){return new _core.EventEmitter}}),_descriptor79=_applyDecoratedDescriptor(_class70.prototype,'hostDomNode',[_dec122],{enumerable:true,initializer:function(){return this.hostDomNode}}),_descriptor80=_applyDecoratedDescriptor(_class70.prototype,'initialized',[_dec123],{enumerable:true,initializer:function(){return new _core.EventEmitter}}),_descriptor81=_applyDecoratedDescriptor(_class70.prototype,'model',[_dec124],{enumerable:true,initializer:function(){return''}}),_descriptor82=_applyDecoratedDescriptor(_class70.prototype,'modelChange',[_dec125],{enumerable:true,initializer:function(){return new _core.EventEmitter}})),_class70))||_class69);/* eslint-disable max-len */(0,_core.Optional)()(CodeEditorComponent,null,1);Reflect.defineMetadata('design:paramtypes',[ExtendObjectPipe,_core.Injector,ToolsService],CodeEditorComponent);const propertyContent={editor:`
        (blur)="focused = false"
        @defaultAnimation
        (focus)="focused = true"
        [ngModel]="model.value"
        (ngModelChange)="model.value = onChange($event, state); modelChange.emit(model)"
        [style.visibilty]="initialized ? 'visible' : 'hidden'"
        #state="ngModel"
    `,nativ:`
        [name]="model.name"
        [ngModel]="model.value"
        (ngModelChange)="model.value = onChange($event, state); modelChange.emit(model)"
        [placeholder]="description === '' ? null : description ? description : (model.description || model.name)"
        [required]="required === null ? !model.nullable : required"
        #state="ngModel"
    `,nativText:`
        [disabled]="disabled === null ? (model.disabled || model.mutable === false || model.writable === false) : disabled"
        [maxlength]="maximumLength === null ? (model.type === 'string' ? model.maximumLength : null) : maximumLength"
        [minlength]="minimumLength === null ? (model.type === 'string' ? model.minimumLength : null) : minimumLength"
        [pattern]="pattern === null ? (model.type === 'string' ? model.regularExpressionPattern : null) : pattern"
    `,wrapper:`
        [declaration]="declaration"
        [description]="description"
        [disabled]="disabled"
        [showDeclarationText]="showDeclarationText"
        [maximum]="maximum"
        [maximumLength]="maximumLength"
        [maximumLengthText]="maximumLengthText"
        [maximumText]="maximumText"
        [minimum]="minimum"
        [minimumLength]="minimumLength"
        [minimumLengthText]="minimumLengthText"
        [minimumText]="minimumText"
        [model]="model"
        [pattern]="pattern"
        [required]="required"
        [requiredText]="requiredText"
        [patternText]="patternText"
        [showValidationErrorMessages]="showValidationErrorMessages"
        [type]="type"
    `};const inputContent=`
    &lt;mat-hint align="start" @defaultAnimation matTooltip="info">
        &lt;span
            [class.active]="showDeclaration"
            (click)="showDeclaration = !showDeclaration"
            *ngIf="declaration || model.declaration"
        >
            &lt;a
                (click)="$event.preventDefault()"
                @defaultAnimation
                href=""
                *ngIf="showDeclarationText"
            >{{showDeclarationText}}&lt;/a>
            &lt;span @defaultAnimation *ngIf="showDeclaration">
                {{declaration || model.declaration}}
            &lt;/span>
        &lt;/span>
        &lt;span *ngIf="editor &amp;&amp; selectableEditor &amp;&amp; !model.disabled">
            &lt;span *ngIf="declaration || model.declaration">|&lt;/span>
            &lt;a
                [class.active]="activeEditor"
                (click)="$event.preventDefault(); $event.stopPropagation(); activeEditor = true"
                href=""
            >editor&lt;/a>
            &lt;span>|&lt;/span>
            &lt;a
                [class.active]="!activeEditor"
                (click)="$event.preventDefault(); $event.stopPropagation(); activeEditor = false"
                href=""
            >plain&lt;/a>
        &lt;/span>
    &lt;/mat-hint>
    &lt;span generic-error *ngIf="showValidationErrorMessages">
        &lt;p @defaultAnimation *ngIf="model.state?.errors?.maxlength">
            {{maximumLengthText | genericStringTemplate:model}}
        &lt;/p>
        &lt;p @defaultAnimation *ngIf="model.state?.errors?.max">
            {{maximumText | genericStringTemplate:model}}
        &lt;/p>
        &lt;p @defaultAnimation *ngIf="model.state?.errors?.minlength">
            {{minimumLengthText | genericStringTemplate:model}}
        &lt;/p>
        &lt;p @defaultAnimation *ngIf="model.state?.errors?.min">
            {{minimumText | genericStringTemplate:model}}
        &lt;/p>
        &lt;p @defaultAnimation *ngIf="model.state?.errors?.pattern">
            {{patternText | genericStringTemplate:model}}
        &lt;/p>
        &lt;p @defaultAnimation *ngIf="model.state?.errors?.required">
            {{requiredText | genericStringTemplate:model}}
        &lt;/p>
    &lt;/span>
    &lt;mat-hint
        align="end"
        @defaultAnimation
        *ngIf="!model.selection &amp;&amp; model.type === 'string' &amp;&amp; model.maximumLength !== null &amp;&amp; model.maximumLength &lt; 100"
    >{{model.value?.length}} / {{model.maximumLength}}&lt;/mat-hint>
`;/* eslint-enable max-len */// IgnoreTypeCheck
/**
 * A generic form input, selection or textarea component with validation,
 * labeling and info description support.
 * @property activeEditor - Indicates whether current editor is active.
 * @property editor - Editor to choose from for an activated editor.
 * @property labels - Defines some selectable value labels.
 * @property maximumNumberOfRows - Maximum resizeable number of rows.
 * @property minimumNumberOfRows - Minimum resizeable number of rows.
 * @property rows - Number of rows to show.
 * @property selectableEditor - Indicates whether an editor is selectable.
 * @property type - Optionally defines an input type explicitly.
 */let InputComponent=exports.InputComponent=(_dec126=(0,_core.Component)({animations:[defaultAnimation()],changeDetection:_core.ChangeDetectionStrategy[CHANGE_DETECTION_STRATEGY_NAME],selector:'generic-input',template:`
        &lt;generic-textarea
            ${propertyContent.wrapper}
            [activeEditor]="activeEditor"
            [editor]="editor"
            [maximumNumberOfRows]="maximumNumberOfRows"
            [minimumNumberOfRows]="minimumNumberOfRows"
            *ngIf="editor || model.editor; else simpleInput"
            [rows]="rows"
            [selectableEditor]="selectableEditor"
        >&lt;ng-content>&lt;/ng-content>&lt;/generic-textarea>
        &lt;ng-template #simpleInput>&lt;generic-simple-input
            ${propertyContent.wrapper}
            [labels]="labels"
        >&lt;ng-content>&lt;/ng-content>&lt;/generic-simple-input>&lt;/ng-template>
    `}),_dec127=(0,_core.Input)(),_dec128=(0,_core.Input)(),_dec129=(0,_core.Input)(),_dec130=(0,_core.Input)(),_dec131=(0,_core.Input)(),_dec132=(0,_core.Input)(),_dec133=(0,_core.Input)(),_dec134=(0,_core.Input)(),_dec126(_class72=(_class73=class InputComponent extends AbstractInputComponent{/**
     * Delegates injected injector service instance to the super constructor.
     * @param injector - Injected injector service instance.
     * @returns Nothing.
     */constructor(injector){super(injector);_initDefineProp(this,'activeEditor',_descriptor83,this);_initDefineProp(this,'editor',_descriptor84,this);_initDefineProp(this,'labels',_descriptor85,this);_initDefineProp(this,'maximumNumberOfRows',_descriptor86,this);_initDefineProp(this,'minimumNumberOfRows',_descriptor87,this);_initDefineProp(this,'rows',_descriptor88,this);_initDefineProp(this,'selectableEditor',_descriptor89,this);_initDefineProp(this,'type',_descriptor90,this)}},(_descriptor83=_applyDecoratedDescriptor(_class73.prototype,'activeEditor',[_dec127],{enumerable:true,initializer:function(){return null}}),_descriptor84=_applyDecoratedDescriptor(_class73.prototype,'editor',[_dec128],{enumerable:true,initializer:function(){return null}}),_descriptor85=_applyDecoratedDescriptor(_class73.prototype,'labels',[_dec129],{enumerable:true,initializer:function(){return{}}}),_descriptor86=_applyDecoratedDescriptor(_class73.prototype,'maximumNumberOfRows',[_dec130],{enumerable:true,initializer:function(){return this.maximumNumberOfRows}}),_descriptor87=_applyDecoratedDescriptor(_class73.prototype,'minimumNumberOfRows',[_dec131],{enumerable:true,initializer:function(){return this.minimumNumberOfRows}}),_descriptor88=_applyDecoratedDescriptor(_class73.prototype,'rows',[_dec132],{enumerable:true,initializer:function(){return this.rows}}),_descriptor89=_applyDecoratedDescriptor(_class73.prototype,'selectableEditor',[_dec133],{enumerable:true,initializer:function(){return null}}),_descriptor90=_applyDecoratedDescriptor(_class73.prototype,'type',[_dec134],{enumerable:true,initializer:function(){return this.type}})),_class73))||_class72);/* eslint-disable max-len */// IgnoreTypeCheck
Reflect.defineMetadata('design:paramtypes',[_core.Injector],InputComponent);/* eslint-enable max-len *//**
 * A generic form input or select component with validation, labeling and info
 * description support.
 * @property labels - Defines some selectable value labels.
 * @property type - Optionally defines an input type explicitly.
 */let SimpleInputComponent=exports.SimpleInputComponent=(_dec135=(0,_core.Component)({animations:[defaultAnimation()],changeDetection:_core.ChangeDetectionStrategy[CHANGE_DETECTION_STRATEGY_NAME],selector:'generic-simple-input',template:`
        &lt;ng-container
            @defaultAnimation *ngIf="model.selection; else textInput"
        >
            &lt;mat-form-field>
                &lt;mat-select [(ngModel)]="model.value" ${propertyContent.nativ}>
                    &lt;mat-option
                        *ngFor="let value of model.selection" [value]="value"
                    >
                        {{labels.hasOwnProperty(value) ? labels[value] : value}}
                    &lt;/mat-option>
                &lt;/mat-select>
                ${inputContent}
                &lt;ng-content>&lt;/ng-content>
            &lt;/mat-form-field>
        &lt;/ng-container>
        &lt;ng-template #textInput>&lt;mat-form-field>
            &lt;input
                ${propertyContent.nativ}
                ${propertyContent.nativText}
                [max]="maximum === null ? (model.type === 'number' ? model.maximum : null) : maximum"
                matInput
                [min]="minimum === null ? (model.type === 'number' ? model.minimum : null) : minimum"
                [type]="type ? type : model.name.startsWith('password') ? 'password' : model.type === 'string' ? 'text' : 'number'"
            />
            ${inputContent}
            &lt;ng-content>&lt;/ng-content>
        &lt;/mat-form-field>&lt;/ng-template>
    `}),_dec136=(0,_core.Input)(),_dec137=(0,_core.Input)(),_dec135(_class75=(_class76=class SimpleInputComponent extends AbstractNativeInputComponent{/**
     * Delegates injected injector service instance to the super constructor.
     * @param injector - Injected injector service instance.
     * @returns Nothing.
     */constructor(injector){super(injector);_initDefineProp(this,'labels',_descriptor91,this);_initDefineProp(this,'type',_descriptor92,this)}},(_descriptor91=_applyDecoratedDescriptor(_class76.prototype,'labels',[_dec136],{enumerable:true,initializer:function(){return{}}}),_descriptor92=_applyDecoratedDescriptor(_class76.prototype,'type',[_dec137],{enumerable:true,initializer:function(){return this.type}})),_class76))||_class75);/* eslint-disable max-len */// IgnoreTypeCheck
Reflect.defineMetadata('design:paramtypes',[_core.Injector],SimpleInputComponent);/* eslint-enable max-len *//* eslint-disable brace-style *//**
 * A generic form textarea component with validation, labeling and info
 * description support.
 * @property static:defaultEditorOptions - Globale default editor options.
 *
 * @property activeEditor - Indicated weather current editor is active or not.
 * @property editor - Editor options to choose from for an activated editor.
 * @property editorType - Editor type description.
 * @property maximumNumberOfRows - Maximum resizeable number of rows.
 * @property minimumNumberOfRows - Minimum resizeable number of rows.
 * @property rows - Number of rows to show.
 * @property selectableEditor - Indicates whether an editor is selectable.
 */let TextareaComponent=exports.TextareaComponent=(_dec138=(0,_core.Component)({animations:[defaultAnimation()],changeDetection:_core.ChangeDetectionStrategy[CHANGE_DETECTION_STRATEGY_NAME],selector:'generic-textarea',template:`
        &lt;ng-container *ngIf="activeEditor; else plain">
            &lt;span [class.focused]="focused" class="editor-label">
                {{
                    description === '' ? null : description ? description : (
                        model.description || model.name
                    )
                }}
            &lt;/span>
            &lt;code-editor
                ${propertyContent.editor}
                [configuration]="editor"
                [disabled]="disabled === null ? (model.disabled || model.mutable === false || model.writable === false) : disabled"
                (initialized)="initialized = true"
                *ngIf="editorType === 'code' || editor.indentUnit; else tinyMCE"
            >&lt;/code-editor>
            &lt;ng-template #tinyMCE>&lt;angular-tinymce
                ${propertyContent.editor}
                (init)="initialized = true"
                [settings]="editor"
            >&lt;/angular-tinymce>&lt;/ng-template>
            ${inputContent}
            &lt;ng-content>&lt;/ng-content>
        &lt;/ng-container>
        &lt;ng-template #plain>&lt;mat-form-field @defaultAnimation>
            &lt;textarea
                ${propertyContent.nativ}
                ${propertyContent.nativText}
                [matAutosizeMaxRows]="maximumNumberOfRows"
                [matAutosizeMinRows]="minimumNumberOfRows"
                matInput
                matTextareaAutosize
                [rows]="rows"
            >&lt;/textarea>
            ${inputContent}
            &lt;ng-content>&lt;/ng-content>
        &lt;/mat-form-field>&lt;/ng-template>
    `}),_dec139=(0,_core.Input)(),_dec140=(0,_core.Input)(),_dec141=(0,_core.Input)(),_dec142=(0,_core.Input)(),_dec143=(0,_core.Input)(),_dec144=(0,_core.Input)(),_dec138(_class78=(_class79=(_temp5=_class80=class TextareaComponent extends AbstractNativeInputComponent/* implements OnInit*/{/**
     * Forwards injected service instances to the abstract input component's
     * constructor.
     * @param initialData - Injected initial data service instance.
     * @param injector - Application specific injector to use instead auto
     * detected one.
     * @returns Nothing.
     *//* eslint-enable brace-style */constructor(initialData,injector){super(injector);_initDefineProp(this,'activeEditor',_descriptor93,this);_initDefineProp(this,'editor',_descriptor94,this);this.editorType='custom';_initDefineProp(this,'maximumNumberOfRows',_descriptor95,this);_initDefineProp(this,'minimumNumberOfRows',_descriptor96,this);_initDefineProp(this,'rows',_descriptor97,this);_initDefineProp(this,'selectableEditor',_descriptor98,this);if(initialData.configuration.hasOwnProperty('defaultEditorOptions')&amp;&amp;typeof initialData.configuration.defaultEditorOptions==='object'&amp;&amp;initialData.configuration.defaultEditorOptions!==null)this.constructor.defaultEditorOptions=initialData.configuration.defaultEditorOptions}/**
     * Triggers after input values have been resolved.
     * @param additionalParameter - Additional arguments will be forwarded to
     * the overridden method invocation.
     * @returns Nothing.
     */ngOnInit(...additionalParameter){super.ngOnInit(...additionalParameter);if(this.editor===null&amp;&amp;this.model.editor)this.editor=this.model.editor;if(typeof this.editor==='string'){if(this.editor.startsWith('!')){this.editor=this.editor.substring(1);if(this.selectableEditor===null)this.selectableEditor=false}if(this.editor.startsWith('(')&amp;&amp;this.editor.endsWith(')'))this.editor=this.editor.substring(1,this.editor.length-1);else if(this.activeEditor===null)this.activeEditor=true;this.editorType=this.editor;if(this.editor.startsWith('code')){if(this.editor.startsWith('code:'))this.editor={mode:this.editor.substring('code:'.length)};else this.editor={};}else if(this.editor==='raw')this.editor={/* eslint-disable max-len */toolbar1:'cut copy paste | undo redo removeformat | code | fullscreen',/* eslint-enable max-len */toolbar2:false};else if(this.editor==='simple')this.editor={/* eslint-disable max-len */toolbar1:'cut copy paste | undo redo removeformat | bold italic underline strikethrough subscript superscript | fullscreen',toolbar2:false/* eslint-enable max-len */};else if(this.editor==='normal')this.editor={/* eslint-disable max-len */toolbar1:'cut copy paste | undo redo removeformat | styleselect formatselect | searchreplace visualblocks fullscreen code'/* eslint-enable max-len */};else// Advanced editor.
this.editor={}}else if(this.editor===null&amp;&amp;this.activeEditor)this.editor={};if(this.activeEditor===null)this.activeEditor=false;if(this.selectableEditor===null)if(typeof this.model.selectableEditor==='boolean')this.selectableEditor=this.model.selectableEditor;else this.selectableEditor=true;if(typeof this.editor==='object'&amp;&amp;this.editor!==null){if(this.editorType.startsWith('code')||this.editor.indentUnit)this.editor=this._extendObject(true,{},CODE_MIRROR_DEFAULT_OPTIONS,this.constructor.defaultEditorOptions.code,this.editor);else this.editor=this._extendObject(true,{},TINY_MCE_DEFAULT_OPTIONS,this.constructor.defaultEditorOptions.markup,this.editor);}else this.selectableEditor=false}},_class80.defaultEditorOptions={code:{},markup:{}},_temp5),(_descriptor93=_applyDecoratedDescriptor(_class79.prototype,'activeEditor',[_dec139],{enumerable:true,initializer:function(){return null}}),_descriptor94=_applyDecoratedDescriptor(_class79.prototype,'editor',[_dec140],{enumerable:true,initializer:function(){return null}}),_descriptor95=_applyDecoratedDescriptor(_class79.prototype,'maximumNumberOfRows',[_dec141],{enumerable:true,initializer:function(){return this.maximumNumberOfRows}}),_descriptor96=_applyDecoratedDescriptor(_class79.prototype,'minimumNumberOfRows',[_dec142],{enumerable:true,initializer:function(){return this.minimumNumberOfRows}}),_descriptor97=_applyDecoratedDescriptor(_class79.prototype,'rows',[_dec143],{enumerable:true,initializer:function(){return this.rows}}),_descriptor98=_applyDecoratedDescriptor(_class79.prototype,'selectableEditor',[_dec144],{enumerable:true,initializer:function(){return null}})),_class79))||_class78);// // endregion
// / region file input
/* eslint-disable max-len */// IgnoreTypeCheck
Reflect.defineMetadata('design:paramtypes',[InitialDataService,_core.Injector],TextareaComponent);/* eslint-enable max-len *//**
 * A file type independent file uploader with file content preview (if
 * supported).
 * @property static:imageMimeTypeRegularExpression - Regular expression which
 * should match to each known image mime type.
 * @property static:textMimeTypeRegularExpression - Regular expression which
 * should match to each known text mime type.
 * @property static:videoMimeTypeRegularExpression - Regular expression which
 * should match to each known video mime type.
 *
 * @property attachmentTypeName - Current attachment type name.
 * @property change - File change event emitter.
 * @property configuration - Configuration object.
 * @property delete - Event emitter which triggers its handler when current
 * file should be removed.
 * @property deleteButtonText - Text for button to trigger file removing.
 * @property deletedName - Holds the deleted model field name.
 * @property downloadButtonText - Text for button to download current file.
 * @property editableName - Indicates whether file name could be edited.
 * @property file - Holds the current selected file object if present.
 * @property headerText - Header text to show instead of property description
 * or name.
 * @property idName - Name if id field.
 * @property input - Virtual file input dom node.
 * @property internalName - Technical regular expression style file type.
 * @property keyCode - Mapping from key code to their description.
 * @property mapNameToField - Indicates whether current file name should be
 * mapped to a specific model property.
 * @property maximumSizeText - Maximum file size validation text.
 * @property minimumSizeText - Minimum file size validation text.
 * @property model - File property specification.
 * @property modelChange - Event emitter triggering when model changes happen.
 * @property name - Name or prefix of currently active file.
 * @property namePatternText - Name pattern validation text.
 * @property newButtonText - Text for button to trigger new file upload.
 * @property noFileText - Text to show if now file is selected.
 * @property noPreviewText - Text to show if no preview is available.
 * @property requiredText - Required file selection validation text.
 * @property revision - Revision of given model to show.
 * @property revisionName - Name if revision field.
 * @property showDeclarationText - Info text to click for more informations.
 * @property showValidationErrorMessages - Indicates whether validation errors
 * should be displayed. Useful to hide error messages until user tries to
 * submit a form.
 * @property synchronizeImmediately - Indicates whether file upload should be
 * done immediately after a file was selected (or synchronously with other
 * model data).
 * @property typeName - Name of type field.
 * @property typePatternText - File type validation text.
 *
 * @property _data - Holds the data service instance.
 * @property _domSanitizer - Holds the dom sanitizer service instance.
 * @property _extendObject - Holds the extend object pipe instance's transform
 * method.
 * @property _getFilenameByPrefix - Holds the file name by prefix getter pipe
 * instance's transform method.
 * @property _idIsObject - Indicates whether the model document specific id is
 * provided as object and "value" named property or directly.
 * @property _representObject - Holds the represent object pipe instance's
 * transform method.
 * @property _stringFormat - Saves the string formatting pip's transformation
 * function.
 * @property _prefixMatch - Holds the prefix match pipe instance's transform
 * method.
 */let FileInputComponent/* implements AfterViewInit, OnChanges */=exports.FileInputComponent=(_dec145=(0,_core.Component)({animations:[defaultAnimation()],changeDetection:_core.ChangeDetectionStrategy[CHANGE_DETECTION_STRATEGY_NAME],selector:'generic-file-input',template:`
        &lt;mat-card>
            &lt;mat-card-header
                @defaultAnimation
                *ngIf="headerText !== '' &amp;&amp; (headerText || file?.name || model[attachmentTypeName][internalName]?.declaration || headerText || file?.name || name || model[attachmentTypeName][internalName]?.description || name)"
            >
                &lt;mat-card-title>
                    &lt;span
                        @defaultAnimation
                        *ngIf="!editableName || revision || headerText || !file?.name; else editable"
                    >
                        {{
                            headerText ||
                            file?.name ||
                            model[attachmentTypeName][
                                internalName
                            ]?.description ||
                            name
                        }}
                    &lt;/span>
                    &lt;ng-template #editable>
                        &lt;ng-container *ngIf="synchronizeImmediately; else parent">
                            &lt;mat-form-field
                                [class.dirty]="editedName &amp;&amp; editedName !== file.name"
                                matTooltip="Focus to edit."
                            >
                                &lt;input
                                    matInput
                                    [ngModel]="editedName || file.name"
                                    (ngModelChange)="editedName = $event"
                                />
                                &lt;mat-hint
                                    [class.active]="showDeclaration"
                                    (click)="showDeclaration = !showDeclaration"
                                    @defaultAnimation
                                    matTooltip="info"
                                    *ngIf="model[attachmentTypeName][internalName]?.declaration"
                                >
                                    &lt;a
                                        (click)="$event.preventDefault()"
                                        @defaultAnimation
                                        href=""
                                        *ngIf="showDeclarationText"
                                    >{{showDeclarationText}}&lt;/a>
                                    &lt;span
                                        @defaultAnimation
                                        *ngIf="showDeclaration"
                                    >
                                        {{
                                            model[attachmentTypeName][
                                                internalName
                                            ].declaration
                                        }}
                                    &lt;/span>
                                &lt;/mat-hint>
                            &lt;/mat-form-field>
                            &lt;ng-container
                                *ngIf="editedName &amp;&amp; editedName !== file.name"
                            >
                                &lt;a
                                    (click)="$event.preventDefault();rename(editedName)"
                                    @defaultAnimation
                                    href=""
                                >{{saveNameText}}&lt;/a>
                                &lt;a
                                    (click)="$event.preventDefault();editedName = file.name"
                                    @defaultAnimation
                                    href=""
                                >{{resetNameText}}&lt;/a>
                            &lt;/ng-container>
                        &lt;/ng-container>
                        &lt;ng-template #parent>&lt;mat-form-field
                            [class.dirty]="file.initialName !== file.name"
                            @defaultAnimation
                            matTooltip="Focus to edit."
                            *ngIf="!synchronizeImmediately"
                        >
                            &lt;input
                                matInput [ngModel]="file.name"
                                (ngModelChange)="file.name = $event;modelChange.emit(this.model); fileChange.emit(file)"
                            />
                            &lt;mat-hint
                                [class.active]="showDeclaration"
                                (click)="showDeclaration = !showDeclaration"
                                @defaultAnimation
                                matTooltip="info"
                                *ngIf="model[attachmentTypeName][internalName]?.declaration"
                            >
                                &lt;a
                                    (click)="$event.preventDefault()"
                                    @defaultAnimation
                                    href=""
                                    *ngIf="showDeclarationText"
                                >{{showDeclarationText}}&lt;/a>
                                &lt;span
                                    @defaultAnimation
                                    *ngIf="showDeclaration"
                                >
                                    {{
                                        model[attachmentTypeName][
                                            internalName
                                        ].declaration
                                    }}
                                &lt;/span>
                            &lt;/mat-hint>
                        &lt;/mat-form-field>&lt;/ng-template>
                    &lt;/ng-template>
                &lt;/mat-card-title>
            &lt;/mat-card-header>
            &lt;img mat-card-image
                [attr.alt]="name"
                [attr.src]="file.source"
                @defaultAnimation
                *ngIf="file?.type === 'image' &amp;&amp; file?.source"
            >
            &lt;video
                autoplay
                @defaultAnimation
                mat-card-image
                muted
                *ngIf="file?.type === 'video' &amp;&amp; file?.source"
                loop
            >
                &lt;source [attr.src]="file.source" [type]="file.content_type">
                No preview possible.
            &lt;/video>
            &lt;iframe
                @defaultAnimation
                *ngIf="file?.type === 'text' &amp;&amp; file?.source"
                [src]="file.source"
                style="border: none; width: 100%; max-height: 150px"
            >&lt;/iframe>
            &lt;div
                @defaultAnimation
                mat-card-image
                *ngIf="(!file?.type &amp;&amp; (file?.source || (file?.source | genericType) === 'string') ? noPreviewText : noFileText) as text"
            >&lt;p>{{text}}&lt;/p>&lt;/div>
            &lt;mat-card-content>
                &lt;ng-content>&lt;/ng-content>
                &lt;div
                    @defaultAnimation
                    generic-error
                    *ngIf="showValidationErrorMessages &amp;&amp; model[attachmentTypeName][internalName]?.state?.errors"
                >
                    &lt;p
                        @defaultAnimation
                        *ngIf="model[attachmentTypeName][internalName].state.errors.required"
                    >
                        {{
                            requiredText | genericStringTemplate:{
                                attachmentTypeName: attachmentTypeName,
                                file: file,
                                internalName: internalName,
                                model: model[attachmentTypeName][internalName]
                            }
                        }}
                    &lt;/p>
                    &lt;p
                        @defaultAnimation
                        *ngIf="model[attachmentTypeName][internalName].state.errors.name"
                    >
                        {{
                            namePatternText | genericStringTemplate:{
                                attachmentTypeName: attachmentTypeName,
                                file: file,
                                internalName: internalName,
                                model: model[attachmentTypeName][internalName]
                            }
                        }}
                    &lt;/p>
                    &lt;p
                        @defaultAnimation
                        *ngIf="model[attachmentTypeName][internalName].state.errors.contentType"
                    >
                        {{
                            typePatternText | genericStringTemplate:{
                                attachmentTypeName: attachmentTypeName,
                                file: file,
                                internalName: internalName,
                                model: model[attachmentTypeName][internalName]
                            }
                        }}
                    &lt;/p>
                    &lt;p
                        @defaultAnimation
                        *ngIf="model[attachmentTypeName][internalName].state.errors.minimumSize"
                    >
                        {{
                            minimumSizeText | genericStringTemplate:{
                                attachmentTypeName: attachmentTypeName,
                                file: file,
                                internalName: internalName,
                                model: model[attachmentTypeName][internalName]
                            }
                        }}
                    &lt;/p>
                    &lt;p
                        @defaultAnimation
                        *ngIf="model[attachmentTypeName][internalName].state.errors.maximumSize"
                    >
                        {{
                            maximumSizeText | genericStringTemplate:{
                                attachmentTypeName: attachmentTypeName,
                                file: file,
                                internalName: internalName,
                                model: model[attachmentTypeName][internalName]
                            }
                        }}
                    &lt;/p>
                    &lt;p
                        @defaultAnimation
                        *ngIf="model[attachmentTypeName][internalName].state.errors.database"
                    >
                        {{
                            model[attachmentTypeName][
                                internalName
                            ].state.errors.database
                        }}
                    &lt;/p>
                &lt;/div>
            &lt;/mat-card-content>
            &lt;mat-card-actions>
                &lt;input #input style="display: none" type="file" />
                &lt;button
                    @defaultAnimation
                    (click)="input.click()"
                    mat-raised-button
                    *ngIf="newButtonText"
                >{{newButtonText}}&lt;/button>
                &lt;button
                    (click)="remove()"
                    @defaultAnimation
                    mat-raised-button
                    *ngIf="deleteButtonText &amp;&amp; file"
                >{{deleteButtonText}}&lt;/button>
                &lt;button mat-raised-button
                    @defaultAnimation
                    *ngIf="downloadButtonText &amp;&amp; file"
                >&lt;a [download]="file.name" [href]="file.source">
                    {{downloadButtonText}}
                &lt;/a>&lt;/button>
            &lt;/mat-card-actions>
        &lt;/mat-card>
    `}),_dec146=(0,_core.Output)(),_dec147=(0,_core.Input)(),_dec148=(0,_core.Input)(),_dec149=(0,_core.Input)(),_dec150=(0,_core.Output)(),_dec151=(0,_core.Input)(),_dec152=(0,_core.ViewChild)('input'),_dec153=(0,_core.Input)(),_dec154=(0,_core.Input)(),_dec155=(0,_core.Input)(),_dec156=(0,_core.Input)(),_dec157=(0,_core.Input)(),_dec158=(0,_core.Input)(),_dec159=(0,_core.Input)(),_dec160=(0,_core.Output)(),_dec161=(0,_core.Input)(),_dec162=(0,_core.Input)(),_dec163=(0,_core.Input)(),_dec164=(0,_core.Input)(),_dec165=(0,_core.Input)(),_dec166=(0,_core.Input)(),_dec167=(0,_core.Input)(),_dec168=(0,_core.Input)(),_dec169=(0,_core.Input)(),_dec170=(0,_core.Input)(),_dec145(_class81=(_class82=(_temp6=_class83=class FileInputComponent{/**
     * Sets needed services as property values.
     * @param data - Injected data service instance.
     * @param domSanitizer - Injected dom sanitizer service instance.
     * @param extendObjectPipe - Injected extend object pipe instance.
     * @param getFilenameByPrefixPipe - Saves the file name by prefix retriever
     * pipe instance.
     * @param initialData - Injected initial data service instance.
     * @param representObjectPipe - Saves the object to string representation
     * pipe instance.
     * @param stringFormatPipe - Saves the string formation pipe instance.
     * @param tools - Tools service instance.
     * @returns Nothing.
     */constructor(data,domSanitizer,extendObjectPipe,getFilenameByPrefixPipe,initialData,representObjectPipe,stringFormatPipe,tools){this.attachmentTypeName=this.attachmentTypeName;this.configuration=this.configuration;_initDefineProp(this,'delete',_descriptor99,this);_initDefineProp(this,'deleteButtonText',_descriptor100,this);this.deletedName=this.deletedName;_initDefineProp(this,'downloadButtonText',_descriptor101,this);_initDefineProp(this,'editableName',_descriptor102,this);this.file=null;_initDefineProp(this,'fileChange',_descriptor103,this);_initDefineProp(this,'headerText',_descriptor104,this);this.idName=this.idName;_initDefineProp(this,'input',_descriptor105,this);_initDefineProp(this,'resetNameText',_descriptor106,this);_initDefineProp(this,'saveNameText',_descriptor107,this);_initDefineProp(this,'showDeclarationText',_descriptor108,this);this.typeName=this.typeName;this.internalName=this.internalName;this.keyCode=this.keyCode;_initDefineProp(this,'mapNameToField',_descriptor109,this);_initDefineProp(this,'maximumSizeText',_descriptor110,this);_initDefineProp(this,'minimumSizeText',_descriptor111,this);_initDefineProp(this,'model',_descriptor112,this);_initDefineProp(this,'modelChange',_descriptor113,this);_initDefineProp(this,'name',_descriptor114,this);_initDefineProp(this,'namePatternText',_descriptor115,this);_initDefineProp(this,'newButtonText',_descriptor116,this);_initDefineProp(this,'noFileText',_descriptor117,this);_initDefineProp(this,'noPreviewText',_descriptor118,this);_initDefineProp(this,'requiredText',_descriptor119,this);_initDefineProp(this,'revision',_descriptor120,this);this.revisionName=this.revisionName;_initDefineProp(this,'showValidationErrorMessages',_descriptor121,this);_initDefineProp(this,'synchronizeImmediately',_descriptor122,this);_initDefineProp(this,'typePatternText',_descriptor123,this);this._data=this._data;this._domSanitizer=this._domSanitizer;this._extendObject=this._extendObject;this._getFilenameByPrefix=this._getFilenameByPrefix;this._idIsObject=false;this._representObject=this._representObject;this._stringFormat=this._stringFormat;this._prefixMatch=false;this.configuration=initialData.configuration;this.attachmentTypeName=this.configuration.database.model.property.name.special.attachment;this.keyCode=tools.tools.keyCode;this.deletedName=this.configuration.database.model.property.name.special.deleted;this.idName=this.configuration.database.model.property.name.special.id;this.model={[this.attachmentTypeName]:{},id:null};this.revisionName=this.configuration.database.model.property.name.special.revision;this.typeName=this.configuration.database.model.property.name.special.type;this._data=data;this._domSanitizer=domSanitizer;this._extendObject=extendObjectPipe.transform.bind(extendObjectPipe);this._getFilenameByPrefix=getFilenameByPrefixPipe.transform.bind(getFilenameByPrefixPipe);this._representObject=representObjectPipe.transform.bind(representObjectPipe);this._stringFormat=stringFormatPipe.transform.bind(stringFormatPipe)}/**
     * Determines which type of file we have to present.
     * @returns Nothing.
     */determinePresentationType(){if(this.file&amp;&amp;this.file.content_type)if(this.constructor.textMimeTypeRegularExpression.test(this.file.content_type))this.file.type='text';else if(this.constructor.imageMimeTypeRegularExpression.test(this.file.content_type))this.file.type='image';else if(this.constructor.videoMimeTypeRegularExpression.test(this.file.content_type))this.file.type='video';else this.file.type='binary'}/**
     * Initializes file upload handler.
     * @param changes - Holds informations about changed bound properties.
     * @returns Nothing.
     */ngOnChanges(changes){var _this13=this;return _asyncToGenerator(function*(){if(typeof _this13.model[_this13.idName]==='object')_this13._idIsObject=true;if(changes.hasOwnProperty('mapNameToField')&amp;&amp;_this13.mapNameToField&amp;&amp;!Array.isArray(_this13.mapNameToField))_this13.mapNameToField=[_this13.mapNameToField];if(changes.hasOwnProperty('model')||changes.hasOwnProperty('name')){_this13.internalName=_this13._getFilenameByPrefix(_this13.model[_this13.attachmentTypeName],_this13.name);if(_this13.name&amp;&amp;_this13.internalName&amp;&amp;_this13.internalName!==_this13.name)_this13._prefixMatch=true;_this13.model[_this13.attachmentTypeName][_this13.internalName].state={};_this13.file=_this13.model[_this13.attachmentTypeName][_this13.internalName].value;if(_this13.file)_this13.file.initialName=_this13.file.name;else if(!_this13.model[_this13.attachmentTypeName][_this13.internalName].nullable)_this13.model[_this13.attachmentTypeName][_this13.internalName].state.errors={required:true}}if(changes.hasOwnProperty('model')||changes.hasOwnProperty('name')||changes.hasOwnProperty('revision')){if(_this13.file){_this13.file.query=`?version=${_this13.file.digest}`;/*
                    NOTE: Only set new file source if isn't already present to
                    prevent to download an immediately uploaded file and grab
                    and older cached one.
                */if(!_this13.file.source){const id=_this13._idIsObject?_this13.model[_this13.idName].value:_this13.model[_this13.idName];if(_this13.revision&amp;&amp;changes.revision.currentValue!==changes.revision.previousValue)try{yield _this13.retrieveAttachment(id,{rev:_this13.revision})}catch(error){model[attachmentTypeName][internalName].state.errors.database='message'in error?error.message:_this13._representObject(error);return}else _this13.file.source=_this13._domSanitizer.bypassSecurityTrustResourceUrl(_this13._stringFormat(_this13.configuration.database.url,'')+'/'+(_this13.configuration.name||'generic')+`/${id}/${_this13.file.name}`+_this13.file.query)}}_this13.determinePresentationType();_this13.modelChange.emit(_this13.model);_this13.fileChange.emit(_this13.file)}})()}/**
     * Initializes current file input field. Adds needed event observer.
     * @returns Nothing.
     */ngAfterViewInit(){this.input.nativeElement.addEventListener('change',()=>{if(this.input.nativeElement.files.length>0){this.file={/* eslint-disable camelcase */// IgnoreTypeCheck
content_type:this.input.nativeElement.files[0].type||'text/plain',/* eslint-enable camelcase */// IgnoreTypeCheck
data:this.input.nativeElement.files[0],initialName:this.input.nativeElement.files[0].name,// IgnoreTypeCheck
length:this.input.nativeElement.files[0].size,name:this.input.nativeElement.files[0].name};this.update(this.file?this.file.name:null)}})}/**
     * Removes current file.
     * @returns A Promise which will be resolved after current file will be
     * removed.
     */remove(){var _this14=this;return _asyncToGenerator(function*(){if(_this14.synchronizeImmediately&amp;&amp;_this14.file){let result;const update={[_this14.typeName]:_this14.model[_this14.typeName],[_this14.idName]:_this14._idIsObject?_this14.model[_this14.idName].value:_this14.model[_this14.idName],[_this14.revisionName]:_this14.model[_this14.revisionName]};if(_this14.mapNameToField&amp;&amp;_this14.mapNameToField.includes(_this14.idName))update[_this14.deletedName]=true;else update[_this14.attachmentTypeName]={[_this14.file.name]:{/* eslint-disable camelcase */content_type:'text/plain',/* eslint-enable camelcase */data:null}};try{result=yield _this14._data.put(update)}catch(error){_this14.model[_this14.attachmentTypeName][_this14.internalName].state.errors={database:'message'in error?error.message:_this14._representObject(error)};return}if(_this14.mapNameToField&amp;&amp;_this14.mapNameToField.includes(_this14.idName))_this14.delete.emit(result);else _this14.model[_this14.revisionName]=result.rev}_this14.model[_this14.attachmentTypeName][_this14.internalName].state.errors=_this14.model[_this14.attachmentTypeName][_this14.internalName].value=_this14.file=null;if(!_this14.model[_this14.attachmentTypeName][_this14.internalName].nullable)_this14.model[_this14.attachmentTypeName][_this14.internalName].state.errors={required:true};_this14.modelChange.emit(_this14.model);_this14.fileChange.emit(_this14.file)})()}/**
     * Renames current file.
     * @param name - New name to rename current file to.
     * @returns A Promise which will be resolved after current file will be
     * renamed.
     */rename(name){var _this15=this;return _asyncToGenerator(function*(){const id=_this15._idIsObject?_this15.model[_this15.idName].value:_this15.model[_this15.idName];const oldName=_this15.file.name;if(_this15.file.stub&amp;&amp;_this15.mapNameToField&amp;&amp;id&amp;&amp;_this15.mapNameToField.includes(_this15.idName))try{yield _this15.retrieveAttachment(id)}catch(error){_this15.model[_this15.attachmentTypeName][_this15.internalName].state.errors={database:'message'in error?error.message:_this15._representObject(error)};return}_this15.file.name=name;return _this15.update(oldName)})()}/**
     * Retrieves current attachment with given document id and converts them
     * into a base 64 string which will be set as file source.
     * @param id - Document id which should hold needed attachment.
     * @param options - Options to use for the attachment retrieving.
     * @returns A promise which resolves if requested attachment was retrieved.
     */retrieveAttachment(id,options={}){var _this16=this;return _asyncToGenerator(function*(){const file=yield _this16._data.getAttachment(id,_this16.file.name,options);_this16.file={/* eslint-disable camelcase */content_type:file.type||'text/plain',/* eslint-enable camelcase */data:yield(0,_blobUtil.blobToBase64String)(file),length:file.size,name:_this16.file.name};_this16.file.source=_this16._domSanitizer.bypassSecurityTrustResourceUrl(`data:${_this16.file.content_type};base64,${_this16.file.data}`)})()}/**
     * Updates given current file into database (replaces if old name is
     * given).
     * @param oldName - Name of saved file to update or replace.
     * @returns A Promise which will be resolved after current file will be
     * synchronized.
     */update(oldName){var _this17=this;return _asyncToGenerator(function*(){_this17.model[_this17.attachmentTypeName][_this17.internalName].state={};if(_this17._prefixMatch){const lastIndex=_this17.file.name.lastIndexOf('.');if([0,-1].includes(lastIndex))_this17.file.name=_this17.name;else _this17.file.name=_this17.name+_this17.file.name.substring(lastIndex)}_this17.model[_this17.attachmentTypeName][_this17.internalName].value=_this17.file;// region determine errors
if(!_this17.model[_this17.attachmentTypeName][_this17.internalName].state.errors)_this17.model[_this17.attachmentTypeName][_this17.internalName].state.errors={};if(!new RegExp(_this17.internalName).test(_this17.file.name))_this17.model[_this17.attachmentTypeName][_this17.internalName].state.errors={name:true};if(!([undefined,null].includes(_this17.model[_this17.attachmentTypeName][_this17.internalName].contentTypeRegularExpressionPattern)||new RegExp(_this17.model[_this17.attachmentTypeName][_this17.internalName].contentTypeRegularExpressionPattern).test(_this17.file.content_type)))_this17.model[_this17.attachmentTypeName][_this17.internalName].state.errors.contentType=true;if(!([undefined,null].includes(_this17.model[_this17.attachmentTypeName][_this17.internalName].minimumSize)||_this17.model[_this17.attachmentTypeName][_this17.internalName].minimumSize&lt;=_this17.file.length))_this17.model[_this17.attachmentTypeName][_this17.internalName].state.errors.minimuSize=true;if(!([undefined,null].includes(_this17.model[_this17.attachmentTypeName][_this17.internalName].maximumSize)||_this17.model[_this17.attachmentTypeName][_this17.internalName].maximumSize>=_this17.file.length))_this17.model[_this17.attachmentTypeName][_this17.internalName].state.errors.maximumSize=true;if(Object.keys(_this17.model[_this17.attachmentTypeName][_this17.internalName].state.errors).length===0)delete _this17.model[_this17.attachmentTypeName][_this17.internalName].state.errors;// endregion
if(_this17.synchronizeImmediately&amp;&amp;!_this17.model[_this17.attachmentTypeName][_this17.internalName].state.errors){let newData={[_this17.typeName]:_this17.model[_this17.typeName],[_this17.idName]:_this17._idIsObject?_this17.model[_this17.idName].value:_this17.model[_this17.idName]};if(_this17.synchronizeImmediately!==true)_this17._extendObject(true,newData,_this17.synchronizeImmediately);let id=_this17._idIsObject?_this17.model[_this17.idName].value:_this17.model[_this17.idName];// NOTE: We want to replace old medium.
if(oldName&amp;&amp;oldName!==_this17.file.name&amp;&amp;!(_this17.mapNameToField&amp;&amp;id&amp;&amp;_this17.mapNameToField.includes(_this17.idName)))newData[_this17.attachmentTypeName]={[oldName]:{data:null}};if(![undefined,null].includes(_this17.model[_this17.revisionName]))newData[_this17.revisionName]=_this17.model[_this17.revisionName];const tasks=[];if(_this17.mapNameToField){if(id&amp;&amp;id!==_this17.file.name&amp;&amp;_this17.mapNameToField.includes(_this17.idName)){newData[_this17.deletedName]=true;tasks.unshift(newData);newData=_this17._extendObject(true,{},newData,{[_this17.deletedName]:false})}for(const name of _this17.mapNameToField){newData[name]=_this17.file.name;if(name===_this17.idName&amp;&amp;_this17._idIsObject)_this17.model[name].value=_this17.file.name;else _this17.model[name]=_this17.file.name}}newData[_this17.revisionName]='upsert';newData[_this17.attachmentTypeName]={[_this17.file.name]:{/* eslint-disable camelcase */content_type:_this17.file.content_type,/* eslint-enable camelcase */data:_this17.file.data}};tasks.unshift(newData);let result;try{result=yield _this17._data.bulkDocs(tasks)}catch(error){_this17.model[_this17.attachmentTypeName][_this17.internalName].state.errors={database:'message'in error?error.message:_this17._representObject(error)};return}id=newData[_this17.idName];let revision;for(const item of result){if(item.error){_this17.model[_this17.attachmentTypeName][_this17.internalName].state.errors={database:item.message};return}if(item.id===id)revision=item.rev}if(_this17.file){_this17.file.revision=_this17.model[_this17.revisionName]=revision;_this17.file.query=`?rev=${revision}`;_this17.file.source=_this17._domSanitizer.bypassSecurityTrustResourceUrl(_this17._stringFormat(_this17.configuration.database.url,'')+`/${_this17.configuration.name}/${id}/`+`${_this17.file.name}${_this17.file.query}`);_this17.determinePresentationType()}_this17.modelChange.emit(_this17.model);_this17.fileChange.emit(_this17.file)}else if(_this17.file.data){_this17.determinePresentationType();const fileReader=new FileReader;fileReader.onload=function(event){_this17.file.digest=new Date().getTime();_this17.file.source=_this17._domSanitizer.bypassSecurityTrustResourceUrl(event.target.result);if(_this17.mapNameToField)for(const name of _this17.mapNameToField)_this17.model[name]=_this17.file.name;_this17.modelChange.emit(_this17.model);_this17.fileChange.emit(_this17.file)};fileReader.readAsDataURL(_this17.file.data)}})()}},_class83.imageMimeTypeRegularExpression=new RegExp('^image/(?:p?jpe?g|png|svg(?:\\+xml)?|vnd\\.microsoft\\.icon|gif|'+'tiff|webp|vnd\\.wap\\.wbmp|x-(?:icon|jng|ms-bmp))$'),_class83.textMimeTypeRegularExpression=new RegExp('^(?:application/xml)|(?:text/(?:plain|x-ndpb[wy]html|(?:x-)?csv))$'),_class83.videoMimeTypeRegularExpression=new RegExp('^video/(?:(?:x-)?(?:x-)?webm|3gpp|mp2t|mp4|mpeg|quicktime|'+'(?:x-)?flv|(?:x-)?m4v|(?:x-)mng|x-ms-as|x-ms-wmv|x-msvideo)|'+'(?:application/(?:x-)?shockwave-flash)$'),_temp6),(_descriptor99=_applyDecoratedDescriptor(_class82.prototype,'delete',[_dec146],{enumerable:true,initializer:function(){return new _core.EventEmitter}}),_descriptor100=_applyDecoratedDescriptor(_class82.prototype,'deleteButtonText',[_dec147],{enumerable:true,initializer:function(){return'delete'}}),_descriptor101=_applyDecoratedDescriptor(_class82.prototype,'downloadButtonText',[_dec148],{enumerable:true,initializer:function(){return'download'}}),_descriptor102=_applyDecoratedDescriptor(_class82.prototype,'editableName',[_dec149],{enumerable:true,initializer:function(){return true}}),_descriptor103=_applyDecoratedDescriptor(_class82.prototype,'fileChange',[_dec150],{enumerable:true,initializer:function(){return new _core.EventEmitter}}),_descriptor104=_applyDecoratedDescriptor(_class82.prototype,'headerText',[_dec151],{enumerable:true,initializer:function(){return null}}),_descriptor105=_applyDecoratedDescriptor(_class82.prototype,'input',[_dec152],{enumerable:true,initializer:function(){return this.input}}),_descriptor106=_applyDecoratedDescriptor(_class82.prototype,'resetNameText',[_dec153],{enumerable:true,initializer:function(){return'\xD7'}}),_descriptor107=_applyDecoratedDescriptor(_class82.prototype,'saveNameText',[_dec154],{enumerable:true,initializer:function(){return'\u2713'}}),_descriptor108=_applyDecoratedDescriptor(_class82.prototype,'showDeclarationText',[_dec155],{enumerable:true,initializer:function(){return'\u2139'}}),_descriptor109=_applyDecoratedDescriptor(_class82.prototype,'mapNameToField',[_dec156],{enumerable:true,initializer:function(){return null}}),_descriptor110=_applyDecoratedDescriptor(_class82.prototype,'maximumSizeText',[_dec157],{enumerable:true,initializer:function(){return'Filesize (${file.length} byte) is more than specified maximum of '+'${model.maximumSize} byte.'}}),_descriptor111=_applyDecoratedDescriptor(_class82.prototype,'minimumSizeText',[_dec158],{enumerable:true,initializer:function(){return'Filesize (${file.length} byte) is less than specified minimum of '+'${model.minimumSize} byte.'}}),_descriptor112=_applyDecoratedDescriptor(_class82.prototype,'model',[_dec159],{enumerable:true,initializer:function(){return this.model}}),_descriptor113=_applyDecoratedDescriptor(_class82.prototype,'modelChange',[_dec160],{enumerable:true,initializer:function(){return new _core.EventEmitter}}),_descriptor114=_applyDecoratedDescriptor(_class82.prototype,'name',[_dec161],{enumerable:true,initializer:function(){return null}}),_descriptor115=_applyDecoratedDescriptor(_class82.prototype,'namePatternText',[_dec162],{enumerable:true,initializer:function(){return'Given filename "${file.name}" doesn\'t match specified pattern "'+'${internalName}".'}}),_descriptor116=_applyDecoratedDescriptor(_class82.prototype,'newButtonText',[_dec163],{enumerable:true,initializer:function(){return'new'}}),_descriptor117=_applyDecoratedDescriptor(_class82.prototype,'noFileText',[_dec164],{enumerable:true,initializer:function(){return''}}),_descriptor118=_applyDecoratedDescriptor(_class82.prototype,'noPreviewText',[_dec165],{enumerable:true,initializer:function(){return''}}),_descriptor119=_applyDecoratedDescriptor(_class82.prototype,'requiredText',[_dec166],{enumerable:true,initializer:function(){return'Please select a file.'}}),_descriptor120=_applyDecoratedDescriptor(_class82.prototype,'revision',[_dec167],{enumerable:true,initializer:function(){return null}}),_descriptor121=_applyDecoratedDescriptor(_class82.prototype,'showValidationErrorMessages',[_dec168],{enumerable:true,initializer:function(){return false}}),_descriptor122=_applyDecoratedDescriptor(_class82.prototype,'synchronizeImmediately',[_dec169],{enumerable:true,initializer:function(){return false}}),_descriptor123=_applyDecoratedDescriptor(_class82.prototype,'typePatternText',[_dec170],{enumerable:true,initializer:function(){return'Filetype "${file.content_type}" doesn\'t match specified pattern "'+'${model.contentTypeRegularExpressionPattern}".'}})),_class82))||_class81);// / endregion
// / region pagination
/* eslint-disable max-len */// IgnoreTypeCheck
Reflect.defineMetadata('design:paramtypes',[DataService,_platformBrowser.DomSanitizer,ExtendObjectPipe,GetFilenameByPrefixPipe,InitialDataService,RepresentObjectPipe,StringFormatPipe,ToolsService],FileInputComponent);/* eslint-enable max-len *//**
 * Provides a generic pagination component.
 * @property itemsPerPage - Number of items to show per page as maximum.
 * @property page - Contains currently selected page number.
 * @property pageChange - Event emitter to fire on each page change event.
 * @property pageRangeLimit - Number of concrete page links to show.
 * @property total - Contains total number of pages.
 *
 * @property _changeDetectorReference - Current views change detector reference
 * service instance.
 * @property _makeRangePipe - Saves the make range pipe transformation
 * function.
 */let PaginationComponent=exports.PaginationComponent=(_dec171=(0,_core.Component)({animations:[defaultAnimation()],changeDetection:_core.ChangeDetectionStrategy.OnPush,selector:'generic-pagination',template:`
        &lt;ul @defaultAnimation *ngIf="lastPage > 1">
            &lt;li @defaultAnimation *ngIf="page > 2">
                &lt;a href="" (click)="change($event, 1)">--&lt;/a>
            &lt;/li>
            &lt;li @defaultAnimation *ngIf="page > 1">
                &lt;a href="" (click)="change($event, previousPage)">-&lt;/a>
            &lt;/li>
            &lt;li
                class="page-{{currentPage}}"
                @defaultAnimation
                [ngClass]="{current: currentPage === page, previous: currentPage === previousPage, next: currentPage === nextPage, even: even, 'even-page': currentPage % 2 === 0, first: currentPage === firstPage, last: currentPage === lastPage}"
                *ngFor="let currentPage of pagesRange;let even = even"
            >
                &lt;a (click)="change($event, currentPage)" href="">
                    {{currentPage}}
                &lt;/a>
            &lt;/li>
            &lt;li @defaultAnimation *ngIf="lastPage > page">
                &lt;a href="" (click)="change($event, nextPage)">+&lt;/a>
            &lt;/li>
            &lt;li @defaultAnimation *ngIf="lastPage > page + 1">
                &lt;a href="" (click)="change($event, lastPage)">++&lt;/a>
            &lt;/li>
        &lt;/ul>
    `}),_dec172=(0,_core.Input)(),_dec173=(0,_core.Input)(),_dec174=(0,_core.Output)(),_dec175=(0,_core.Input)(),_dec176=(0,_core.Input)(),_dec171(_class84=(_class85=class PaginationComponent{/**
     * Sets needed services as property values.
     * @param changeDetectorReference - Model dirty checking service.
     * @param makeRangePipe - Saves the make range pipe instance.
     * @returns Nothing.
     */constructor(changeDetectorReference,makeRangePipe){_initDefineProp(this,'itemsPerPage',_descriptor124,this);_initDefineProp(this,'page',_descriptor125,this);_initDefineProp(this,'pageChange',_descriptor126,this);_initDefineProp(this,'pageRangeLimit',_descriptor127,this);_initDefineProp(this,'total',_descriptor128,this);this._changeDetectorReference=this._changeDetectorReference;this._makeRange=this._makeRange;this._changeDetectorReference=changeDetectorReference;this._makeRange=makeRangePipe.transform.bind(makeRangePipe)}/**
     * Is called whenever a page change should be performed.
     * @param event - The responsible event.
     * @param newPage - New page number to change to.
     * @returns Nothing.
     */change(event,newPage){event.preventDefault();this._changeDetectorReference.markForCheck();this.page=newPage;this.pageChange.emit(this.page)}/**
     * Determines the highest page number.
     * @returns The determines page number.
     */get lastPage(){return Math.ceil(this.total/this.itemsPerPage)}/**
     * Retrieves the next or last (if last is current) page.
     * @returns The new determined page number.
     */get nextPage(){return Math.min(this.page+1,this.lastPage)}/**
     * Determines the number of pages to show.
     * @returns A list of page numbers.
     */get pagesRange(){if(this.page-this.pageRangeLimit&lt;1){const start=1;const startRest=this.pageRangeLimit-(this.page-start);const end=Math.min(this.lastPage,this.page+this.pageRangeLimit+startRest);return this._makeRange([start,end])}const end=Math.min(this.lastPage,this.page+this.pageRangeLimit);const endRest=this.pageRangeLimit-(end-this.page);const start=Math.max(1,this.page-this.pageRangeLimit-endRest);return this._makeRange([start,end])}/**
     * Determines the previous or first (if first is current) page.
     * @returns The previous determined page number.
     */get previousPage(){return Math.max(1,this.page-1)}},(_descriptor124=_applyDecoratedDescriptor(_class85.prototype,'itemsPerPage',[_dec172],{enumerable:true,initializer:function(){return 10}}),_descriptor125=_applyDecoratedDescriptor(_class85.prototype,'page',[_dec173],{enumerable:true,initializer:function(){return 1}}),_descriptor126=_applyDecoratedDescriptor(_class85.prototype,'pageChange',[_dec174],{enumerable:true,initializer:function(){return new _core.EventEmitter}}),_descriptor127=_applyDecoratedDescriptor(_class85.prototype,'pageRangeLimit',[_dec175],{enumerable:true,initializer:function(){return 4}}),_descriptor128=_applyDecoratedDescriptor(_class85.prototype,'total',[_dec176],{enumerable:true,initializer:function(){return 0}})),_class85))||_class84);// / endregion
// endregion
// region module
Reflect.defineMetadata('design:paramtypes',[_core.ChangeDetectorRef,ArrayMakeRangePipe],PaginationComponent);const determineExports=exports.determineExports=module=>Object.keys(module.exports).filter(name=>!name.startsWith('Abstract')&amp;&amp;['Component','Directive','Pipe'].some(suffix=>name.endsWith(suffix))).map(name=>module.exports[name]);const determineDeclarations=exports.determineDeclarations=module=>determineExports(module).concat(Object.keys(module.exports).filter(name=>!name.startsWith('Abstract')&amp;&amp;['Accessor'].some(suffix=>name.endsWith(suffix))).map(name=>module.exports[name]));const determineProviders=exports.determineProviders=module=>Object.keys(module.exports).filter(name=>name.endsWith('Resolver')||name.endsWith('Pipe')||name.endsWith('Guard')||name.endsWith('Service')).map(name=>module.exports[name]);// IgnoreTypeCheck
/**
 * Represents the importable angular module.
 */let Module=(_dec177=(0,_core.NgModule)({declarations:determineDeclarations(module),entryComponents:[ConfirmComponent],exports:determineExports(module),imports:[_platformBrowser.BrowserModule.withServerTransition({appId:'generic-universal'}),_forms.FormsModule,_material.MatButtonModule,_material.MatCardModule,_material.MatDialogModule,_material.MatInputModule,_material.MatSelectModule,_material.MatTooltipModule,_angularTinymce.TinyMceModule.forRoot(TINY_MCE_DEFAULT_OPTIONS)],providers:determineProviders(module).concat(_common.DatePipe,{deps:[DataService,InitialDataService,_core.Injector],multi:true,provide:_core.APP_INITIALIZER,useFactory:(data,initialData,injector)=>()=>{initialData.constructor.injectors.add(injector);return data.initialize()}})}),_dec177(_class87=class Module{})||_class87);// endregion
// region vim modline
// vim: set tabstop=4 shiftwidth=4 expandtab:
// vim: foldmethod=marker foldmarker=region,endregion:
// endregion
exports.default=Module;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)(module)))

/***/ }),
/* 11 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 12 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_12__;

/***/ }),
/* 13 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_13__;

/***/ }),
/* 14 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_14__;

/***/ }),
/* 15 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_15__;

/***/ }),
/* 16 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_16__;

/***/ }),
/* 17 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_17__;

/***/ }),
/* 18 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_18__;

/***/ }),
/* 19 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_19__;

/***/ }),
/* 20 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_20__;

/***/ }),
/* 21 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_21__;

/***/ }),
/* 22 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_22__;

/***/ }),
/* 23 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_23__;

/***/ }),
/* 24 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_24__;

/***/ })
/******/ ]);</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-angularGeneric.html">angularGeneric</a></li></ul><h3>Classes</h3><ul><li><a href="module-angularGeneric.AbstractNativeInputComponent.html">AbstractNativeInputComponent</a></li><li><a href="module-angularGeneric-_class4.html">_class4</a></li><li><a href="module-angularGeneric-_class5.html">_class5</a></li><li><a href="module-angularGeneric-_class8.html">_class8</a></li><li><a href="module-angularGeneric-_class10.html">_class10</a></li><li><a href="module-angularGeneric-_class12.html">_class12</a></li><li><a href="module-angularGeneric-_class16.html">_class16</a></li><li><a href="module-angularGeneric-_class27.html">_class27</a></li><li><a href="module-angularGeneric-_class28.html">_class28</a></li><li><a href="module-angularGeneric-_class29.html">_class29</a></li><li><a href="module-angularGeneric-_class30.html">_class30</a></li><li><a href="module-angularGeneric-_class31.html">_class31</a></li><li><a href="module-angularGeneric-_class38-_class39.html">_class39</a></li><li><a href="module-angularGeneric-_class41.html">_class41</a></li><li><a href="module-angularGeneric-_class44.html">_class44</a></li><li><a href="module-angularGeneric-_class45.html">_class45</a></li><li><a href="module-angularGeneric-_class47.html">_class47</a></li><li><a href="module-angularGeneric-_class52.html">_class52</a></li><li><a href="module-angularGeneric-_class54.html">_class54</a></li><li><a href="module-angularGeneric-_class56-_class57.html">_class57</a></li><li><a href="module-angularGeneric-_class59-_class60.html">_class60</a></li><li><a href="module-angularGeneric-_class62.html">_class62</a></li><li><a href="module-angularGeneric-_class66-_class67.html">_class67</a></li><li><a href="module-angularGeneric-_class72-_class73.html">_class73</a></li><li><a href="module-angularGeneric-_class75-_class76.html">_class76</a></li><li><a href="module-angularGeneric-_class83.html">_class83</a></li><li><a href="module-angularGeneric-_class84-_class85.html">_class85</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Tue Oct 17 2017 17:49:23 GMT+0200 (CEST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
