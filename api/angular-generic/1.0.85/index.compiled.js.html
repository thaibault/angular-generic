<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: index.compiled.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: index.compiled.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';
var index =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.l = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };

/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};

/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module &amp;&amp; module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};

/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 23);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_0__;

/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_1__;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {// #!/usr/bin/env node
// -*- coding: utf-8 -*-
/** @module angularGeneric *//* !
    region header
    [Project page](http://torben.website/angularGeneric)

    Copyright Torben Sickert (info["~at~"]torben.website) 16.12.2012

    License
    -------

    This library written by Torben Sickert stand under a creative commons
    naming 3.0 unported license.
    See http://creativecommons.org/licenses/by/3.0/deed.de
    endregion
*/// region imports
Object.defineProperty(exports,'__esModule',{value:true});exports.default=exports.GenericPaginationComponent=exports.GenericFileInputComponent=exports.GenericTextareaComponent=exports.GenericInputComponent=exports.AbstractItemsComponent=exports.AbstractInputComponent=exports.AbstractResolver=exports.GenericDataScopeService=exports.GenericDataService=exports.GenericCanDeactivateRouteLeaveGuard=exports.GenericNumberPercentPipe=exports.GenericStringSliceMatchPipe=exports.GenericStringStartsWithPipe=exports.GenericStringShowIfPatternMatchesPipe=exports.GenericStringReplacePipe=exports.GenericStringMatchPipe=exports.GenericStringHasTimeSuffixPipe=exports.GenericStringEndsWithPipe=exports.GenericTypePipe=exports.GenericMapPipe=exports.GenericGetFilenameByPrefixPipe=exports.GenericIsDefinedPipe=exports.GenericExtractRawDataPipe=exports.GenericInitialDataService=exports.GenericToolsService=undefined;var _dec,_class,_dec2,_class3,_dec3,_class5,_dec4,_class6,_dec5,_class7,_dec6,_class8,_dec7,_class10,_dec8,_class11,_dec9,_class12,_dec10,_class13,_dec11,_class14,_dec12,_class15,_dec13,_class16,_dec14,_class17,_dec15,_class18,_dec16,_class19,_dec17,_class20,_class21,_temp,_dec18,_class22,_dec19,_dec20,_dec21,_desc,_value,_class25,_descriptor,_descriptor2,_descriptor3,_dec22,_dec23,_class28,_desc2,_value2,_class29,_descriptor4,_dec24,_class31,_dec25,_dec26,_dec27,_dec28,_dec29,_dec30,_dec31,_dec32,_dec33,_dec34,_class32,_desc3,_value3,_class33,_descriptor5,_descriptor6,_descriptor7,_descriptor8,_descriptor9,_descriptor10,_descriptor11,_descriptor12,_descriptor13,_class34,_temp2,_dec35,_dec36,_dec37,_dec38,_dec39,_dec40,_class35,_desc4,_value4,_class36,_descriptor14,_descriptor15,_descriptor16,_descriptor17,_descriptor18,_dec41,_class38;var _clientnode=__webpack_require__(11);var _clientnode2=_interopRequireDefault(_clientnode);var _core=__webpack_require__(0);var _forms=__webpack_require__(7);var _material=__webpack_require__(8);var _platformBrowser=__webpack_require__(9);var _router=__webpack_require__(1);var _pouchdb=__webpack_require__(17);var _pouchdb2=_interopRequireDefault(_pouchdb);var _pouchdbFind=__webpack_require__(15);var _pouchdbFind2=_interopRequireDefault(_pouchdbFind);var _pouchdbValidation=__webpack_require__(16);var _pouchdbValidation2=_interopRequireDefault(_pouchdbValidation);var _rxjs=__webpack_require__(18);var _Observable=__webpack_require__(20);function _interopRequireDefault(obj){return obj&amp;&amp;obj.__esModule?obj:{default:obj}}function _initDefineProp(target,property,descriptor,context){if(!descriptor)return;Object.defineProperty(target,property,{enumerable:descriptor.enumerable,configurable:descriptor.configurable,writable:descriptor.writable,value:descriptor.initializer?descriptor.initializer.call(context):void 0})}function _applyDecoratedDescriptor(target,property,decorators,descriptor,context){var desc={};Object['ke'+'ys'](descriptor).forEach(function(key){desc[key]=descriptor[key]});desc.enumerable=!!desc.enumerable;desc.configurable=!!desc.configurable;if('value'in desc||desc.initializer){desc.writable=true}desc=decorators.slice().reverse().reduce(function(desc,decorator){return decorator(target,property,desc)||desc},desc);if(context&amp;&amp;desc.initializer!==void 0){desc.value=desc.initializer?desc.initializer.call(context):void 0;desc.initializer=undefined}if(desc.initializer===void 0){Object['define'+'Property'](target,property,desc);desc=null}return desc}function _initializerWarningHelper(descriptor,context){throw new Error('Decorating class property failed. Please ensure that transform-class-properties is enabled.')}function _asyncToGenerator(fn){return function(){var gen=fn.apply(this,arguments);return new Promise(function(resolve,reject){function step(key,arg){try{var info=gen[key](arg);var value=info.value}catch(error){reject(error);return}if(info.done){resolve(value)}else{return Promise.resolve(value).then(function(value){step('next',value)},function(err){step('throw',err)})}}return step('next')})}}// NOTE: Only needed for debugging this file.
try{module.require('source-map-support/register')}catch(error){}// endregion
// region basic services
// IgnoreTypeCheck
/**
 * Injectable angular service for the tools class.
 * @property $ - Holds an instance of a generic dom abstraction layer like
 * jquery.
 * @property globalContext - Hold a reference to the environment specific
 * global scope.
 * @property tools - Holds a reference to the wrapped tools class.
 */let GenericToolsService=exports.GenericToolsService=(_dec=(0,_core.Injectable)(),_dec(_class=class GenericToolsService{constructor(){this.$=_clientnode.$;this.globalContext=_clientnode.globalContext;this.tools=_clientnode2.default}})||_class);// IgnoreTypeCheck
/**
 * Serves initial data provided via a global variable.
 */let GenericInitialDataService=exports.GenericInitialDataService=(_dec2=(0,_core.Injectable)(),_dec2(_class3=class GenericInitialDataService{/**
     * Sets all properties of given initial data as properties to this
     * initializing instance.
     * @param tools - Saves the generic tools service.
     * @returns Nothing.
     */constructor(tools){this.configuration=this.configuration;for(const key in tools.globalContext.genericInitialData)if(tools.globalContext.genericInitialData.hasOwnProperty(key))// IgnoreTypeCheck
this[key]=tools.globalContext.genericInitialData[key]}})||_class3);// endregion
// region pipes
// / region forwarded methods
Reflect.defineMetadata('design:paramtypes',[GenericToolsService],GenericInitialDataService);const reference={};for(const name of Object.getOwnPropertyNames(_clientnode2.default))if(!['caller','arguments'].includes(name))// IgnoreTypeCheck
reference[name]=_clientnode2.default[name];for(const configuration of[{invert:['array'],methodGroups:{string:['encodeURIComponent'],number:['pow']},reference:window},{invert:['array'],methodGroups:{'':['convertCircularObjectToJSON','equals','extendObject','representObject','sort'],array:'*',number:'*',string:'*'},reference:reference}])for(const methodTypePrefix in configuration.methodGroups)if(configuration.methodGroups.hasOwnProperty(methodTypePrefix)){let methodNames=[];if(configuration.methodGroups[methodTypePrefix]==='*'){for(const name in configuration.reference)if(configuration.reference.hasOwnProperty(name)&amp;&amp;configuration.reference.hasOwnProperty(name)&amp;&amp;new RegExp(`^${methodTypePrefix}[A-Z0-9]`).test(name))methodNames.push(name)}else methodNames=configuration.methodGroups[methodTypePrefix];for(const methodName of methodNames){const pipeName=_clientnode2.default.stringCapitalize(methodName);module.exports[`Generic${pipeName}Pipe`]=class{/**
                     * Performs the concrete conversion logic.
                     * @param parameter - Saves all generic parameter to
                     * forward it for triggering the underlying tools utility.
                     * @returns Whatever the underlying tools function returns.
                     */transform(...parameter){return _core.ReflectiveInjector.resolveAndCreate([GenericToolsService]).get(GenericToolsService).tools[methodName](...parameter)}};(0,_core.Pipe)({name:`generic${pipeName}`})(module.exports[`Generic${pipeName}Pipe`]);if(configuration.invert.includes(methodTypePrefix)){module.exports[`generic${pipeName}InvertedPipe`]=class{/**
                         * Performs the concrete conversion logic.
                         * @param parameter - Saves all generic parameter to
                         * forward it for triggering the underlying tools
                         * utility.
                         * @returns Whatever the underlying tools function
                         * returns.
                         */transform(...parameter){const tools=_core.ReflectiveInjector.resolveAndCreate([GenericToolsService]).get(GenericToolsService).tools;// IgnoreTypeCheck
return tools.invertArrayFilter(tools[methodName])(...parameter)}};(0,_core.Pipe)({name:`generic${pipeName}Inverted`})(module.exports[`generic${pipeName}InvertedPipe`])}}}// / endregion
// / region object
// IgnoreTypeCheck
/**
 * Removes all meta data from documents.
 */let GenericExtractRawDataPipe/* implements PipeTransform*/=exports.GenericExtractRawDataPipe=(_dec3=(0,_core.Pipe)({name:'genericExtractRawData'}),_dec3(_class5=class GenericExtractRawDataPipe{/**
     * Implements attachment changes or removes.
     * @param newDocument - Document to slice meta data from.
     * @param oldAttachments - Old document to take into account.
     * @param fileTypeReplacement - Indicates weather file type replacements
     * and removes should be taken into account.
     * @param untouchedAttachments - List of file names which doesn't exist in
     * given new document.
     * @returns The sliced attachment version of given document.
     */_handleAttachmentChanges(newDocument,oldAttachments,fileTypeReplacement,untouchedAttachments){for(const type in oldAttachments)if(oldAttachments.hasOwnProperty(type)&amp;&amp;![undefined,null].includes(oldAttachments[type].value)){if(newDocument._attachments){if(newDocument._attachments.hasOwnProperty(oldAttachments[type].value.name))continue}else if(!untouchedAttachments.includes(oldAttachments[type].value.name)){newDocument._attachments={[oldAttachments[type].value.name]:{data:null}};continue}if(fileTypeReplacement)for(const fileName in newDocument._attachments)if(newDocument._attachments.hasOwnProperty(fileName)&amp;&amp;new RegExp(type).test(fileName))newDocument._attachments[oldAttachments[type].value.name]={data:null}}return newDocument}/**
     * Implements the meta data removing of given document.
     * @param newDocument - Document to slice meta data from.
     * @param oldDocument - Optionally existing old document to take into
     * account.
     * @param fileTypeReplacement - Indicates weather file type replacements
     * and removes should be taken into account.
     * @returns The copies sliced version of given document.
     */transform(newDocument,oldDocument,fileTypeReplacement=true){const result={};const untouchedAttachments=[];for(const name in newDocument)if(newDocument.hasOwnProperty(name)&amp;&amp;![undefined,null,''].includes(newDocument[name])&amp;&amp;name!=='_revisions')if(name==='_attachments'){result[name]={};let empty=true;for(const fileName in newDocument[name])if(newDocument[name].hasOwnProperty(fileName))if(newDocument[name][fileName].hasOwnProperty('data')&amp;&amp;!(oldDocument&amp;&amp;oldDocument.hasOwnProperty(name)&amp;&amp;oldDocument[name].hasOwnProperty(fileName)&amp;&amp;newDocument[name][fileName].data===oldDocument[name][fileName].data&amp;&amp;(oldDocument[name][fileName].content_type||'application/octet-stream')===(newDocument[name][fileName].content_type||'application/octet-stream'))){result[name][fileName]={content_type:newDocument[name][fileName].content_type||'application/octet-stream',data:newDocument[name][fileName].data};empty=false}else untouchedAttachments.push(fileName);if(empty)delete result[name]}else result[name]=newDocument[name];// Handle attachment removes or replacements.
if(oldDocument&amp;&amp;oldDocument.hasOwnProperty('_attachments')&amp;&amp;oldDocument._attachments)this._handleAttachmentChanges(result,oldDocument._attachments,fileTypeReplacement,untouchedAttachments);return result}})||_class5);// IgnoreTypeCheck
/**
 * Checks if given reference is defined.
 */let GenericIsDefinedPipe/* implements PipeTransform*/=exports.GenericIsDefinedPipe=(_dec4=(0,_core.Pipe)({name:'genericIsDefined'}),_dec4(_class6=class GenericIsDefinedPipe{/**
     * Performs the actual comparison.
     * @param object - Object to compare against "undefined" or "null".
     * @param nullIsUndefined - Indicates weather "null" should be handles as
     * "undefined".
     * @returns The comparison result.
     */transform(object,nullIsUndefined=false){return!(object===undefined||nullIsUndefined&amp;&amp;object===null)}})||_class6);// IgnoreTypeCheck
/**
 * Retrieves a matching filename by given filename prefix.
 */let GenericGetFilenameByPrefixPipe/* implements PipeTransform*/=exports.GenericGetFilenameByPrefixPipe=(_dec5=(0,_core.Pipe)({name:'genericGetFilenameByPrefix'}),_dec5(_class7=class GenericGetFilenameByPrefixPipe{/**
     * Performs the actual transformations process.
     * @param attachments - Documents attachments object to determine file with
     * matching file name prefix.
     * @param prefix - Prefix or nothing to search for. If nothing given first
     * file name will be returned.
     * @returns Matching file name or null if no file matches.
     */transform(attachments,prefix){if(prefix){for(const name in attachments)if(attachments.hasOwnProperty(name)&amp;&amp;name.startsWith(prefix))return name}else{const keys=Object.keys(attachments);if(keys.length)return keys[0]}return null}})||_class7);// IgnoreTypeCheck
/**
 * Returns a copy of given object where each item was processed through given
 * function.
 * @property injector - Pipe specific injector to determine pipe dynamically at
 * runtime.
 */let GenericMapPipe/* implements PipeTransform*/=exports.GenericMapPipe=(_dec6=(0,_core.Pipe)({name:'genericMap'}),_dec6(_class8=class GenericMapPipe{/**
     * Injects the injector and saves as instance property.
     * @param injector - Pipe injector service instance.
     * @returns Nothing.
     */constructor(injector){this.injector=this.injector;this.injector=injector}/**
     * Performs the actual transformation.
     * @param object - Iterable item where given pipe should be applied to each
     * value.
     * @param pipeName - Pipe to apply to each value.
     * @param additionalArguments - All additional arguments will be forwarded
     * to given pipe (after the actual value).
     * @returns Given transform copied object.
     */transform(object,pipeName,...additionalArguments){const pipe=this.injector.get(pipeName);if(Array.isArray(object)){const result=[];for(const item of object)result.push(pipe.transform(item,...additionalArguments));return result}const result={};for(const key in object)if(object.hasOwnProperty(key))result[key]=pipe.transform.transform(object[key],key,...additionalArguments);return result}})||_class8);// IgnoreTypeCheck
Reflect.defineMetadata('design:paramtypes',[_core.Injector],GenericMapPipe);/**
 * Determines type of given object.
 */let GenericTypePipe/* implements PipeTransform*/=exports.GenericTypePipe=(_dec7=(0,_core.Pipe)({name:'genericType'}),_dec7(_class10=class GenericTypePipe{/**
     * Returns type of given object.
     * @param object - Object to determine type of.
     * @returns Type name.
     */transform(object){return typeof object}})||_class10);// / endregion
// region string
// IgnoreTypeCheck
/**
 * Forwards javaScript's native "stringEndsWith" method.
 */let GenericStringEndsWithPipe/* implements PipeTransform*/=exports.GenericStringEndsWithPipe=(_dec8=(0,_core.Pipe)({name:'genericStringEndsWith'}),_dec8(_class11=class GenericStringEndsWithPipe{/**
     * Performs the actual indicator method.
     * @param string - To check.
     * @param needle - Suffix to search for.
     * @returns The boolean result.
     */transform(string,needle){return typeof string==='string'&amp;&amp;typeof needle==='string'&amp;&amp;string.endsWith(needle)}})||_class11);// IgnoreTypeCheck
/**
 * Determines if given string has a time indicating suffix.
 */let GenericStringHasTimeSuffixPipe/* implements PipeTransform*/=exports.GenericStringHasTimeSuffixPipe=(_dec9=(0,_core.Pipe)({name:'genericStringHasTimeSuffix'}),_dec9(_class12=class GenericStringHasTimeSuffixPipe{/**
     * Performs the actual string suffix check.
     * @param string - To search in.
     * @returns The boolean result.
     */transform(string){if(typeof string!=='string')return false;return string.endsWith('Date')||string.endsWith('Time')||string==='timestamp'}})||_class12);// IgnoreTypeCheck
/**
 * Tests if given pattern matches against given subject.
 */let GenericStringMatchPipe/* implements PipeTransform*/=exports.GenericStringMatchPipe=(_dec10=(0,_core.Pipe)({name:'genericStringMatch'}),_dec10(_class13=class GenericStringMatchPipe{/**
     * Performs the actual matching.
     * @param pattern - String or regular expression to search for.
     * @param subject - String to search in.
     * @param modifier - Regular expression modifier (second argument to the
     * "RegExp" constructor).
     * @returns Boolean test result.
     */transform(pattern,subject,modifier=''){// IgnoreTypeCheck
return new RegExp(pattern,modifier).test(subject)}})||_class13);// IgnoreTypeCheck
/**
 * Provides javascript's native string replacement method as pipe.
 */let GenericStringReplacePipe/* implements PipeTransform*/=exports.GenericStringReplacePipe=(_dec11=(0,_core.Pipe)({name:'genericStringReplace'}),_dec11(_class14=class GenericStringReplacePipe{/**
     * Performs the actual replacement.
     * @param string - String to replace content.
     * @param search - String or regular expression to us as matcher.
     * @param replacement - String to replace with matching parts in given
     * "string".
     * @param modifier - Regular expression modifier (second argument to the
     * "RegExp" constructor).
     * @returns A new string with replacements done.
     */transform(string,search,replacement='',modifier='g'){// IgnoreTypeCheck
return string.replace(new RegExp(search,modifier),replacement)}})||_class14);// IgnoreTypeCheck
/**
 * Returns given string if it matches given pattern.
 */let GenericStringShowIfPatternMatchesPipe/* implements PipeTransform*/=exports.GenericStringShowIfPatternMatchesPipe=(_dec12=(0,_core.Pipe)({name:'genericStringShowIfPatternMatches'}),_dec12(_class15=class GenericStringShowIfPatternMatchesPipe{/**
     * Performs the actual matching.
     * @param string - String to replace content.
     * @param pattern - String or regular expression to us as matcher.
     * @param invert - Indicates weather given string should be shown if given
     * pattern matches or not.
     * @param modifier - Regular expression modifier (second argument to the
     * "RegExp" constructor).
     * @returns Given string if matching indicator was successful.
     */transform(string,pattern,invert=false,modifier=''){// IgnoreTypeCheck
let indicator=new RegExp(pattern,modifier).test(string);if(invert)indicator=!indicator;return indicator?string:''}})||_class15);// IgnoreTypeCheck
/**
 * Forwards javascript's native "stringStartsWith" method.
 */let GenericStringStartsWithPipe/* implements PipeTransform*/=exports.GenericStringStartsWithPipe=(_dec13=(0,_core.Pipe)({name:'genericStringStartsWith'}),_dec13(_class16=class GenericStringStartsWithPipe{/**
     * Performs the actual indicator method.
     * @param string - To check.
     * @param needle - Prefix to search for.
     * @returns The boolean result.
     */transform(string,needle){return typeof string==='string'&amp;&amp;typeof needle==='string'&amp;&amp;string.startsWith(needle)}})||_class16);// IgnoreTypeCheck
/**
 * Returns a matched part of given subject with given pattern. Default is the
 * whole (zero) matched part.
 */let GenericStringSliceMatchPipe/* implements PipeTransform*/=exports.GenericStringSliceMatchPipe=(_dec14=(0,_core.Pipe)({name:'genericStringSliceMatch'}),_dec14(_class17=class GenericStringSliceMatchPipe{/**
     * Performs the actual matching.
     * @param subject - String to search in.
     * @param pattern - String or regular expression to search for.
     * @param index - Match group to extract.
     * @param modifier - Regular expression modifier (second argument to the
     * "RegExp" constructor).
     * @returns Matching group.
     */transform(subject,pattern,index=0,modifier=''){if(typeof subject==='string'){const match=subject.match(new RegExp(// IgnoreTypeCheck
pattern,modifier));if(match&amp;&amp;typeof match[index]==='string')return match[index]}return''}})||_class17);// / endregion
// / region number
// IgnoreTypeCheck
/**
 * Returns part in percent of all.
 */let GenericNumberPercentPipe/* implements PipeTransform*/=exports.GenericNumberPercentPipe=(_dec15=(0,_core.Pipe)({name:'genericNumberPercent'}),_dec15(_class18=class GenericNumberPercentPipe{/**
     * Performs the actual calculation.
     * @param part - Part to divide "all" through.
     * @param all - Reference value to calculate part of.
     * @returns The calculated part.
     */transform(part,all){return part/all*100}})||_class18);// / endregion
// endregion
const GenericArrayMakeRangePipe=module.exports.GenericArrayMakeRangePipe;const GenericStringEscapeRegularExpressionsPipe=module.exports.GenericStringEscapeRegularExpressionsPipe;const GenericExtendObjectPipe=module.exports.GenericExtendObjectPipe;const GenericRepresentObjectPipe=module.exports.GenericRepresentObjectPipe;const GenericStringFormatPipe=module.exports.GenericStringFormatPipe;// region services
// IgnoreTypeCheck
/**
 * A generic guard which prevents from switching to route if its component's
 * "canDeactivate()" method returns "false", a promise or observable wrapping
 * a boolean.
 */let GenericCanDeactivateRouteLeaveGuard/* implements CanDeactivate&lt;Object>*/=exports.GenericCanDeactivateRouteLeaveGuard=(_dec16=(0,_core.Injectable)(),_dec16(_class19=class GenericCanDeactivateRouteLeaveGuard{/**
     * Calls the component specific "canDeactivate()" method.
     * @param component - Component instance of currently selected route.
     * @returns A boolean, promise or observable which wraps the indicator.
     */canDeactivate(component){return'canDeactivate'in component?component.canDeactivate():true}})||_class19);// IgnoreTypeCheck
let/**
 * A generic database connector.
 * @property connection - The current database connection instance.
 * @property database - The entire database constructor.
 * @property extendObject - Holds the extend object's pipe transformation
 * method.
 * @property middlewares - Mapping of post and pre callback arrays to trigger
 * before or after each database transaction.
 * @property synchronisation - This synchronisation instance represents the
 * active synchronisation process if a local offline database is in use.
 * @property stringFormat - Holds the string format's pipe transformation
 * method.
 */GenericDataService=exports.GenericDataService=(_dec17=(0,_core.Injectable)(),_dec17(_class20=(_temp=_class21=class GenericDataService{/**
     * Creates the database constructor applies all plugins instantiates
     * the connection instance and registers all middlewares.
     * @param extendObject - Injected extend object pipe instance.
     * @param initialData - Injected initial data service instance.
     * @param stringFormat - Injected string format pipe instance.
     * @returns Nothing.
     */constructor(extendObject,initialData,stringFormat){this.connection=this.connection;this.configuration=this.configuration;this.database=this.database;this.extendObject=this.extendObject;this.middlewares={post:{},pre:{}};this.stringFormat=this.stringFormat;this.synchronisation=this.synchronisation;this.database=_pouchdb2.default.plugin(_pouchdbFind2.default).plugin(_pouchdbValidation2.default);this.extendObject=extendObject.transform.bind(extendObject);this.configuration=initialData.configuration;this.stringFormat=stringFormat.transform.bind(stringFormat);for(const plugin of this.configuration.database.plugins||[])this.database=this.database.plugin(plugin);this.initialize()}/**
     * Initializes database connection and synchronisation if needed.
     * @returns Nothing.
     */initialize(){const type=this.configuration.database.local?'local':this.configuration.database.url;this.connection=new this.database(this.stringFormat(type,'')+(/^[a-z]+:\/\/.+$/g.test(type)?`/${this.configuration.name||'generic'}`:''),this.extendObject(true,{skip_setup:true},this.configuration.database.options||{}));for(const name in this.connection)if(this.constructor.wrappableMethodNames.includes(name)&amp;&amp;typeof this.connection[name]==='function'){const method=this.connection[name];this.connection[name]=(...parameter)=>{for(const methodName of[name,'_all'])if(this.middlewares.pre.hasOwnProperty(methodName))for(const interceptor of this.middlewares.pre[methodName])parameter=interceptor.apply(this.connection,parameter.concat(methodName==='_all'?name:[]));let result=method.apply(this.connection,parameter);for(const methodName of[name,'_all'])if(this.middlewares.post.hasOwnProperty(methodName))for(const interceptor of this.middlewares.post[methodName])result=interceptor.call(this.connection,result,...parameter.concat(methodName==='_all'?name:[]));return result}}this.connection.installValidationMethods();if(this.configuration.database.local)this.synchronisation=_pouchdb2.default.sync(this.stringFormat(this.configuration.database.url,`${this.configuration.database.user.name}:`+`${this.configuration.database.user.password}@`)+`/${this.configuration.name}`,'local',{live:true,retry:true}).on('change',info=>console.info('change',info)).on('paused',error=>console.info('paused',error)).on('active',()=>console.info('active')).on('denied',error=>console.warn('denied',error)).on('complete',info=>console.info('complete',info)).on('error',error=>console.error('error',error))}/**
     * Creates a database index.
     * @param parameter - All parameter will be forwarded to the underlining
     * pouchdb-find's "createIndex()" method.
     * @returns Whatever pouchdb-find's "createIndex()" method returns.
     */createIndex(...parameter){return this.connection.createIndex(...parameter)}/**
     * Removes current active database.
     * @param parameter - All parameter will be forwarded to the underlining
     * pouchdb's "destroy()" method.
     * @returns Whatever pouchdb's "destroy()" method returns.
     */destroy(...parameter){if(this.synchronisation)this.synchronisation.cancel();const result=this.connection.destroy(...parameter);this.middlewares={post:{},pre:{}};return result}/**
     * Retrieves a database resource determined by given selector.
     * @param selector - Selector object in mango.
     * @param options - Options to use during selecting items.
     * @returns A promise with resulting array of retrieved resources.
     */find(selector,options={}){var _this=this;return _asyncToGenerator(function*(){return(yield _this.connection.find(_this.extendObject(true,{selector},options))).docs})()}/**
     * Retrieves a resource by id.
     * @param parameter - All parameter will be forwarded to the underlining
     * pouchdb's "get()" method.
     * @returns Whatever pouchdb's "get()" method returns.
     */get(...parameter){return this.connection.get(...parameter)}/**
     * Creates or updates given data.
     * @param parameter - All parameter will be forwarded to the underlining
     * pouchdb's "put()" method.
     * @returns Whatever pouchdb's "put()" method returns.
     */put(...parameter){return this.connection.put(...parameter)}/**
     * Registers a new middleware.
     * @param names - Event names to intercept.
     * @param callback - Callback function to trigger when specified event
     * happens.
     * @param type - Specifies weather callback should be triggered before or
     * after specified event has happened.
     * @returns A cancel function which will deregister given middleware.
     */register(names,callback,type='post'){if(!Array.isArray(names))names=[names];for(const name of names){if(!this.middlewares[type].hasOwnProperty(name))this.middlewares[type][name]=[];this.middlewares[type][name].push(callback)}return()=>{for(const name of names){const index=this.middlewares[type][name].indexOf(callback);if(index!==-1)this.middlewares[type][name].splice(index,1);if(this.middlewares[type][name].length===0)delete this.middlewares[type][name]}}}/**
     * Removes specified entities in database.
     * @param parameter - All parameter will be forwarded to the underlining
     * pouchdb's "remove()" method.
     * @returns Whatever pouchdb's "remove()" method return.
     */remove(...parameter){return this.connection.remove(...parameter)}},_class21.wrappableMethodNames=['allDocs','bulkDocs','bulkGet','changes','close','compact','compactDocument','createIndex','deleteIndexs','destroy','find','get','getAttachment','getIndexes','info','post','put','putAttachment','query','remove','removeAttachment','sync'],_temp))||_class20);// IgnoreTypeCheck
Reflect.defineMetadata('design:paramtypes',[GenericExtendObjectPipe,GenericInitialDataService,GenericStringFormatPipe],GenericDataService);/**
 * Auto generates a components scope environment for a specified model.
 * @property configuration - Holds the configuration service instance.
 * @property data - Holds the data exchange service instance.
 * @property extendObject - Holds the extend object's pipe transformation
 * method.
 * @property tools - Holds the tools class from the tools service.
 */let GenericDataScopeService=exports.GenericDataScopeService=(_dec18=(0,_core.Injectable)(),_dec18(_class22=class GenericDataScopeService{/**
     * Saves alle needed services as property values.
     * @param data - Injected data service instance.
     * @param extendObject - Injected extend object pipe instance.
     * @param initialData - Injected initial data service instance.
     * @param tools - Injected tools service instance.
     * @returns Nothing.
     */constructor(data,extendObject,initialData,tools){this.configuration=this.configuration;this.data=this.data;this.extendObject=this.extendObject;this.tools=this.tools;this.configuration=initialData.configuration;this.data=data;this.extendObject=extendObject.transform.bind(extendObject);this.tools=tools.tools}/**
     * Retrieves needed data for given scope.
     * @param scope - Scope to use to determine which data is needed.
     * @returns Resolved data.
     */get(scope){const result={};for(const key in scope)if(scope.hasOwnProperty(key)&amp;&amp;!key.startsWith('_')&amp;&amp;typeof scope[key]==='object'&amp;&amp;scope[key]!==null&amp;&amp;'hasOwnProperty'in scope&amp;&amp;scope[key].hasOwnProperty('value'))result[key]=scope[key].value;if(scope.hasOwnProperty('_attachments')&amp;&amp;scope._attachments)for(const key in scope._attachments)if(scope._attachments.hasOwnProperty(key)&amp;&amp;typeof scope._attachments[key]==='object'&amp;&amp;scope._attachments[key]!==null&amp;&amp;'hasOwnProperty'in scope._attachments&amp;&amp;scope._attachments[key].hasOwnProperty('value')&amp;&amp;scope._attachments[key].value){if(!result._attachments)result._attachments={};result._attachments[scope._attachments[key].value.name]=scope._attachments[key].value}for(const name of['_id','_rev','-type'])if(scope.hasOwnProperty(name))result[name]=scope[name];return result}/**
     * Generates a scope object for given model with given property names and
     * property value mapping data.
     * @param modelName - Name of model to generate scope for.
     * @param propertyNames - List of property names to generate meta data in
     * scope for. If "null" is given all properties in given model will be
     * taken into account.
     * @param data - Data to use for given properties.
     * @returns The generated scope object.
     */generate(modelName,propertyNames=null,data={}){const modelSpecification=this.configuration.modelConfiguration.models[modelName];for(const name in modelSpecification)if(modelSpecification.hasOwnProperty(name))if(name==='_attachments'){for(const fileName in modelSpecification[name])if(modelSpecification[name].hasOwnProperty(fileName))modelSpecification[name][fileName]=this.extendObject(true,this.tools.copyLimitedRecursively(this.configuration.modelConfiguration.default.propertySpecification),modelSpecification[name][fileName])}else modelSpecification[name]=this.extendObject(true,this.tools.copyLimitedRecursively(this.configuration.modelConfiguration.default.propertySpecification),modelSpecification[name]);if(!propertyNames)propertyNames=Object.keys(modelSpecification);const result={};for(const name of propertyNames){if(modelSpecification.hasOwnProperty(name))result[name]=this.tools.copyLimitedRecursively(modelSpecification[name]);else result[name]={};if(name==='_attachments'){for(const type in modelSpecification[name])if(modelSpecification[name].hasOwnProperty(type)){result[name][type].name=type;result[name][type].value=null;if(Object.keys(data).length===0)for(const hookType of['onCreateExpression','onCreateExecution'])if(result[name][type].hasOwnProperty(hookType)&amp;&amp;result[name][type][hookType]){result[name][type].value=new Function('newDocument','oldDocument','userContext','securitySettings','name','models','modelConfiguration','serialize','modelName','model','propertySpecification',(hookType.endsWith('Expression')?'return ':'')+result[name][type][hookType])(data,null,{},{},type,this.configuration.modelConfiguration.models,modelSpecification,object=>JSON.stringify(object,null,4),modelName,modelSpecification,result[name][type]);if(result[name][type].hasOwnProperty('value')&amp;&amp;result[name][type].value===undefined)delete result[name][type].value}let fileFound=false;if(data.hasOwnProperty(name)&amp;&amp;![undefined,null].includes(data[name]))for(const fileName in data[name])if(result[name].hasOwnProperty(type)&amp;&amp;new RegExp(type).test(fileName)){fileFound=true;result[name][type].value=data[name][fileName];result[name][type].value.name=fileName;break}if(!fileFound&amp;&amp;result[name][type].hasOwnProperty('default')&amp;&amp;![undefined,null].includes(result[name][type].default))result[name][type].value=result[name][type].default}}else if(!name.startsWith('_')){result[name].name=name;result[name].value=null;if(Object.keys(data).length===0)for(const type of['onCreateExpression','onCreateExecution'])if(result[name].hasOwnProperty(type)&amp;&amp;result[name][type])result[name].value=new Function('newDocument','oldDocument','userContext','securitySettings','name','models','modelConfiguration','serialize','modelName','model','propertySpecification',(type.endsWith('Expression')?'return ':'')+result[name][type])(data,null,{},{},name,this.configuration.modelConfiguration.models,this.configuration.modelConfiguration,object=>JSON.stringify(object,null,4),modelName,modelSpecification,result[name]);if(data.hasOwnProperty(name)&amp;&amp;![undefined,null].includes(data[name]))result[name].value=data[name];else if(result[name].hasOwnProperty('default')&amp;&amp;![undefined,null].includes(result[name].default))result[name].value=result[name].default;else if(result[name].hasOwnProperty('selection')&amp;&amp;Array.isArray(result[name].selection)&amp;&amp;result[name].selection.length)result[name].value=result[name].selection[0];if(!(result[name].value instanceof Date)&amp;&amp;(name.endsWith('Time')||name.endsWith('Date')))result[name].value=new Date(result[name].value)}}for(const name of['_id','_rev','-type'])if(data.hasOwnProperty(name))result[name]=data[name];else if(name==='-type')result[name]=modelName;result._metaData={submitted:false};return result}/**
     * Useful to sets route specific data in a resolver.
     * @param modelName - Name of model to retrieve data from.
     * @param scope - Scope or array of scopes to extend and set retrieved
     * values in.
     * @param id - ID of an entity to retrieve data from.
     * @param propertyNames - List of property names to retrieve data from.
     * @param options - To use for retrieving needed data from data service.
     * @returns A promise wrapping requested data.
     */set(modelName,scope=null,id=null,propertyNames=null,options={}){var _this2=this;return _asyncToGenerator(function*(){if(propertyNames&amp;&amp;!options.hasOwnProperty('fields'))options.fields=propertyNames;let data={};if(id){const result=yield _this2.data.find({'-type':modelName,_id:id},options);if(result.length===0)throw new Error(`Document with given id "${id}" isn't available.`);data=result[0]}const result=_this2.generate(modelName,propertyNames,data);if(scope){if(!Array.isArray(scope))scope=[scope];for(const object of scope)_this2.extendObject(true,object,result);return result}return result})()}})||_class22);// / region abstract
/**
 * Helper class to extend from to have some basic methods to deal with database
 * entities.
 * @property _type - Model name to handle /should be overwritten in concrete
 * implementations.
 * @property data - Holds currently retrieved data.
 * @property escapeRegularExpressions - Holds the escape regular expressions's
 * pipe transformation method.
 * @property extendObject - Holds the extend object's pipe transformation
 * method.
 * @property models - Saves a mapping from all available model names to their
 * specification.
 * @property relevantKeys - Saves a list of relevant key names to take into
 * account during resolving.
 */Reflect.defineMetadata('design:paramtypes',[GenericDataService,GenericExtendObjectPipe,GenericInitialDataService,GenericToolsService],GenericDataScopeService);let AbstractResolver/* implements Resolve&lt;PlainObject>*/=exports.AbstractResolver=class AbstractResolver{/**
     * Sets all needed injected services as instance properties.
     * @param data - Injected data service instance.
     * @param escapeRegularExpressions - Injected escape regular expression
     * pipe instance.
     * @param extendObject - Injected extend object pipe instance.
     * @param initialData - Injected initial data service instance.
     * @returns Nothing.
     */constructor(data,escapeRegularExpressions,extendObject,initialData){this._type='Item';this.data=this.data;this.escapeRegularExpressions=this.escapeRegularExpressions;this.extendObject=this.extendObject;this.models=this.models;this.relevantKeys=null;this.data=data;this.escapeRegularExpressions=escapeRegularExpressions.transform.bind(escapeRegularExpressions);this.extendObject=extendObject.transform.bind(extendObject);this.models=initialData.configuration.modelConfiguration.models}/**
     * List items which matches given filter criteria.
     * @param sort - List of items.
     * @param page - Page to show.
     * @param limit - Maximal number of entities to retrieve.
     * @param searchTerm - String query to search for.
     * @param additionalSelectors - Custom filter criteria.
     * @returns A promise wrapping retrieved data.
     */list(sort=[{_id:'asc'}],page=1,limit=10,searchTerm='',additionalSelectors={}){if(!this.relevantKeys)this.relevantKeys=Object.keys(this.models[this._type]).filter(name=>!name.startsWith('_')&amp;&amp;[undefined,'string'].includes(this.models[this._type][name].type));const selector={'-type':this._type};if(searchTerm||Object.keys(additionalSelectors).length){if(sort.length)selector[Object.keys(sort[0])[0]]={$gt:null};selector.$or=[];for(const name of this.relevantKeys)selector.$or.push({[name]:{$regex:searchTerm}})}/*
            NOTE: We can't use "limit" here since we want to provide total data
            set size for pagination.
        */const options={skip:(page-1)*limit};if(options.skip===0)delete options.skip;if(sort.length)options.sort=[{'-type':'asc'}].concat(sort);return this.data.find(this.extendObject(true,selector,additionalSelectors),options)}/* eslint-disable no-unused-vars *//**
     * Implements the resolver method which converts route informations into
     * "list()" method parameter and forward their result as result in an
     * observable.
     * @param route - Current route informations.
     * @param state - Current state informations.
     * @returns Observable with data filtered by current route informations.
     */resolve(route,state){/* eslint-enable no-unused-vars */let searchTerm='';if('searchTerm'in route.params){const term=decodeURIComponent(route.params.searchTerm);if(term.startsWith('exact-'))searchTerm=this.escapeRegularExpressions(term.substring('exact-'.length));else if(term.startsWith('regex-')){searchTerm=term.substring('regex-'.length);try{new RegExp(searchTerm)}catch(error){searchTerm=''}}}let sort=[];if('sort'in route.params)sort=route.params.sort.split(',').map(name=>{const lastIndex=name.lastIndexOf('-');let type='asc';if(lastIndex!==-1){name=name.substring(0,lastIndex);type=name.substring(lastIndex+1)||type}return{[name]:type}});return _Observable.Observable.fromPromise(this.list(sort,parseInt(route.params.page||1),parseInt(route.params.limit||10),searchTerm))}};// / endregion
// endregion
// region components
// / region abstract
/**
 * Generic input component.
 * @property extendObject - Holds the extend object's pipe transformation
 * @property model - Holds model informations including actual value and
 * metadata.
 * @property modelChange - Model event emitter emitting events on each model
 * change.
 * @property showValidationErrorMessages - Indicates weather validation errors
 * should be suppressed or be shown automatically. Useful to prevent error
 * component from showing error messages before the user has submit the form.
 */Reflect.defineMetadata('design:paramtypes',[GenericDataService,GenericStringEscapeRegularExpressionsPipe,GenericExtendObjectPipe,GenericInitialDataService],AbstractResolver);let AbstractInputComponent=exports.AbstractInputComponent=(_dec19=(0,_core.Input)(),_dec20=(0,_core.Output)(),_dec21=(0,_core.Input)(),(_class25=class AbstractInputComponent{/**
     * Sets needed services as property values.
     * @param extendObject - Injected extend object pipe instance.
     * @returns Nothing.
     */constructor(extendObject){this._extendObject=this._extendObject;_initDefineProp(this,'model',_descriptor,this);_initDefineProp(this,'modelChange',_descriptor2,this);_initDefineProp(this,'showValidationErrorMessages',_descriptor3,this);this._extendObject=extendObject.transform.bind(extendObject)}/**
     * Triggers after input values have been resolved.
     * @returns Nothing.
     */ngOnInit(){this._extendObject(this.model,this._extendObject({disabled:false,maximum:Infinity,minimum:this.model.type==='string'?0:-Infinity,nullable:true,regularExpressionPattern:'.*',state:{},type:'string'},this.model))}/**
     * Triggers when ever a change to current model happens inside this
     * component.
     * @param state - Saves the current model state.
     * @returns Nothing.
     */onChange(state){this.model.state=state;this.modelChange.emit(this.model)}},(_descriptor=_applyDecoratedDescriptor(_class25.prototype,'model',[_dec19],{enumerable:true,initializer:function(){return{}}}),_descriptor2=_applyDecoratedDescriptor(_class25.prototype,'modelChange',[_dec20],{enumerable:true,initializer:function(){return new _core.EventEmitter}}),_descriptor3=_applyDecoratedDescriptor(_class25.prototype,'showValidationErrorMessages',[_dec21],{enumerable:true,initializer:function(){return false}})),_class25));/**
 * A generic abstract component to edit, search, navigate and filter a list of
 * entities.
 * @property _itemPath - Routing path to a specific item.
 * @property _itemsPath - Routing path to the items overview.
 * @property _route - Current route configuration.
 * @property _router - Router service instance.
 * @property _tools - Tools service instance property.
 * @property items - Current list of visible items.
 * @property limit - Maximal number of visible items.
 * @property page - Current page number of each item list part.
 * @property regularExpression - Indicator weather searching via regular
 * expressions should be used.
 * @property searchTerm - Search string to filter visible item list.
 * @property searchTermStream - Search term stream which debounces and caches
 * search results.
 * @property selectedItems - List of currently selected items for group editing
 * purposes.
 * @property sort - Sorting informations.
 */Reflect.defineMetadata('design:paramtypes',[GenericExtendObjectPipe],AbstractInputComponent);let AbstractItemsComponent=exports.AbstractItemsComponent=class AbstractItemsComponent{/**
     * Saves injected service instances as instance properties.
     * @param route - Current route configuration.
     * @param router - Injected router service instance.
     * @param tools - Injected tools service instance.
     * @returns Nothing.
     */constructor(route,router,tools){this._itemPath='admin/item';this._itemsPath='admin/items';this._route=this._route;this._router=this._router;this._tools=this._tools;this.items=this.items;this.limit=this.limit;this.page=this.page;this.regularExpression=false;this.searchTerm='';this.searchTermStream=new _rxjs.Subject;this.selectedItems=new Set;this.sort={_id:'asc'};this._route=route;this._router=router;this._tools=tools.tools;this._route.params.subscribe(data=>{this.page=parseInt(data.page);this.limit=parseInt(data.limit);const match=/(regex|exact)-(.*)/.exec(data.searchTerm);if(match){this.regularExpression=match[1]==='regex';this.searchTerm=match[2]}});this._route.data.subscribe(data=>{this.limit=Math.max(1,this.limit||1);const total=data.items.length+(Math.max(1,this.page||1)-1)*this.limit;if(data.items.length>this.limit)data.items.splice(this.limit,data.items.length-this.limit);this.items=data.items;this.items.total=total;if(this.applyPageConstraints())this._tools.timeout(()=>this.update())});this.searchTermStream.debounceTime(200).distinctUntilChanged().map(()=>{this.page=1;return this.update()}).subscribe()}/**
     * Updates constraints between limit, page number and number of total
     * available items.
     * @returns Nothing.
     */applyPageConstraints(){const oldPage=this.page;const oldLimit=this.limit;this.limit=Math.max(1,this.limit||1);this.page=Math.max(1,Math.min(this.page,Math.ceil(this.items.total/this.limit)));return this.page!==oldPage||this.limit!==oldLimit}/* eslint-disable no-unused-vars *//**
     * Deletes item which has same id provided by the id property through given
     * event object.
     * @param event - Event object which triggers action.
     * @returns Nothing.
     */delete(event){this.update(true)}/* eslint-enable no-unused-vars *//**
     * Removes all items currently selected and clear current selection.
     * @returns Nothing.
     */deleteSelectedItems(){this.update(true)}/**
     * Switches section to item which has given id.
     * @param itemID - ID of item to switch to.
     * @returns Nothing.
     */goToItem(itemID){this._router.navigate([this._itemPath,itemID])}/**
     * Applies current filter criteria to current visible item set.
     * @param reload - Indicates weather a simple reload should be made because
     * a changed list of available items is expected for example.
     * @returns A boolean indicating weather route change was successful.
     */update(reload=false){this.applyPageConstraints();if(reload)/*
                NOTE: Will be normalised to "1" after route reload (hack to
                enforce route reloading).
            */this.page=0;let sort='';for(const name in this.sort)if(this.sort.hasOwnProperty(name))sort+=`${sort?',':''}${name}-${this.sort[name]}`;return this._router.navigate([this._itemsPath,sort,this.page,this.limit,`${this.regularExpression?'regex':'exact'}-`+encodeURIComponent(this.searchTerm)])}/**
     * Applies current search term to the search term stream.
     * @returns Nothing.
     */updateSearch(){this.searchTermStream.next(this.searchTerm)}};// / endregion
// // region text
/* eslint-disable max-len */Reflect.defineMetadata('design:paramtypes',[_router.ActivatedRoute,_router.Router,GenericToolsService],AbstractItemsComponent);const propertyInputContent=`
    [disabled]="model.disabled || model.mutable === false || model.writable === false"
    [maxlength]="model.type === 'string' ? model.maximum : null"
    [minlength]="model.type === 'string' ? model.minimum : null"
    [pattern]="model.type === 'string' ? model.regularExpressionPattern : null"
    [placeholder]="model.description || model.name"
    [required]="!model.nullable"
    [(ngModel)]="model.value"
    #state="ngModel"
    #data
    (change)="onChange(state)"
`;const mdInputContent=`
    &lt;span
        md-suffix (click)="showDeclaration = !showDeclaration" title="info"
        *ngIf="model.declaration"
    >[i]&lt;/span>
    &lt;md-hint align="start">
        &lt;span *ngIf="showValidationErrorMessages">
            &lt;span *ngIf="model.state.errors?.required">
                Bitte füllen Sie das Feld "{{model.description || model.name}}"
                aus.
            &lt;/span>
            &lt;span *ngIf="model.state.errors?.maxlength">
                Bitte geben Sie maximal {{model.maximum}} Zeichen ein.
            &lt;/span>
            &lt;span *ngIf="model.state.errors?.minlength">
                Bitte geben Sie mindestens {{model.minimum}} Zeichen ein.
            &lt;/span>
            &lt;span *ngIf="model.state.errors?.max">
                Bitte geben Sie eine Zahl kleiner oder gleich {{model.maximum}}
                ein.
            &lt;/span>
            &lt;span *ngIf="model.state.errors?.min">
                Bitte geben Sie eine Zahl großer oder gleich {{model.minimum}}
                ein.
            &lt;/span>
            &lt;span *ngIf="model.state.errors?.pattern">
                Bitte geben Sie eine Zeinefolge ein die dem regulären Ausdruck
                "{{model.regularExpressionPattern}}" entspricht.
            &lt;/span>
        &lt;/span>
        &lt;span *ngIf="showDeclaration">{{model.declaration}}&lt;/span>
    &lt;/md-hint>
    &lt;md-hint
        align="end"
        *ngIf="model.type === 'string' &amp;&amp; model.maximum !== null &amp;&amp; model.maximum &lt; 100"
    >{{data.characterCount}} / {{model.maximum}}&lt;/md-hint>
`;// IgnoreTypeCheck
/* eslint-enable max-len *//**
 * A generic form input component with validation, labeling and info
 * description support.
 * @property type - Optionally defines an input type explicitly.
 */let GenericInputComponent=exports.GenericInputComponent=(_dec22=(0,_core.Component)({selector:'generic-input',template:`
        &lt;md-input
            [max]="model.type === 'number' ? model.maximum : null"
            [min]="model.type === 'number' ? model.minimum : null"
            [type]="type || model.name.startsWith('password') ? 'password' : model.type === 'string' ? 'text' : 'number'"
            ${propertyInputContent}
        >${mdInputContent}&lt;/md-input>`}),_dec23=(0,_core.Input)(),_dec22(_class28=(_class29=class GenericInputComponent extends AbstractInputComponent{/**
     * Forwards injected service instances to the abstract input component's
     * constructor.
     * @param extendObject - Injected extend object pipe instance.
     * @returns Nothing.
     */constructor(extendObject){super(extendObject);_initDefineProp(this,'type',_descriptor4,this)}},(_descriptor4=_applyDecoratedDescriptor(_class29.prototype,'type',[_dec23],{enumerable:true,initializer:function(){return this.type}})),_class29))||_class28);// IgnoreTypeCheck
Reflect.defineMetadata('design:paramtypes',[GenericExtendObjectPipe],GenericInputComponent);/**
 * A generic form textarea component with validation, labeling and info
 * description support.
 */let GenericTextareaComponent=exports.GenericTextareaComponent=(_dec24=(0,_core.Component)({selector:'generic-textarea',template:`
        &lt;md-textarea ${propertyInputContent}>${mdInputContent}&lt;/md-textarea>`}),_dec24(_class31=class GenericTextareaComponent extends AbstractInputComponent{/**
     * Forwards injected service instances to the abstract input component's
     * constructor.
     * @param extendObject - Injected extend object pipe instance.
     * @returns Nothing.
     */constructor(extendObject){super(extendObject)}})||_class31);// // endregion
// / region file input
/* eslint-disable max-len */// IgnoreTypeCheck
Reflect.defineMetadata('design:paramtypes',[GenericExtendObjectPipe],GenericTextareaComponent);/* eslint-enable max-len *//**
 * A file type independent file uploader with file content preview (if
 * supported).
 * @property static:imageMimeTypeRegularExpression - Regular expression which
 * should match to each known image mime type.
 * @property static:textMimeTypeRegularExpression - Regular expression which
 * should match to each known text mime type.
 * @property static:videoMimeTypeRegularExpression - Regular expression which
 * should match to each known video mime type.
 * @property _data - Holds the data service instance.
 * @property _domSanitizer - Holds the dom sanitizer service instance.
 * @property _extendObject - Holds the extend object pipe instance's transform
 * method.
 * @property _getFilenameByPrefix - Holds the file name by prefix getter pipe
 * instance's transform method.
 * @property _representObject - Holds the represent object pipe instance's
 * transform method.
 * @property _prefixMatch - Holds the prefix match pipe instance's transform
 * method.
 * @property delete - Event emitter which triggers its handler when current
 * file should be removed.
 * @property file - Holds the current selected file object if present.
 * @property fileChange - Event emitter emitting when file changes happen.
 * @property input - Virtual file input dom node.
 * @property internalName - Technical regular expression style file type.
 * @property mapNameToField - Indicates weather current file name should be
 * mapped to a specific model property.
 * @property model - File property specification.
 * @property modelChange -
 * @property name - Name of currently active file.
 * @property showValidationErrorMessages - Indicates weather validation errors
 * should be displayed. Useful to hide error messages until user tries to
 * submit a form.
 * @property synchronizeImmediately - Indicates weather file upload should be
 * done immediately after a file was selected (or synchronously with other
 * model data).
 */let GenericFileInputComponent/* implements OnInit, AfterViewInit*/=exports.GenericFileInputComponent=(_dec25=(0,_core.Component)({selector:'generic-file-input',template:`
        &lt;md-card>
            &lt;md-card-header>
                &lt;h3>
                    {{model._attachments[internalName]?.description || name}}
                    &lt;span
                        md-suffix (click)="showDeclaration = !showDeclaration"
                        title="info"
                        *ngIf="model._attachments[internalName]?.declaration"
                    >[i]&lt;/span>
                &lt;/h3>
                &lt;p *ngIf="showDeclaration">
                    {{model._attachments[internalName].declaration}}
                &lt;/p>
            &lt;/md-card-header>
            &lt;img md-card-image
                *ngIf="file?.type === 'image' &amp;&amp; file?.source"
                [attr.alt]="name" [attr.src]="file.source"
            >
            &lt;video
                md-card-image autoplay muted loop
                *ngIf="file?.type === 'video' &amp;&amp; file?.source"
            >
                &lt;source [attr.src]="file.source" [type]="file.content_type">
                Keine Vorschau möglich.
            &lt;/video>
            &lt;iframe
                [src]="file.source"
                *ngIf="file?.type === 'text' &amp;&amp; file?.source"
                style="border:none;width:100%;max-height:150px"
            >&lt;/iframe>
            &lt;div
                md-card-image
                *ngIf="!file?.type &amp;&amp; (file?.source || (file?.source | genericType) === 'string')"
            >Keine Vorschau möglich.&lt;/div>
            &lt;div md-card-image *ngIf="!file">Keine Datei ausgewählt.&lt;/div>
            &lt;md-card-content>
                &lt;ng-content>&lt;/ng-content>
                &lt;span *ngIf="showValidationErrorMessages">
                    &lt;p
                        *ngIf="model._attachments[internalName]?.state.errors?.required"
                    >Bitte wählen Sie eine Datei aus.&lt;/p>
                    &lt;p
                        *ngIf="model._attachments[internalName]?.state.errors?.name"
                    >
                        Der Dateiname "{{file.name}}" entspricht nicht dem
                        vorgegebenen Muster "{{this.internalName}}".
                    &lt;/p>
                    &lt;p
                        *ngIf="model._attachments[internalName]?.state.errors?.contentType"
                    >
                        Der Daten-Typ "{{file.content_type}}" entspricht
                        nicht dem vorgegebenen Muster
                        "{{model._attachments[internalName].contentTypeRegularExpressionPattern}}".
                    &lt;/p>
                    &lt;p
                        *ngIf="model._attachments[internalName]?.state.errors?.database"
                    >
                        {{model._attachments[internalName]?.state.errors?.database}}
                    &lt;/p>
                &lt;/span>
            &lt;/md-card-content>
            &lt;md-card-actions>
                &lt;input #input type="file" style="display:none"/>
                &lt;button md-button (click)="input.click()">Neu&lt;/button>
                &lt;button md-button *ngIf="file" (click)="remove()">
                    Löschen
                &lt;/button>
                &lt;a *ngIf="file" [download]="file.name" [href]="file.source">
                    &lt;button md-button>Download&lt;/button>
                &lt;/a>
            &lt;/md-card-actions>
        &lt;/md-card>
    `}),_dec26=(0,_core.Output)(),_dec27=(0,_core.Output)(),_dec28=(0,_core.ViewChild)('input'),_dec29=(0,_core.Input)(),_dec30=(0,_core.Input)(),_dec31=(0,_core.Output)(),_dec32=(0,_core.Input)(),_dec33=(0,_core.Input)(),_dec34=(0,_core.Input)(),_dec25(_class32=(_class33=(_temp2=_class34=class GenericFileInputComponent{/**
     * Sets needed services as property values.
     * @param data - Injected data service instance.
     * @param domSanitizer - Injected dom sanitizer service instance.
     * @param extendObject - Injected extend object pipe instance.
     * @param getFilenameByPrefix - Saves the file name by prefix retriever
     * pipe instance.
     * @param initialData - Injected initial data service instance.
     * @param representObject - Saves the object to string representation pipe
     * instance.
     * @returns Nothing.
     */constructor(data,domSanitizer,extendObject,getFilenameByPrefix,initialData,representObject){this._configuration=this._configuration;this._data=this._data;this._domSanitizer=this._domSanitizer;this._extendObject=this._extendObject;this._getFilenameByPrefix=this._getFilenameByPrefix;this._representObject=this._representObject;this._prefixMatch=false;_initDefineProp(this,'delete',_descriptor5,this);this.file=null;_initDefineProp(this,'fileChange',_descriptor6,this);_initDefineProp(this,'input',_descriptor7,this);this.internalName=this.internalName;_initDefineProp(this,'mapNameToField',_descriptor8,this);_initDefineProp(this,'model',_descriptor9,this);_initDefineProp(this,'modelChange',_descriptor10,this);_initDefineProp(this,'name',_descriptor11,this);_initDefineProp(this,'showValidationErrorMessages',_descriptor12,this);_initDefineProp(this,'synchronizeImmediately',_descriptor13,this);this._configuration=initialData.configuration;this._data=data;this._domSanitizer=domSanitizer;this._extendObject=extendObject.transform.bind(extendObject);this._getFilenameByPrefix=getFilenameByPrefix.transform.bind(getFilenameByPrefix);this._representObject=representObject.transform.bind(representObject)}/**
     * Initializes file upload handler.
     * @returns Nothing.
     */ngOnInit(){if(this.mapNameToField&amp;&amp;!Array.isArray(this.mapNameToField))this.mapNameToField=[this.mapNameToField];const name=this._getFilenameByPrefix(this.model._attachments,this.name);if(this.name&amp;&amp;name!==this.name)this._prefixMatch=true;this.internalName=name;this.file=this.model._attachments[this.internalName].value;this.model._attachments[this.internalName].state={};if(this.file)this.file.descriptionName=this.name;else if(!this.model._attachments[this.internalName].nullable)this.model._attachments[this.internalName].state.errors={required:true};if(this.file){this.file.hash=`#${this.file.digest}`;this.file.source=this._domSanitizer.bypassSecurityTrustResourceUrl(this._configuration.database.url+`/${this._configuration.name||'generic'}/`+`${this.model._id}/${this.file.name}${this.file.hash}`)}this.determinePresentationType();this.fileChange.emit(this.file)}/**
     * Initializes current file input field. Adds needed event observer.
     * @returns Nothing.
     */ngAfterViewInit(){var _this3=this;this.input.nativeElement.addEventListener('change',_asyncToGenerator(function*(){if(_this3.input.nativeElement.files.length&lt;1)return;_this3.model._attachments[_this3.internalName].state={};const oldFileName=_this3.file?_this3.file.name:null;_this3.file={descriptionName:_this3.name,name:_this3.input.nativeElement.files[0].name};if(!_this3.name)_this3.name=_this3.file.name;else if(_this3._prefixMatch){const lastIndex=_this3.file.name.lastIndexOf('.');if([0,-1].includes(lastIndex))_this3.file.name=_this3.name;else _this3.file.name=_this3.name+_this3.file.name.substring(lastIndex)}// IgnoreTypeCheck
_this3.file.data=_this3.input.nativeElement.files[0];// IgnoreTypeCheck
_this3.file.content_type=_this3.file.data.type||'text/plain';// IgnoreTypeCheck
_this3.file.length=_this3.file.data.size;_this3.model._attachments[_this3.internalName].value=_this3.file;if(!new RegExp(_this3.internalName).test(_this3.file.name))_this3.model._attachments[_this3.internalName].state.errors={name:true};if(!([undefined,null].includes(_this3.model._attachments[_this3.internalName].contentTypeRegularExpressionPattern)||new RegExp(_this3.model._attachments[_this3.internalName].contentTypeRegularExpressionPattern).test(_this3.file.content_type))){if(_this3.model._attachments[_this3.internalName].state.errors)_this3.model._attachments[_this3.internalName].state.errors.contentType=true;else _this3.model._attachments[_this3.internalName].state.errors={contentType:true};_this3.determinePresentationType()}if(_this3.synchronizeImmediately&amp;&amp;!_this3.model._attachments[_this3.internalName].state.errors){let result;const newData={'-type':_this3.model['-type'],_id:_this3.model._id,_attachments:{[_this3.file.name]:{content_type:_this3.file.content_type,data:_this3.file.data}}};if(_this3.synchronizeImmediately!==true)_this3._extendObject(true,newData,_this3.synchronizeImmediately);// NOTE: We want to replace old medium.
if(oldFileName&amp;&amp;oldFileName!==_this3.file.name)newData._attachments[oldFileName]={data:null};if(![undefined,null].includes(_this3.model._rev))newData._rev=_this3.model._rev;if(_this3.mapNameToField){if(_this3.model._id&amp;&amp;_this3.mapNameToField.includes('_id')){newData._deleted=true;try{result=yield _this3._data.put(newData)}catch(error){_this3.model._attachments[_this3.internalName].state.errors={database:'message'in error?error.message:_this3._representObject(error)};return}delete newData._deleted;delete newData._rev}for(const name of _this3.mapNameToField){newData[name]=_this3.file.name;_this3.model[name]=_this3.file.name}}try{result=yield _this3._data.put(newData)}catch(error){_this3.model._attachments[_this3.internalName].state.errors={database:'message'in error?error.message:_this3._representObject(error)};return}_this3.file.revision=_this3.model._rev=result.rev;_this3.file.hash=`#${result.rev}`;_this3.file.source=_this3._domSanitizer.bypassSecurityTrustResourceUrl(_this3._configuration.database.url+`/${_this3._configuration.name}/${_this3.model._id}/`+`${_this3.file.name}${_this3.file.hash}`);_this3.determinePresentationType();_this3.fileChange.emit(_this3.file);_this3.modelChange.emit(_this3.model)}else{_this3.determinePresentationType();const fileReader=new FileReader;fileReader.onload=function(event){_this3.file.source=_this3._domSanitizer.bypassSecurityTrustResourceUrl(event.target.result);if(_this3.mapNameToField)for(const name of _this3.mapNameToField)_this3.model[name]=_this3.file.name;_this3.fileChange.emit(_this3.file);_this3.modelChange.emit(_this3.model)};fileReader.readAsDataURL(_this3.file.data)}}))}/**
     * Determines which type of file we have to present.
     * @returns Nothing.
     */determinePresentationType(){if(this.file&amp;&amp;this.file.content_type&amp;&amp;this.constructor.textMimeTypeRegularExpression.test(this.file.content_type))this.file.type='text';else if(this.file&amp;&amp;this.file.content_type&amp;&amp;this.constructor.imageMimeTypeRegularExpression.test(this.file.content_type))this.file.type='image';else if(this.file&amp;&amp;this.file.content_type&amp;&amp;this.constructor.videoMimeTypeRegularExpression.test(this.file.content_type))this.file.type='video';else this.file.type='binary'}/**
     * Removes current file.
     * @returns A Promise which will be resolved after current file will be
     * removed.
     */remove(){var _this4=this;return _asyncToGenerator(function*(){if(_this4.synchronizeImmediately&amp;&amp;_this4.file){let result;const update={'-type':_this4.model['-type'],_id:_this4.model._id,_rev:_this4.model._rev,_attachments:{[_this4.file.name]:{content_type:'text/plain',data:null}}};if(_this4.mapNameToField&amp;&amp;_this4.mapNameToField.includes('_id'))update._deleted=true;try{result=yield _this4._data.put(update)}catch(error){_this4.model._attachments[_this4.internalName].state.errors={database:_this4._representObject(error)};return}if(_this4.mapNameToField&amp;&amp;_this4.mapNameToField.includes('_id'))_this4.delete.emit(result);else _this4.model._rev=result.rev}_this4.model._attachments[_this4.internalName].state.errors=_this4.model._attachments[_this4.internalName].value=_this4.file=null;if(!_this4.model._attachments[_this4.internalName].nullable)_this4.model._attachments[_this4.internalName].state.errors={required:true};_this4.fileChange.emit(_this4.file);_this4.modelChange.emit(_this4.model)})()}},_class34.imageMimeTypeRegularExpression=new RegExp('^image/(?:p?jpe?g|png|svg(?:\\+xml)?|vnd\\.microsoft\\.icon|gif|'+'tiff|webp|vnd\\.wap\\.wbmp|x-(?:icon|jng|ms-bmp))$'),_class34.textMimeTypeRegularExpression=new RegExp('^(?:application/xml)|(?:text/(?:plain|x-ndpb[wy]html|(?:x-)?csv))$'),_class34.videoMimeTypeRegularExpression=new RegExp('^video/(?:(?:x-)?(?:x-)?webm|3gpp|mp2t|mp4|mpeg|quicktime|'+'(?:x-)?flv|(?:x-)?m4v|(?:x-)mng|x-ms-as|x-ms-wmv|x-msvideo)|'+'(?:application/(?:x-)?shockwave-flash)$'),_temp2),(_descriptor5=_applyDecoratedDescriptor(_class33.prototype,'delete',[_dec26],{enumerable:true,initializer:function(){return new _core.EventEmitter}}),_descriptor6=_applyDecoratedDescriptor(_class33.prototype,'fileChange',[_dec27],{enumerable:true,initializer:function(){return new _core.EventEmitter}}),_descriptor7=_applyDecoratedDescriptor(_class33.prototype,'input',[_dec28],{enumerable:true,initializer:function(){return this.input}}),_descriptor8=_applyDecoratedDescriptor(_class33.prototype,'mapNameToField',[_dec29],{enumerable:true,initializer:function(){return null}}),_descriptor9=_applyDecoratedDescriptor(_class33.prototype,'model',[_dec30],{enumerable:true,initializer:function(){return{_attachments:[],id:null}}}),_descriptor10=_applyDecoratedDescriptor(_class33.prototype,'modelChange',[_dec31],{enumerable:true,initializer:function(){return new _core.EventEmitter}}),_descriptor11=_applyDecoratedDescriptor(_class33.prototype,'name',[_dec32],{enumerable:true,initializer:function(){return null}}),_descriptor12=_applyDecoratedDescriptor(_class33.prototype,'showValidationErrorMessages',[_dec33],{enumerable:true,initializer:function(){return false}}),_descriptor13=_applyDecoratedDescriptor(_class33.prototype,'synchronizeImmediately',[_dec34],{enumerable:true,initializer:function(){return false}})),_class33))||_class32);// / endregion
// / region pagination
/* eslint-disable max-len */// IgnoreTypeCheck
Reflect.defineMetadata('design:paramtypes',[GenericDataService,_platformBrowser.DomSanitizer,GenericExtendObjectPipe,GenericGetFilenameByPrefixPipe,GenericInitialDataService,GenericRepresentObjectPipe],GenericFileInputComponent);/* eslint-enable max-len *//**
 * Provides a generic pagination component.
 * @property _makeRange - Saves the make range pipe transformation function.
 * @property itemsPerPage - Number of items to show per page as maximum.
 * @property page - Contains currently selected page number.
 * @property pageChange - Event emitter to fire on each page change event.
 * @property pageRangeLimit - Number of concrete page links to show.
 * @property total - Contains total number of pages.
 */let GenericPaginationComponent=exports.GenericPaginationComponent=(_dec35=(0,_core.Component)({selector:'generic-pagination',template:`
        &lt;ul *ngIf="lastPage > 1">
            &lt;li *ngIf="page > 2">
                &lt;a href="" (click)="change($event, 1)">--&lt;/a>
            &lt;/li>
            &lt;li *ngIf="page > 1">
                &lt;a href="" (click)="change($event, previousPage)">-&lt;/a>
            &lt;/li>
            &lt;li *ngFor="let currentPage of pagesRange;let even = even">
                &lt;a
                    href="" class="page-{{currentPage}}"
                    [ngClass]="{current: currentPage === page, previous: currentPage === previousPage, next: currentPage === nextPage, even: even, 'even-page': currentPage % 2 === 0, first: currentPage === firstPage, last: currentPage === lastPage}"
                    (click)="change($event, currentPage)"
                >{{currentPage}}&lt;/a>
            &lt;/li>
            &lt;li *ngIf="lastPage > page">
                &lt;a href="" (click)="change($event, nextPage)">+&lt;/a>
            &lt;/li>
            &lt;li *ngIf="lastPage > page + 1">
                &lt;a href="" (click)="change($event, lastPage)">++&lt;/a>
            &lt;/li>
        &lt;/ul>
    `}),_dec36=(0,_core.Input)(),_dec37=(0,_core.Input)(),_dec38=(0,_core.Output)(),_dec39=(0,_core.Input)(),_dec40=(0,_core.Input)(),_dec35(_class35=(_class36=class GenericPaginationComponent{/**
     * Sets needed services as property values.
     * @param makeRange - Saves the make range pipe instance.
     * @returns Nothing.
     */constructor(makeRange){this._makeRange=this._makeRange;_initDefineProp(this,'itemsPerPage',_descriptor14,this);_initDefineProp(this,'page',_descriptor15,this);_initDefineProp(this,'pageChange',_descriptor16,this);_initDefineProp(this,'pageRangeLimit',_descriptor17,this);_initDefineProp(this,'total',_descriptor18,this);this._makeRange=makeRange.transform.bind(makeRange)}/**
     * Is called whenever a page change should be performed.
     * @param event - The responsible event.
     * @param newPage - New page number to change to.
     * @returns Nothing.
     */change(event,newPage){event.preventDefault();this.page=newPage;this.pageChange.emit(this.page)}/**
     * Determines the highest page number.
     * @returns The determines page number.
     */get lastPage(){return Math.ceil(this.total/this.itemsPerPage)}/**
     * Retrieves the next or last (if last is current) page.
     * @returns The new determined page number.
     */get nextPage(){return Math.min(this.page+1,this.lastPage)}/**
     * Determines the number of pages to show.
     * @returns A list of page numbers.
     */get pagesRange(){if(this.page-this.pageRangeLimit&lt;1){const start=1;const startRest=this.pageRangeLimit-(this.page-start);const end=Math.min(this.lastPage,this.page+this.pageRangeLimit+startRest);return this._makeRange([start,end])}const end=Math.min(this.lastPage,this.page+this.pageRangeLimit);const endRest=this.pageRangeLimit-(end-this.page);const start=Math.max(1,this.page-this.pageRangeLimit-endRest);return this._makeRange([start,end])}/**
     * Determines the previous or first (if first is current) page.
     * @returns The previous determined page number.
     */get previousPage(){return Math.max(1,this.page-1)}},(_descriptor14=_applyDecoratedDescriptor(_class36.prototype,'itemsPerPage',[_dec36],{enumerable:true,initializer:function(){return 20}}),_descriptor15=_applyDecoratedDescriptor(_class36.prototype,'page',[_dec37],{enumerable:true,initializer:function(){return 1}}),_descriptor16=_applyDecoratedDescriptor(_class36.prototype,'pageChange',[_dec38],{enumerable:true,initializer:function(){return new _core.EventEmitter}}),_descriptor17=_applyDecoratedDescriptor(_class36.prototype,'pageRangeLimit',[_dec39],{enumerable:true,initializer:function(){return 4}}),_descriptor18=_applyDecoratedDescriptor(_class36.prototype,'total',[_dec40],{enumerable:true,initializer:function(){return 0}})),_class36))||_class35);// / endregion
// endregion
// region modules
Reflect.defineMetadata('design:paramtypes',[GenericArrayMakeRangePipe],GenericPaginationComponent);const declarations=Object.keys(module.exports).filter(name=>!name.startsWith('Abstract')&amp;&amp;(name.endsWith('Component')||name.endsWith('Pipe'))).map(name=>module.exports[name]);const providers=Object.keys(module.exports).filter(name=>!name.startsWith('Abstract')&amp;&amp;(name.endsWith('Resolver')||name.endsWith('Pipe')||name.endsWith('Guard')||name.endsWith('Service'))).map(name=>module.exports[name]);const modules=[_platformBrowser.BrowserModule,_forms.FormsModule,_material.MaterialModule.forRoot()];// IgnoreTypeCheck
/**
 * Represents the importable angular module.
 */let GenericModule=(_dec41=(0,_core.NgModule)({declarations,exports:declarations,imports:modules,providers}),_dec41(_class38=class GenericModule{})||_class38);// endregion
// region vim modline
// vim: set tabstop=4 shiftwidth=4 expandtab:
// vim: foldmethod=marker foldmarker=region,endregion:
// endregion
exports.default=GenericModule;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)(module)))

/***/ }),
/* 3 */,
/* 4 */
/***/ (function(module, exports) {

/*! *****************************************************************************
Copyright (C) Microsoft. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var Reflect;
(function (Reflect) {
    "use strict";
    var hasOwn = Object.prototype.hasOwnProperty;
    // feature test for Object.create support
    var supportsCreate = typeof Object.create === "function";
    // feature test for __proto__ support
    var supportsProto = { __proto__: [] } instanceof Array;
    // feature test for Symbol support
    var supportsSymbol = typeof Symbol === "function";
    var toPrimitiveSymbol = supportsSymbol &amp;&amp; typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
    var iteratorSymbol = supportsSymbol &amp;&amp; typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
    // create an object in dictionary mode (a.k.a. "slow" mode in v8)
    var createDictionary = supportsCreate ? function () { return MakeDictionary(Object.create(null)); } :
        supportsProto ? function () { return MakeDictionary({ __proto__: null }); } :
            function () { return MakeDictionary({}); };
    var HashMap;
    (function (HashMap) {
        var downLevel = !supportsCreate &amp;&amp; !supportsProto;
        HashMap.has = downLevel
            ? function (map, key) { return hasOwn.call(map, key); }
            : function (map, key) { return key in map; };
        HashMap.get = downLevel
            ? function (map, key) { return hasOwn.call(map, key) ? map[key] : undefined; }
            : function (map, key) { return map[key]; };
    })(HashMap || (HashMap = {}));
    // Load global or shim versions of Map, Set, and WeakMap
    var functionPrototype = Object.getPrototypeOf(Function);
    var _Map = typeof Map === "function" &amp;&amp; typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
    var _Set = typeof Set === "function" &amp;&amp; typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
    var _WeakMap = typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
    // [[Metadata]] internal slot
    var Metadata = new _WeakMap();
    /**
      * Applies a set of decorators to a property of a target object.
      * @param decorators An array of decorators.
      * @param target The target object.
      * @param targetKey (Optional) The property key to decorate.
      * @param targetDescriptor (Optional) The property descriptor for the target key
      * @remarks Decorators are applied in reverse order.
      * @example
      *
      *     class Example {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     Example = Reflect.decorate(decoratorsArray, Example);
      *
      *     // property (on constructor)
      *     Reflect.decorate(decoratorsArray, Example, "staticProperty");
      *
      *     // property (on prototype)
      *     Reflect.decorate(decoratorsArray, Example.prototype, "property");
      *
      *     // method (on constructor)
      *     Object.defineProperty(Example, "staticMethod",
      *         Reflect.decorate(decoratorsArray, Example, "staticMethod",
      *             Object.getOwnPropertyDescriptor(Example, "staticMethod")));
      *
      *     // method (on prototype)
      *     Object.defineProperty(Example.prototype, "method",
      *         Reflect.decorate(decoratorsArray, Example.prototype, "method",
      *             Object.getOwnPropertyDescriptor(Example.prototype, "method")));
      *
      */
    function decorate(decorators, target, targetKey, targetDescriptor) {
        if (!IsUndefined(targetKey)) {
            if (!IsArray(decorators))
                throw new TypeError();
            if (!IsObject(target))
                throw new TypeError();
            if (!IsObject(targetDescriptor) &amp;&amp; !IsUndefined(targetDescriptor) &amp;&amp; !IsNull(targetDescriptor))
                throw new TypeError();
            if (IsNull(targetDescriptor))
                targetDescriptor = undefined;
            targetKey = ToPropertyKey(targetKey);
            return DecorateProperty(decorators, target, targetKey, targetDescriptor);
        }
        else {
            if (!IsArray(decorators))
                throw new TypeError();
            if (!IsConstructor(target))
                throw new TypeError();
            return DecorateConstructor(decorators, target);
        }
    }
    Reflect.decorate = decorate;
    /**
      * A default metadata decorator factory that can be used on a class, class member, or parameter.
      * @param metadataKey The key for the metadata entry.
      * @param metadataValue The value for the metadata entry.
      * @returns A decorator function.
      * @remarks
      * If `metadataKey` is already defined for the target and target key, the
      * metadataValue for that key will be overwritten.
      * @example
      *
      *     // constructor
      *     @Reflect.metadata(key, value)
      *     class Example {
      *     }
      *
      *     // property (on constructor, TypeScript only)
      *     class Example {
      *         @Reflect.metadata(key, value)
      *         static staticProperty;
      *     }
      *
      *     // property (on prototype, TypeScript only)
      *     class Example {
      *         @Reflect.metadata(key, value)
      *         property;
      *     }
      *
      *     // method (on constructor)
      *     class Example {
      *         @Reflect.metadata(key, value)
      *         static staticMethod() { }
      *     }
      *
      *     // method (on prototype)
      *     class Example {
      *         @Reflect.metadata(key, value)
      *         method() { }
      *     }
      *
      */
    function metadata(metadataKey, metadataValue) {
        function decorator(target, targetKey) {
            if (!IsUndefined(targetKey)) {
                if (!IsObject(target))
                    throw new TypeError();
                targetKey = ToPropertyKey(targetKey);
                OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, targetKey);
            }
            else {
                if (!IsConstructor(target))
                    throw new TypeError();
                OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, /*targetKey*/ undefined);
            }
        }
        return decorator;
    }
    Reflect.metadata = metadata;
    /**
      * Define a unique metadata entry on the target.
      * @param metadataKey A key used to store and retrieve metadata.
      * @param metadataValue A value that contains attached metadata.
      * @param target The target object on which to define metadata.
      * @param targetKey (Optional) The property key for the target.
      * @example
      *
      *     class Example {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     Reflect.defineMetadata("custom:annotation", options, Example);
      *
      *     // property (on constructor)
      *     Reflect.defineMetadata("custom:annotation", options, Example, "staticProperty");
      *
      *     // property (on prototype)
      *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "property");
      *
      *     // method (on constructor)
      *     Reflect.defineMetadata("custom:annotation", options, Example, "staticMethod");
      *
      *     // method (on prototype)
      *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "method");
      *
      *     // decorator factory as metadata-producing annotation.
      *     function MyAnnotation(options): Decorator {
      *         return (target, key?) => Reflect.defineMetadata("custom:annotation", options, target, key);
      *     }
      *
      */
    function defineMetadata(metadataKey, metadataValue, target, targetKey) {
        if (!IsObject(target))
            throw new TypeError();
        if (!IsUndefined(targetKey))
            targetKey = ToPropertyKey(targetKey);
        return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, targetKey);
    }
    Reflect.defineMetadata = defineMetadata;
    /**
      * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.
      * @param metadataKey A key used to store and retrieve metadata.
      * @param target The target object on which the metadata is defined.
      * @param targetKey (Optional) The property key for the target.
      * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.
      * @example
      *
      *     class Example {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     result = Reflect.hasMetadata("custom:annotation", Example);
      *
      *     // property (on constructor)
      *     result = Reflect.hasMetadata("custom:annotation", Example, "staticProperty");
      *
      *     // property (on prototype)
      *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "property");
      *
      *     // method (on constructor)
      *     result = Reflect.hasMetadata("custom:annotation", Example, "staticMethod");
      *
      *     // method (on prototype)
      *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "method");
      *
      */
    function hasMetadata(metadataKey, target, targetKey) {
        if (!IsObject(target))
            throw new TypeError();
        if (!IsUndefined(targetKey))
            targetKey = ToPropertyKey(targetKey);
        return OrdinaryHasMetadata(metadataKey, target, targetKey);
    }
    Reflect.hasMetadata = hasMetadata;
    /**
      * Gets a value indicating whether the target object has the provided metadata key defined.
      * @param metadataKey A key used to store and retrieve metadata.
      * @param target The target object on which the metadata is defined.
      * @param targetKey (Optional) The property key for the target.
      * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.
      * @example
      *
      *     class Example {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     result = Reflect.hasOwnMetadata("custom:annotation", Example);
      *
      *     // property (on constructor)
      *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticProperty");
      *
      *     // property (on prototype)
      *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "property");
      *
      *     // method (on constructor)
      *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticMethod");
      *
      *     // method (on prototype)
      *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "method");
      *
      */
    function hasOwnMetadata(metadataKey, target, targetKey) {
        if (!IsObject(target))
            throw new TypeError();
        if (!IsUndefined(targetKey))
            targetKey = ToPropertyKey(targetKey);
        return OrdinaryHasOwnMetadata(metadataKey, target, targetKey);
    }
    Reflect.hasOwnMetadata = hasOwnMetadata;
    /**
      * Gets the metadata value for the provided metadata key on the target object or its prototype chain.
      * @param metadataKey A key used to store and retrieve metadata.
      * @param target The target object on which the metadata is defined.
      * @param targetKey (Optional) The property key for the target.
      * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
      * @example
      *
      *     class Example {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     result = Reflect.getMetadata("custom:annotation", Example);
      *
      *     // property (on constructor)
      *     result = Reflect.getMetadata("custom:annotation", Example, "staticProperty");
      *
      *     // property (on prototype)
      *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "property");
      *
      *     // method (on constructor)
      *     result = Reflect.getMetadata("custom:annotation", Example, "staticMethod");
      *
      *     // method (on prototype)
      *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "method");
      *
      */
    function getMetadata(metadataKey, target, targetKey) {
        if (!IsObject(target))
            throw new TypeError();
        if (!IsUndefined(targetKey))
            targetKey = ToPropertyKey(targetKey);
        return OrdinaryGetMetadata(metadataKey, target, targetKey);
    }
    Reflect.getMetadata = getMetadata;
    /**
      * Gets the metadata value for the provided metadata key on the target object.
      * @param metadataKey A key used to store and retrieve metadata.
      * @param target The target object on which the metadata is defined.
      * @param targetKey (Optional) The property key for the target.
      * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
      * @example
      *
      *     class Example {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     result = Reflect.getOwnMetadata("custom:annotation", Example);
      *
      *     // property (on constructor)
      *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticProperty");
      *
      *     // property (on prototype)
      *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "property");
      *
      *     // method (on constructor)
      *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticMethod");
      *
      *     // method (on prototype)
      *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "method");
      *
      */
    function getOwnMetadata(metadataKey, target, targetKey) {
        if (!IsObject(target))
            throw new TypeError();
        if (!IsUndefined(targetKey))
            targetKey = ToPropertyKey(targetKey);
        return OrdinaryGetOwnMetadata(metadataKey, target, targetKey);
    }
    Reflect.getOwnMetadata = getOwnMetadata;
    /**
      * Gets the metadata keys defined on the target object or its prototype chain.
      * @param target The target object on which the metadata is defined.
      * @param targetKey (Optional) The property key for the target.
      * @returns An array of unique metadata keys.
      * @example
      *
      *     class Example {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     result = Reflect.getMetadataKeys(Example);
      *
      *     // property (on constructor)
      *     result = Reflect.getMetadataKeys(Example, "staticProperty");
      *
      *     // property (on prototype)
      *     result = Reflect.getMetadataKeys(Example.prototype, "property");
      *
      *     // method (on constructor)
      *     result = Reflect.getMetadataKeys(Example, "staticMethod");
      *
      *     // method (on prototype)
      *     result = Reflect.getMetadataKeys(Example.prototype, "method");
      *
      */
    function getMetadataKeys(target, targetKey) {
        if (!IsObject(target))
            throw new TypeError();
        if (!IsUndefined(targetKey))
            targetKey = ToPropertyKey(targetKey);
        return OrdinaryMetadataKeys(target, targetKey);
    }
    Reflect.getMetadataKeys = getMetadataKeys;
    /**
      * Gets the unique metadata keys defined on the target object.
      * @param target The target object on which the metadata is defined.
      * @param targetKey (Optional) The property key for the target.
      * @returns An array of unique metadata keys.
      * @example
      *
      *     class Example {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     result = Reflect.getOwnMetadataKeys(Example);
      *
      *     // property (on constructor)
      *     result = Reflect.getOwnMetadataKeys(Example, "staticProperty");
      *
      *     // property (on prototype)
      *     result = Reflect.getOwnMetadataKeys(Example.prototype, "property");
      *
      *     // method (on constructor)
      *     result = Reflect.getOwnMetadataKeys(Example, "staticMethod");
      *
      *     // method (on prototype)
      *     result = Reflect.getOwnMetadataKeys(Example.prototype, "method");
      *
      */
    function getOwnMetadataKeys(target, targetKey) {
        if (!IsObject(target))
            throw new TypeError();
        if (!IsUndefined(targetKey))
            targetKey = ToPropertyKey(targetKey);
        return OrdinaryOwnMetadataKeys(target, targetKey);
    }
    Reflect.getOwnMetadataKeys = getOwnMetadataKeys;
    /**
      * Deletes the metadata entry from the target object with the provided key.
      * @param metadataKey A key used to store and retrieve metadata.
      * @param target The target object on which the metadata is defined.
      * @param targetKey (Optional) The property key for the target.
      * @returns `true` if the metadata entry was found and deleted; otherwise, false.
      * @example
      *
      *     class Example {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     result = Reflect.deleteMetadata("custom:annotation", Example);
      *
      *     // property (on constructor)
      *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticProperty");
      *
      *     // property (on prototype)
      *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "property");
      *
      *     // method (on constructor)
      *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticMethod");
      *
      *     // method (on prototype)
      *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "method");
      *
      */
    function deleteMetadata(metadataKey, target, targetKey) {
        // https://github.com/rbuckton/ReflectDecorators/blob/master/spec/metadata.md#deletemetadata-metadatakey-p-
        if (!IsObject(target))
            throw new TypeError();
        if (!IsUndefined(targetKey))
            targetKey = ToPropertyKey(targetKey);
        var metadataMap = GetOrCreateMetadataMap(target, targetKey, /*create*/ false);
        if (IsUndefined(metadataMap))
            return false;
        if (!metadataMap.delete(metadataKey))
            return false;
        if (metadataMap.size > 0)
            return true;
        var targetMetadata = Metadata.get(target);
        targetMetadata.delete(targetKey);
        if (targetMetadata.size > 0)
            return true;
        Metadata.delete(target);
        return true;
    }
    Reflect.deleteMetadata = deleteMetadata;
    function DecorateConstructor(decorators, target) {
        for (var i = decorators.length - 1; i >= 0; --i) {
            var decorator = decorators[i];
            var decorated = decorator(target);
            if (!IsUndefined(decorated) &amp;&amp; !IsNull(decorated)) {
                if (!IsConstructor(decorated))
                    throw new TypeError();
                target = decorated;
            }
        }
        return target;
    }
    function DecorateProperty(decorators, target, propertyKey, descriptor) {
        for (var i = decorators.length - 1; i >= 0; --i) {
            var decorator = decorators[i];
            var decorated = decorator(target, propertyKey, descriptor);
            if (!IsUndefined(decorated) &amp;&amp; !IsNull(decorated)) {
                if (!IsObject(decorated))
                    throw new TypeError();
                descriptor = decorated;
            }
        }
        return descriptor;
    }
    function GetOrCreateMetadataMap(O, P, Create) {
        var targetMetadata = Metadata.get(O);
        if (IsUndefined(targetMetadata)) {
            if (!Create)
                return undefined;
            targetMetadata = new _Map();
            Metadata.set(O, targetMetadata);
        }
        var metadataMap = targetMetadata.get(P);
        if (IsUndefined(metadataMap)) {
            if (!Create)
                return undefined;
            metadataMap = new _Map();
            targetMetadata.set(P, metadataMap);
        }
        return metadataMap;
    }
    // Ordinary Object Internal Methods and Internal Slots
    // https://github.com/rbuckton/ReflectDecorators/blob/master/spec/metadata.md#ordinary-object-internal-methods-and-internal-slots
    // OrdinaryHasMetadata(MetadataKey, O, P)
    // https://github.com/rbuckton/ReflectDecorators/blob/master/spec/metadata.md#ordinaryhasmetadata--metadatakey-o-p-
    function OrdinaryHasMetadata(MetadataKey, O, P) {
        var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
        if (hasOwn)
            return true;
        var parent = OrdinaryGetPrototypeOf(O);
        if (!IsNull(parent))
            return OrdinaryHasMetadata(MetadataKey, parent, P);
        return false;
    }
    // OrdinaryHasOwnMetadata(MetadataKey, O, P)
    // https://github.com/rbuckton/ReflectDecorators/blob/master/spec/metadata.md#ordinaryhasownmetadata--metadatakey-o-p-
    function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
        var metadataMap = GetOrCreateMetadataMap(O, P, /*create*/ false);
        if (IsUndefined(metadataMap))
            return false;
        return ToBoolean(metadataMap.has(MetadataKey));
    }
    // OrdinaryGetMetadata(MetadataKey, O, P)
    // https://github.com/rbuckton/ReflectDecorators/blob/master/spec/metadata.md#ordinarygetmetadata--metadatakey-o-p-
    function OrdinaryGetMetadata(MetadataKey, O, P) {
        var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
        if (hasOwn)
            return OrdinaryGetOwnMetadata(MetadataKey, O, P);
        var parent = OrdinaryGetPrototypeOf(O);
        if (!IsNull(parent))
            return OrdinaryGetMetadata(MetadataKey, parent, P);
        return undefined;
    }
    // OrdinaryGetOwnMetadata(MetadataKey, O, P)
    // https://github.com/rbuckton/ReflectDecorators/blob/master/spec/metadata.md#ordinarygetownmetadata--metadatakey-o-p-
    function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
        var metadataMap = GetOrCreateMetadataMap(O, P, /*create*/ false);
        if (IsUndefined(metadataMap))
            return undefined;
        return metadataMap.get(MetadataKey);
    }
    // OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P)
    // https://github.com/rbuckton/ReflectDecorators/blob/master/spec/metadata.md#ordinarydefineownmetadata--metadatakey-metadatavalue-o-p-
    function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
        var metadataMap = GetOrCreateMetadataMap(O, P, /*create*/ true);
        metadataMap.set(MetadataKey, MetadataValue);
    }
    // OrdinaryMetadataKeys(O, P)
    // https://github.com/rbuckton/ReflectDecorators/blob/master/spec/metadata.md#ordinarymetadatakeys--o-p-
    function OrdinaryMetadataKeys(O, P) {
        var ownKeys = OrdinaryOwnMetadataKeys(O, P);
        var parent = OrdinaryGetPrototypeOf(O);
        if (parent === null)
            return ownKeys;
        var parentKeys = OrdinaryMetadataKeys(parent, P);
        if (parentKeys.length &lt;= 0)
            return ownKeys;
        if (ownKeys.length &lt;= 0)
            return parentKeys;
        var set = new _Set();
        var keys = [];
        for (var _i = 0, ownKeys_1 = ownKeys; _i &lt; ownKeys_1.length; _i++) {
            var key = ownKeys_1[_i];
            var hasKey = set.has(key);
            if (!hasKey) {
                set.add(key);
                keys.push(key);
            }
        }
        for (var _a = 0, parentKeys_1 = parentKeys; _a &lt; parentKeys_1.length; _a++) {
            var key = parentKeys_1[_a];
            var hasKey = set.has(key);
            if (!hasKey) {
                set.add(key);
                keys.push(key);
            }
        }
        return keys;
    }
    // OrdinaryOwnMetadataKeys(O, P)
    // https://github.com/rbuckton/ReflectDecorators/blob/master/spec/metadata.md#ordinaryownmetadatakeys--o-p-
    function OrdinaryOwnMetadataKeys(O, P) {
        var metadataMap = GetOrCreateMetadataMap(O, P, /*create*/ false);
        var keys = [];
        if (IsUndefined(metadataMap))
            return keys;
        var keysObj = metadataMap.keys();
        var iterator = GetIterator(keysObj);
        while (true) {
            var next = IteratorStep(iterator);
            try {
                if (!next)
                    return keys;
                var nextValue = IteratorValue(next);
                keys.push(nextValue);
            }
            catch (e) {
                try {
                    if (next) {
                        next = false;
                        IteratorClose(iterator);
                    }
                }
                finally {
                    throw e;
                }
            }
            finally {
                if (next)
                    IteratorClose(iterator);
            }
        }
    }
    // ECMAScript Specification
    // https://tc39.github.io/ecma262/
    // 6 ECMAScript Data Typ0es and Values
    // https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values
    function Type(x) {
        if (x === null)
            return 1 /* Null */;
        switch (typeof x) {
            case "undefined": return 0 /* Undefined */;
            case "boolean": return 2 /* Boolean */;
            case "string": return 3 /* String */;
            case "symbol": return 4 /* Symbol */;
            case "number": return 5 /* Number */;
            case "object": return x === null ? 1 /* Null */ : 6 /* Object */;
            default: return 6 /* Object */;
        }
    }
    // 6.1.1 The Undefined Type
    // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-undefined-type
    function IsUndefined(x) {
        return x === undefined;
    }
    // 6.1.2 The Null Type
    // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-null-type
    function IsNull(x) {
        return x === null;
    }
    // 6.1.5 The Symbol Type
    // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-symbol-type
    function IsSymbol(x) {
        return typeof x === "symbol";
    }
    // 6.1.7 The Object Type
    // https://tc39.github.io/ecma262/#sec-object-type
    function IsObject(x) {
        return typeof x === "object" ? x !== null : typeof x === "function";
    }
    // 7.1 Type Conversion
    // https://tc39.github.io/ecma262/#sec-type-conversion
    // 7.1.1 ToPrimitive(input [, PreferredType])
    // https://tc39.github.io/ecma262/#sec-toprimitive
    function ToPrimitive(input, PreferredType) {
        switch (Type(input)) {
            case 0 /* Undefined */: return input;
            case 1 /* Null */: return input;
            case 2 /* Boolean */: return input;
            case 3 /* String */: return input;
            case 4 /* Symbol */: return input;
            case 5 /* Number */: return input;
        }
        var hint = PreferredType === 3 /* String */ ? "string" : PreferredType === 5 /* Number */ ? "number" : "default";
        var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
        if (exoticToPrim !== undefined) {
            var result = exoticToPrim.call(input, hint);
            if (IsObject(result))
                throw new TypeError();
            return result;
        }
        return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
    }
    // 7.1.1.1 OrdinaryToPrimitive(O, hint)
    // https://tc39.github.io/ecma262/#sec-ordinarytoprimitive
    function OrdinaryToPrimitive(O, hint) {
        if (hint === "string") {
            var toString_1 = O.toString;
            if (IsCallable(toString_1)) {
                var result = toString_1.call(O);
                if (!IsObject(result))
                    return result;
            }
            var valueOf = O.valueOf;
            if (IsCallable(valueOf)) {
                var result = valueOf.call(O);
                if (!IsObject(result))
                    return result;
            }
        }
        else {
            var valueOf = O.valueOf;
            if (IsCallable(valueOf)) {
                var result = valueOf.call(O);
                if (!IsObject(result))
                    return result;
            }
            var toString_2 = O.toString;
            if (IsCallable(toString_2)) {
                var result = toString_2.call(O);
                if (!IsObject(result))
                    return result;
            }
        }
        throw new TypeError();
    }
    // 7.1.2 ToBoolean(argument)
    // https://tc39.github.io/ecma262/2016/#sec-toboolean
    function ToBoolean(argument) {
        return !!argument;
    }
    // 7.1.12 ToString(argument)
    // https://tc39.github.io/ecma262/#sec-tostring
    function ToString(argument) {
        return "" + argument;
    }
    // 7.1.14 ToPropertyKey(argument)
    // https://tc39.github.io/ecma262/#sec-topropertykey
    function ToPropertyKey(argument) {
        var key = ToPrimitive(argument, 3 /* String */);
        if (IsSymbol(key))
            return key;
        return ToString(key);
    }
    // 7.2 Testing and Comparison Operations
    // https://tc39.github.io/ecma262/#sec-testing-and-comparison-operations
    // 7.2.2 IsArray(argument)
    // https://tc39.github.io/ecma262/#sec-isarray
    function IsArray(argument) {
        return Array.isArray
            ? Array.isArray(argument)
            : argument instanceof Object
                ? argument instanceof Array
                : Object.prototype.toString.call(argument) === "[object Array]";
    }
    // 7.2.3 IsCallable(argument)
    // https://tc39.github.io/ecma262/#sec-iscallable
    function IsCallable(argument) {
        // NOTE: This is an approximation as we cannot check for [[Call]] internal method.
        return typeof argument === "function";
    }
    // 7.2.4 IsConstructor(argument)
    // https://tc39.github.io/ecma262/#sec-isconstructor
    function IsConstructor(argument) {
        // NOTE: This is an approximation as we cannot check for [[Construct]] internal method.
        return typeof argument === "function";
    }
    // 7.3 Operations on Objects
    // https://tc39.github.io/ecma262/#sec-operations-on-objects
    // 7.3.9 GetMethod(V, P)
    // https://tc39.github.io/ecma262/#sec-getmethod
    function GetMethod(V, P) {
        var func = V[P];
        if (func === undefined || func === null)
            return undefined;
        if (!IsCallable(func))
            throw new TypeError();
        return func;
    }
    // 7.4 Operations on Iterator Objects
    // https://tc39.github.io/ecma262/#sec-operations-on-iterator-objects
    function GetIterator(obj) {
        var method = GetMethod(obj, iteratorSymbol);
        if (!IsCallable(method))
            throw new TypeError(); // from Call
        var iterator = method.call(obj);
        if (!IsObject(iterator))
            throw new TypeError();
        return iterator;
    }
    // 7.4.4 IteratorValue(iterResult)
    // https://tc39.github.io/ecma262/2016/#sec-iteratorvalue
    function IteratorValue(iterResult) {
        return iterResult.value;
    }
    // 7.4.5 IteratorStep(iterator)
    // https://tc39.github.io/ecma262/#sec-iteratorstep
    function IteratorStep(iterator) {
        var result = iterator.next();
        return result.done ? false : result;
    }
    // 7.4.6 IteratorClose(iterator, completion)
    // https://tc39.github.io/ecma262/#sec-iteratorclose
    function IteratorClose(iterator) {
        var f = iterator["return"];
        if (f)
            f.call(iterator);
    }
    // 9.1 Ordinary Object Internal Methods and Internal Slots
    // https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots
    // 9.1.1.1 OrdinaryGetPrototypeOf(O)
    // https://tc39.github.io/ecma262/#sec-ordinarygetprototypeof
    function OrdinaryGetPrototypeOf(O) {
        var proto = Object.getPrototypeOf(O);
        if (typeof O !== "function" || O === functionPrototype)
            return proto;
        // TypeScript doesn't set __proto__ in ES5, as it's non-standard.
        // Try to determine the superclass constructor. Compatible implementations
        // must either set __proto__ on a subclass constructor to the superclass constructor,
        // or ensure each class has a valid `constructor` property on its prototype that
        // points back to the constructor.
        // If this is not the same as Function.[[Prototype]], then this is definately inherited.
        // This is the case when in ES6 or when using __proto__ in a compatible browser.
        if (proto !== functionPrototype)
            return proto;
        // If the super prototype is Object.prototype, null, or undefined, then we cannot determine the heritage.
        var prototype = O.prototype;
        var prototypeProto = prototype &amp;&amp; Object.getPrototypeOf(prototype);
        if (prototypeProto == null || prototypeProto === Object.prototype)
            return proto;
        // If the constructor was not a function, then we cannot determine the heritage.
        var constructor = prototypeProto.constructor;
        if (typeof constructor !== "function")
            return proto;
        // If we have some kind of self-reference, then we cannot determine the heritage.
        if (constructor === O)
            return proto;
        // we have a pretty good guess at the heritage.
        return constructor;
    }
    // naive Map shim
    function CreateMapPolyfill() {
        var cacheSentinel = {};
        var arraySentinel = [];
        var MapIterator = (function () {
            function MapIterator(keys, values, selector) {
                this._index = 0;
                this._keys = keys;
                this._values = values;
                this._selector = selector;
            }
            MapIterator.prototype["@@iterator"] = function () { return this; };
            MapIterator.prototype[iteratorSymbol] = function () { return this; };
            MapIterator.prototype.next = function () {
                var index = this._index;
                if (index >= 0 &amp;&amp; index &lt; this._keys.length) {
                    var result = this._selector(this._keys[index], this._values[index]);
                    if (index + 1 >= this._keys.length) {
                        this._index = -1;
                        this._keys = arraySentinel;
                        this._values = arraySentinel;
                    }
                    else {
                        this._index++;
                    }
                    return { value: result, done: false };
                }
                return { value: undefined, done: true };
            };
            MapIterator.prototype.throw = function (error) {
                if (this._index >= 0) {
                    this._index = -1;
                    this._keys = arraySentinel;
                    this._values = arraySentinel;
                }
                throw error;
            };
            MapIterator.prototype.return = function (value) {
                if (this._index >= 0) {
                    this._index = -1;
                    this._keys = arraySentinel;
                    this._values = arraySentinel;
                }
                return { value: value, done: true };
            };
            return MapIterator;
        }());
        return (function () {
            function Map() {
                this._keys = [];
                this._values = [];
                this._cacheKey = cacheSentinel;
                this._cacheIndex = -2;
            }
            Object.defineProperty(Map.prototype, "size", {
                get: function () { return this._keys.length; },
                enumerable: true,
                configurable: true
            });
            Map.prototype.has = function (key) { return this._find(key, /*insert*/ false) >= 0; };
            Map.prototype.get = function (key) {
                var index = this._find(key, /*insert*/ false);
                return index >= 0 ? this._values[index] : undefined;
            };
            Map.prototype.set = function (key, value) {
                var index = this._find(key, /*insert*/ true);
                this._values[index] = value;
                return this;
            };
            Map.prototype.delete = function (key) {
                var index = this._find(key, /*insert*/ false);
                if (index >= 0) {
                    var size = this._keys.length;
                    for (var i = index + 1; i &lt; size; i++) {
                        this._keys[i - 1] = this._keys[i];
                        this._values[i - 1] = this._values[i];
                    }
                    this._keys.length--;
                    this._values.length--;
                    if (key === this._cacheKey) {
                        this._cacheKey = cacheSentinel;
                        this._cacheIndex = -2;
                    }
                    return true;
                }
                return false;
            };
            Map.prototype.clear = function () {
                this._keys.length = 0;
                this._values.length = 0;
                this._cacheKey = cacheSentinel;
                this._cacheIndex = -2;
            };
            Map.prototype.keys = function () { return new MapIterator(this._keys, this._values, getKey); };
            Map.prototype.values = function () { return new MapIterator(this._keys, this._values, getValue); };
            Map.prototype.entries = function () { return new MapIterator(this._keys, this._values, getEntry); };
            Map.prototype["@@iterator"] = function () { return this.entries(); };
            Map.prototype[iteratorSymbol] = function () { return this.entries(); };
            Map.prototype._find = function (key, insert) {
                if (this._cacheKey === key)
                    return this._cacheIndex;
                var index = this._keys.indexOf(key);
                if (index &lt; 0 &amp;&amp; insert) {
                    index = this._keys.length;
                    this._keys.push(key);
                    this._values.push(undefined);
                }
                return this._cacheKey = key, this._cacheIndex = index;
            };
            return Map;
        }());
        function getKey(key, _) {
            return key;
        }
        function getValue(_, value) {
            return value;
        }
        function getEntry(key, value) {
            return [key, value];
        }
    }
    // naive Set shim
    function CreateSetPolyfill() {
        return (function () {
            function Set() {
                this._map = new _Map();
            }
            Object.defineProperty(Set.prototype, "size", {
                get: function () { return this._map.size; },
                enumerable: true,
                configurable: true
            });
            Set.prototype.has = function (value) { return this._map.has(value); };
            Set.prototype.add = function (value) { return this._map.set(value, value), this; };
            Set.prototype.delete = function (value) { return this._map.delete(value); };
            Set.prototype.clear = function () { this._map.clear(); };
            Set.prototype.keys = function () { return this._map.keys(); };
            Set.prototype.values = function () { return this._map.values(); };
            Set.prototype.entries = function () { return this._map.entries(); };
            Set.prototype["@@iterator"] = function () { return this.keys(); };
            Set.prototype[iteratorSymbol] = function () { return this.keys(); };
            return Set;
        }());
    }
    // naive WeakMap shim
    function CreateWeakMapPolyfill() {
        var UUID_SIZE = 16;
        var keys = createDictionary();
        var rootKey = CreateUniqueKey();
        return (function () {
            function WeakMap() {
                this._key = CreateUniqueKey();
            }
            WeakMap.prototype.has = function (target) {
                var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                return table !== undefined ? HashMap.has(table, this._key) : false;
            };
            WeakMap.prototype.get = function (target) {
                var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                return table !== undefined ? HashMap.get(table, this._key) : undefined;
            };
            WeakMap.prototype.set = function (target, value) {
                var table = GetOrCreateWeakMapTable(target, /*create*/ true);
                table[this._key] = value;
                return this;
            };
            WeakMap.prototype.delete = function (target) {
                var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                return table !== undefined ? delete table[this._key] : false;
            };
            WeakMap.prototype.clear = function () {
                // NOTE: not a real clear, just makes the previous data unreachable
                this._key = CreateUniqueKey();
            };
            return WeakMap;
        }());
        function CreateUniqueKey() {
            var key;
            do
                key = "@@WeakMap@@" + CreateUUID();
            while (HashMap.has(keys, key));
            keys[key] = true;
            return key;
        }
        function GetOrCreateWeakMapTable(target, create) {
            if (!hasOwn.call(target, rootKey)) {
                if (!create)
                    return undefined;
                Object.defineProperty(target, rootKey, { value: createDictionary() });
            }
            return target[rootKey];
        }
        function FillRandomBytes(buffer, size) {
            for (var i = 0; i &lt; size; ++i)
                buffer[i] = Math.random() * 0xff | 0;
            return buffer;
        }
        function GenRandomBytes(size) {
            if (typeof Uint8Array === "function") {
                if (typeof crypto !== "undefined")
                    return crypto.getRandomValues(new Uint8Array(size));
                if (typeof msCrypto !== "undefined")
                    return msCrypto.getRandomValues(new Uint8Array(size));
                return FillRandomBytes(new Uint8Array(size), size);
            }
            return FillRandomBytes(new Array(size), size);
        }
        function CreateUUID() {
            var data = GenRandomBytes(UUID_SIZE);
            // mark as random - RFC 4122 § 4.4
            data[6] = data[6] &amp; 0x4f | 0x40;
            data[8] = data[8] &amp; 0xbf | 0x80;
            var result = "";
            for (var offset = 0; offset &lt; UUID_SIZE; ++offset) {
                var byte = data[offset];
                if (offset === 4 || offset === 6 || offset === 8)
                    result += "-";
                if (byte &lt; 16)
                    result += "0";
                result += byte.toString(16).toLowerCase();
            }
            return result;
        }
    }
    // uses a heuristic used by v8 and chakra to force an object into dictionary mode.
    function MakeDictionary(obj) {
        obj.__ = undefined;
        delete obj.__;
        return obj;
    }
    // patch global Reflect
    (function (__global) {
        if (typeof __global.Reflect !== "undefined") {
            if (__global.Reflect !== Reflect) {
                for (var p in Reflect) {
                    if (hasOwn.call(Reflect, p)) {
                        __global.Reflect[p] = Reflect[p];
                    }
                }
            }
        }
        else {
            __global.Reflect = Reflect;
        }
    })(typeof global !== "undefined" ? global :
        typeof self !== "undefined" ? self :
            Function("return this;")());
})(Reflect || (Reflect = {}));
//# sourceMappingURL=Reflect.js.map

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

/**
* @license
* Copyright Google Inc. All Rights Reserved.
*
* Use of this source code is governed by an MIT-style license that can be
* found in the LICENSE file at https://angular.io/license
*/
(function (global, factory) {
     true ? factory() :
    typeof define === 'function' &amp;&amp; define.amd ? define(factory) :
    (factory());
}(this, (function () { 'use strict';

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */


var Zone$1 = (function (global) {
    if (global['Zone']) {
        throw new Error('Zone already loaded.');
    }
    var Zone = (function () {
        function Zone(parent, zoneSpec) {
            this._properties = null;
            this._parent = parent;
            this._name = zoneSpec ? zoneSpec.name || 'unnamed' : '&lt;root>';
            this._properties = zoneSpec &amp;&amp; zoneSpec.properties || {};
            this._zoneDelegate =
                new ZoneDelegate(this, this._parent &amp;&amp; this._parent._zoneDelegate, zoneSpec);
        }
        Zone.assertZonePatched = function () {
            if (global.Promise !== ZoneAwarePromise) {
                throw new Error('Zone.js has detected that ZoneAwarePromise `(window|global).Promise` ' +
                    'has been overwritten.\n' +
                    'Most likely cause is that a Promise polyfill has been loaded ' +
                    'after Zone.js (Polyfilling Promise api is not necessary when zone.js is loaded. ' +
                    'If you must load one, do so before loading zone.js.)');
            }
        };
        Object.defineProperty(Zone, "current", {
            get: function () {
                return _currentZoneFrame.zone;
            },
            enumerable: true,
            configurable: true
        });
        
        Object.defineProperty(Zone, "currentTask", {
            get: function () {
                return _currentTask;
            },
            enumerable: true,
            configurable: true
        });
        
        Object.defineProperty(Zone.prototype, "parent", {
            get: function () {
                return this._parent;
            },
            enumerable: true,
            configurable: true
        });
        
        Object.defineProperty(Zone.prototype, "name", {
            get: function () {
                return this._name;
            },
            enumerable: true,
            configurable: true
        });
        
        Zone.prototype.get = function (key) {
            var zone = this.getZoneWith(key);
            if (zone)
                return zone._properties[key];
        };
        Zone.prototype.getZoneWith = function (key) {
            var current = this;
            while (current) {
                if (current._properties.hasOwnProperty(key)) {
                    return current;
                }
                current = current._parent;
            }
            return null;
        };
        Zone.prototype.fork = function (zoneSpec) {
            if (!zoneSpec)
                throw new Error('ZoneSpec required!');
            return this._zoneDelegate.fork(this, zoneSpec);
        };
        Zone.prototype.wrap = function (callback, source) {
            if (typeof callback !== 'function') {
                throw new Error('Expecting function got: ' + callback);
            }
            var _callback = this._zoneDelegate.intercept(this, callback, source);
            var zone = this;
            return function () {
                return zone.runGuarded(_callback, this, arguments, source);
            };
        };
        Zone.prototype.run = function (callback, applyThis, applyArgs, source) {
            if (applyThis === void 0) { applyThis = null; }
            if (applyArgs === void 0) { applyArgs = null; }
            if (source === void 0) { source = null; }
            _currentZoneFrame = new ZoneFrame(_currentZoneFrame, this);
            try {
                return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);
            }
            finally {
                _currentZoneFrame = _currentZoneFrame.parent;
            }
        };
        Zone.prototype.runGuarded = function (callback, applyThis, applyArgs, source) {
            if (applyThis === void 0) { applyThis = null; }
            if (applyArgs === void 0) { applyArgs = null; }
            if (source === void 0) { source = null; }
            _currentZoneFrame = new ZoneFrame(_currentZoneFrame, this);
            try {
                try {
                    return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);
                }
                catch (error) {
                    if (this._zoneDelegate.handleError(this, error)) {
                        throw error;
                    }
                }
            }
            finally {
                _currentZoneFrame = _currentZoneFrame.parent;
            }
        };
        Zone.prototype.runTask = function (task, applyThis, applyArgs) {
            task.runCount++;
            if (task.zone != this)
                throw new Error('A task can only be run in the zone which created it! (Creation: ' + task.zone.name +
                    '; Execution: ' + this.name + ')');
            var previousTask = _currentTask;
            _currentTask = task;
            _currentZoneFrame = new ZoneFrame(_currentZoneFrame, this);
            try {
                if (task.type == 'macroTask' &amp;&amp; task.data &amp;&amp; !task.data.isPeriodic) {
                    task.cancelFn = null;
                }
                try {
                    return this._zoneDelegate.invokeTask(this, task, applyThis, applyArgs);
                }
                catch (error) {
                    if (this._zoneDelegate.handleError(this, error)) {
                        throw error;
                    }
                }
            }
            finally {
                _currentZoneFrame = _currentZoneFrame.parent;
                _currentTask = previousTask;
            }
        };
        Zone.prototype.scheduleMicroTask = function (source, callback, data, customSchedule) {
            return this._zoneDelegate.scheduleTask(this, new ZoneTask('microTask', this, source, callback, data, customSchedule, null));
        };
        Zone.prototype.scheduleMacroTask = function (source, callback, data, customSchedule, customCancel) {
            return this._zoneDelegate.scheduleTask(this, new ZoneTask('macroTask', this, source, callback, data, customSchedule, customCancel));
        };
        Zone.prototype.scheduleEventTask = function (source, callback, data, customSchedule, customCancel) {
            return this._zoneDelegate.scheduleTask(this, new ZoneTask('eventTask', this, source, callback, data, customSchedule, customCancel));
        };
        Zone.prototype.cancelTask = function (task) {
            var value = this._zoneDelegate.cancelTask(this, task);
            task.runCount = -1;
            task.cancelFn = null;
            return value;
        };
        return Zone;
    }());
    Zone.__symbol__ = __symbol__;
    
    var ZoneDelegate = (function () {
        function ZoneDelegate(zone, parentDelegate, zoneSpec) {
            this._taskCounts = { microTask: 0, macroTask: 0, eventTask: 0 };
            this.zone = zone;
            this._parentDelegate = parentDelegate;
            this._forkZS = zoneSpec &amp;&amp; (zoneSpec &amp;&amp; zoneSpec.onFork ? zoneSpec : parentDelegate._forkZS);
            this._forkDlgt = zoneSpec &amp;&amp; (zoneSpec.onFork ? parentDelegate : parentDelegate._forkDlgt);
            this._forkCurrZone = zoneSpec &amp;&amp; (zoneSpec.onFork ? this.zone : parentDelegate.zone);
            this._interceptZS =
                zoneSpec &amp;&amp; (zoneSpec.onIntercept ? zoneSpec : parentDelegate._interceptZS);
            this._interceptDlgt =
                zoneSpec &amp;&amp; (zoneSpec.onIntercept ? parentDelegate : parentDelegate._interceptDlgt);
            this._interceptCurrZone =
                zoneSpec &amp;&amp; (zoneSpec.onIntercept ? this.zone : parentDelegate.zone);
            this._invokeZS = zoneSpec &amp;&amp; (zoneSpec.onInvoke ? zoneSpec : parentDelegate._invokeZS);
            this._invokeDlgt =
                zoneSpec &amp;&amp; (zoneSpec.onInvoke ? parentDelegate : parentDelegate._invokeDlgt);
            this._invokeCurrZone = zoneSpec &amp;&amp; (zoneSpec.onInvoke ? this.zone : parentDelegate.zone);
            this._handleErrorZS =
                zoneSpec &amp;&amp; (zoneSpec.onHandleError ? zoneSpec : parentDelegate._handleErrorZS);
            this._handleErrorDlgt =
                zoneSpec &amp;&amp; (zoneSpec.onHandleError ? parentDelegate : parentDelegate._handleErrorDlgt);
            this._handleErrorCurrZone =
                zoneSpec &amp;&amp; (zoneSpec.onHandleError ? this.zone : parentDelegate.zone);
            this._scheduleTaskZS =
                zoneSpec &amp;&amp; (zoneSpec.onScheduleTask ? zoneSpec : parentDelegate._scheduleTaskZS);
            this._scheduleTaskDlgt =
                zoneSpec &amp;&amp; (zoneSpec.onScheduleTask ? parentDelegate : parentDelegate._scheduleTaskDlgt);
            this._scheduleTaskCurrZone =
                zoneSpec &amp;&amp; (zoneSpec.onScheduleTask ? this.zone : parentDelegate.zone);
            this._invokeTaskZS =
                zoneSpec &amp;&amp; (zoneSpec.onInvokeTask ? zoneSpec : parentDelegate._invokeTaskZS);
            this._invokeTaskDlgt =
                zoneSpec &amp;&amp; (zoneSpec.onInvokeTask ? parentDelegate : parentDelegate._invokeTaskDlgt);
            this._invokeTaskCurrZone =
                zoneSpec &amp;&amp; (zoneSpec.onInvokeTask ? this.zone : parentDelegate.zone);
            this._cancelTaskZS =
                zoneSpec &amp;&amp; (zoneSpec.onCancelTask ? zoneSpec : parentDelegate._cancelTaskZS);
            this._cancelTaskDlgt =
                zoneSpec &amp;&amp; (zoneSpec.onCancelTask ? parentDelegate : parentDelegate._cancelTaskDlgt);
            this._cancelTaskCurrZone =
                zoneSpec &amp;&amp; (zoneSpec.onCancelTask ? this.zone : parentDelegate.zone);
            this._hasTaskZS = zoneSpec &amp;&amp; (zoneSpec.onHasTask ? zoneSpec : parentDelegate._hasTaskZS);
            this._hasTaskDlgt =
                zoneSpec &amp;&amp; (zoneSpec.onHasTask ? parentDelegate : parentDelegate._hasTaskDlgt);
            this._hasTaskCurrZone = zoneSpec &amp;&amp; (zoneSpec.onHasTask ? this.zone : parentDelegate.zone);
        }
        ZoneDelegate.prototype.fork = function (targetZone, zoneSpec) {
            return this._forkZS ? this._forkZS.onFork(this._forkDlgt, this.zone, targetZone, zoneSpec) :
                new Zone(targetZone, zoneSpec);
        };
        ZoneDelegate.prototype.intercept = function (targetZone, callback, source) {
            return this._interceptZS ?
                this._interceptZS.onIntercept(this._interceptDlgt, this._interceptCurrZone, targetZone, callback, source) :
                callback;
        };
        ZoneDelegate.prototype.invoke = function (targetZone, callback, applyThis, applyArgs, source) {
            return this._invokeZS ?
                this._invokeZS.onInvoke(this._invokeDlgt, this._invokeCurrZone, targetZone, callback, applyThis, applyArgs, source) :
                callback.apply(applyThis, applyArgs);
        };
        ZoneDelegate.prototype.handleError = function (targetZone, error) {
            return this._handleErrorZS ?
                this._handleErrorZS.onHandleError(this._handleErrorDlgt, this._handleErrorCurrZone, targetZone, error) :
                true;
        };
        ZoneDelegate.prototype.scheduleTask = function (targetZone, task) {
            try {
                if (this._scheduleTaskZS) {
                    return this._scheduleTaskZS.onScheduleTask(this._scheduleTaskDlgt, this._scheduleTaskCurrZone, targetZone, task);
                }
                else if (task.scheduleFn) {
                    task.scheduleFn(task);
                }
                else if (task.type == 'microTask') {
                    scheduleMicroTask(task);
                }
                else {
                    throw new Error('Task is missing scheduleFn.');
                }
                return task;
            }
            finally {
                if (targetZone == this.zone) {
                    this._updateTaskCount(task.type, 1);
                }
            }
        };
        ZoneDelegate.prototype.invokeTask = function (targetZone, task, applyThis, applyArgs) {
            try {
                return this._invokeTaskZS ?
                    this._invokeTaskZS.onInvokeTask(this._invokeTaskDlgt, this._invokeTaskCurrZone, targetZone, task, applyThis, applyArgs) :
                    task.callback.apply(applyThis, applyArgs);
            }
            finally {
                if (targetZone == this.zone &amp;&amp; (task.type != 'eventTask') &amp;&amp;
                    !(task.data &amp;&amp; task.data.isPeriodic)) {
                    this._updateTaskCount(task.type, -1);
                }
            }
        };
        ZoneDelegate.prototype.cancelTask = function (targetZone, task) {
            var value;
            if (this._cancelTaskZS) {
                value = this._cancelTaskZS.onCancelTask(this._cancelTaskDlgt, this._cancelTaskCurrZone, targetZone, task);
            }
            else if (!task.cancelFn) {
                throw new Error('Task does not support cancellation, or is already canceled.');
            }
            else {
                value = task.cancelFn(task);
            }
            if (targetZone == this.zone) {
                // this should not be in the finally block, because exceptions assume not canceled.
                this._updateTaskCount(task.type, -1);
            }
            return value;
        };
        ZoneDelegate.prototype.hasTask = function (targetZone, isEmpty) {
            return this._hasTaskZS &amp;&amp;
                this._hasTaskZS.onHasTask(this._hasTaskDlgt, this._hasTaskCurrZone, targetZone, isEmpty);
        };
        ZoneDelegate.prototype._updateTaskCount = function (type, count) {
            var counts = this._taskCounts;
            var prev = counts[type];
            var next = counts[type] = prev + count;
            if (next &lt; 0) {
                throw new Error('More tasks executed then were scheduled.');
            }
            if (prev == 0 || next == 0) {
                var isEmpty = {
                    microTask: counts.microTask > 0,
                    macroTask: counts.macroTask > 0,
                    eventTask: counts.eventTask > 0,
                    change: type
                };
                try {
                    this.hasTask(this.zone, isEmpty);
                }
                finally {
                    if (this._parentDelegate) {
                        this._parentDelegate._updateTaskCount(type, count);
                    }
                }
            }
        };
        return ZoneDelegate;
    }());
    var ZoneTask = (function () {
        function ZoneTask(type, zone, source, callback, options, scheduleFn, cancelFn) {
            this.runCount = 0;
            this.type = type;
            this.zone = zone;
            this.source = source;
            this.data = options;
            this.scheduleFn = scheduleFn;
            this.cancelFn = cancelFn;
            this.callback = callback;
            var self = this;
            this.invoke = function () {
                _numberOfNestedTaskFrames++;
                try {
                    return zone.runTask(self, this, arguments);
                }
                finally {
                    if (_numberOfNestedTaskFrames == 1) {
                        drainMicroTaskQueue();
                    }
                    _numberOfNestedTaskFrames--;
                }
            };
        }
        ZoneTask.prototype.toString = function () {
            if (this.data &amp;&amp; typeof this.data.handleId !== 'undefined') {
                return this.data.handleId;
            }
            else {
                return Object.prototype.toString.call(this);
            }
        };
        // add toJSON method to prevent cyclic error when
        // call JSON.stringify(zoneTask)
        ZoneTask.prototype.toJSON = function () {
            return {
                type: this.type,
                source: this.source,
                data: this.data,
                zone: this.zone.name,
                invoke: this.invoke,
                scheduleFn: this.scheduleFn,
                cancelFn: this.cancelFn,
                runCount: this.runCount,
                callback: this.callback
            };
        };
        return ZoneTask;
    }());
    var ZoneFrame = (function () {
        function ZoneFrame(parent, zone) {
            this.parent = parent;
            this.zone = zone;
        }
        return ZoneFrame;
    }());
    function __symbol__(name) {
        return '__zone_symbol__' + name;
    }
    
    var symbolSetTimeout = __symbol__('setTimeout');
    var symbolPromise = __symbol__('Promise');
    var symbolThen = __symbol__('then');
    var _currentZoneFrame = new ZoneFrame(null, new Zone(null, null));
    var _currentTask = null;
    var _microTaskQueue = [];
    var _isDrainingMicrotaskQueue = false;
    var _uncaughtPromiseErrors = [];
    var _numberOfNestedTaskFrames = 0;
    function scheduleQueueDrain() {
        // if we are not running in any task, and there has not been anything scheduled
        // we must bootstrap the initial task creation by manually scheduling the drain
        if (_numberOfNestedTaskFrames === 0 &amp;&amp; _microTaskQueue.length === 0) {
            // We are not running in Task, so we need to kickstart the microtask queue.
            if (global[symbolPromise]) {
                global[symbolPromise].resolve(0)[symbolThen](drainMicroTaskQueue);
            }
            else {
                global[symbolSetTimeout](drainMicroTaskQueue, 0);
            }
        }
    }
    function scheduleMicroTask(task) {
        scheduleQueueDrain();
        _microTaskQueue.push(task);
    }
    function consoleError(e) {
        var rejection = e &amp;&amp; e.rejection;
        if (rejection) {
            console.error('Unhandled Promise rejection:', rejection instanceof Error ? rejection.message : rejection, '; Zone:', e.zone.name, '; Task:', e.task &amp;&amp; e.task.source, '; Value:', rejection, rejection instanceof Error ? rejection.stack : undefined);
        }
        console.error(e);
    }
    function drainMicroTaskQueue() {
        if (!_isDrainingMicrotaskQueue) {
            _isDrainingMicrotaskQueue = true;
            while (_microTaskQueue.length) {
                var queue = _microTaskQueue;
                _microTaskQueue = [];
                for (var i = 0; i &lt; queue.length; i++) {
                    var task = queue[i];
                    try {
                        task.zone.runTask(task, null, null);
                    }
                    catch (e) {
                        consoleError(e);
                    }
                }
            }
            while (_uncaughtPromiseErrors.length) {
                var _loop_1 = function () {
                    var uncaughtPromiseError = _uncaughtPromiseErrors.shift();
                    try {
                        uncaughtPromiseError.zone.runGuarded(function () {
                            throw uncaughtPromiseError;
                        });
                    }
                    catch (e) {
                        consoleError(e);
                    }
                };
                while (_uncaughtPromiseErrors.length) {
                    _loop_1();
                }
            }
            _isDrainingMicrotaskQueue = false;
        }
    }
    function isThenable(value) {
        return value &amp;&amp; value.then;
    }
    function forwardResolution(value) {
        return value;
    }
    function forwardRejection(rejection) {
        return ZoneAwarePromise.reject(rejection);
    }
    var symbolState = __symbol__('state');
    var symbolValue = __symbol__('value');
    var source = 'Promise.then';
    var UNRESOLVED = null;
    var RESOLVED = true;
    var REJECTED = false;
    var REJECTED_NO_CATCH = 0;
    function makeResolver(promise, state) {
        return function (v) {
            resolvePromise(promise, state, v);
            // Do not return value or you will break the Promise spec.
        };
    }
    function resolvePromise(promise, state, value) {
        if (promise[symbolState] === UNRESOLVED) {
            if (value instanceof ZoneAwarePromise &amp;&amp; value.hasOwnProperty(symbolState) &amp;&amp;
                value.hasOwnProperty(symbolValue) &amp;&amp; value[symbolState] !== UNRESOLVED) {
                clearRejectedNoCatch(value);
                resolvePromise(promise, value[symbolState], value[symbolValue]);
            }
            else if (isThenable(value)) {
                value.then(makeResolver(promise, state), makeResolver(promise, false));
            }
            else {
                promise[symbolState] = state;
                var queue = promise[symbolValue];
                promise[symbolValue] = value;
                for (var i = 0; i &lt; queue.length;) {
                    scheduleResolveOrReject(promise, queue[i++], queue[i++], queue[i++], queue[i++]);
                }
                if (queue.length == 0 &amp;&amp; state == REJECTED) {
                    promise[symbolState] = REJECTED_NO_CATCH;
                    try {
                        throw new Error('Uncaught (in promise): ' + value +
                            (value &amp;&amp; value.stack ? '\n' + value.stack : ''));
                    }
                    catch (e) {
                        var error_1 = e;
                        error_1.rejection = value;
                        error_1.promise = promise;
                        error_1.zone = Zone.current;
                        error_1.task = Zone.currentTask;
                        _uncaughtPromiseErrors.push(error_1);
                        scheduleQueueDrain();
                    }
                }
            }
        }
        // Resolving an already resolved promise is a noop.
        return promise;
    }
    function clearRejectedNoCatch(promise) {
        if (promise[symbolState] === REJECTED_NO_CATCH) {
            promise[symbolState] = REJECTED;
            for (var i = 0; i &lt; _uncaughtPromiseErrors.length; i++) {
                if (promise === _uncaughtPromiseErrors[i].promise) {
                    _uncaughtPromiseErrors.splice(i, 1);
                    break;
                }
            }
        }
    }
    function scheduleResolveOrReject(promise, zone, chainPromise, onFulfilled, onRejected) {
        clearRejectedNoCatch(promise);
        var delegate = promise[symbolState] ? onFulfilled || forwardResolution : onRejected || forwardRejection;
        zone.scheduleMicroTask(source, function () {
            try {
                resolvePromise(chainPromise, true, zone.run(delegate, null, [promise[symbolValue]]));
            }
            catch (error) {
                resolvePromise(chainPromise, false, error);
            }
        });
    }
    var ZoneAwarePromise = (function () {
        function ZoneAwarePromise(executor) {
            var promise = this;
            if (!(promise instanceof ZoneAwarePromise)) {
                throw new Error('Must be an instanceof Promise.');
            }
            promise[symbolState] = UNRESOLVED;
            promise[symbolValue] = []; // queue;
            try {
                executor &amp;&amp; executor(makeResolver(promise, RESOLVED), makeResolver(promise, REJECTED));
            }
            catch (e) {
                resolvePromise(promise, false, e);
            }
        }
        ZoneAwarePromise.toString = function () {
            return 'function ZoneAwarePromise() { [native code] }';
        };
        ZoneAwarePromise.resolve = function (value) {
            return resolvePromise(new this(null), RESOLVED, value);
        };
        ZoneAwarePromise.reject = function (error) {
            return resolvePromise(new this(null), REJECTED, error);
        };
        ZoneAwarePromise.race = function (values) {
            var resolve;
            var reject;
            var promise = new this(function (res, rej) {
                _a = [res, rej], resolve = _a[0], reject = _a[1];
                var _a;
            });
            function onResolve(value) {
                promise &amp;&amp; (promise = null || resolve(value));
            }
            function onReject(error) {
                promise &amp;&amp; (promise = null || reject(error));
            }
            for (var _i = 0, values_1 = values; _i &lt; values_1.length; _i++) {
                var value = values_1[_i];
                if (!isThenable(value)) {
                    value = this.resolve(value);
                }
                value.then(onResolve, onReject);
            }
            return promise;
        };
        ZoneAwarePromise.all = function (values) {
            var resolve;
            var reject;
            var promise = new this(function (res, rej) {
                resolve = res;
                reject = rej;
            });
            var count = 0;
            var resolvedValues = [];
            for (var _i = 0, values_2 = values; _i &lt; values_2.length; _i++) {
                var value = values_2[_i];
                if (!isThenable(value)) {
                    value = this.resolve(value);
                }
                value.then((function (index) { return function (value) {
                    resolvedValues[index] = value;
                    count--;
                    if (!count) {
                        resolve(resolvedValues);
                    }
                }; })(count), reject);
                count++;
            }
            if (!count)
                resolve(resolvedValues);
            return promise;
        };
        ZoneAwarePromise.prototype.then = function (onFulfilled, onRejected) {
            var chainPromise = new this.constructor(null);
            var zone = Zone.current;
            if (this[symbolState] == UNRESOLVED) {
                this[symbolValue].push(zone, chainPromise, onFulfilled, onRejected);
            }
            else {
                scheduleResolveOrReject(this, zone, chainPromise, onFulfilled, onRejected);
            }
            return chainPromise;
        };
        ZoneAwarePromise.prototype.catch = function (onRejected) {
            return this.then(null, onRejected);
        };
        return ZoneAwarePromise;
    }());
    // Protect against aggressive optimizers dropping seemingly unused properties.
    // E.g. Closure Compiler in advanced mode.
    ZoneAwarePromise['resolve'] = ZoneAwarePromise.resolve;
    ZoneAwarePromise['reject'] = ZoneAwarePromise.reject;
    ZoneAwarePromise['race'] = ZoneAwarePromise.race;
    ZoneAwarePromise['all'] = ZoneAwarePromise.all;
    var NativePromise = global[__symbol__('Promise')] = global['Promise'];
    global['Promise'] = ZoneAwarePromise;
    function patchThen(NativePromise) {
        var NativePromiseProtototype = NativePromise.prototype;
        var NativePromiseThen = NativePromiseProtototype[__symbol__('then')] =
            NativePromiseProtototype.then;
        NativePromiseProtototype.then = function (onResolve, onReject) {
            var nativePromise = this;
            return new ZoneAwarePromise(function (resolve, reject) {
                NativePromiseThen.call(nativePromise, resolve, reject);
            })
                .then(onResolve, onReject);
        };
    }
    if (NativePromise) {
        patchThen(NativePromise);
        if (typeof global['fetch'] !== 'undefined') {
            var fetchPromise = void 0;
            try {
                // In MS Edge this throws
                fetchPromise = global['fetch']();
            }
            catch (e) {
                // In Chrome this throws instead.
                fetchPromise = global['fetch']('about:blank');
            }
            // ignore output to prevent error;
            fetchPromise.then(function () { return null; }, function () { return null; });
            if (fetchPromise.constructor != NativePromise &amp;&amp;
                fetchPromise.constructor != ZoneAwarePromise) {
                patchThen(fetchPromise.constructor);
            }
        }
    }
    // This is not part of public API, but it is usefull for tests, so we expose it.
    Promise[Zone.__symbol__('uncaughtPromiseErrors')] = _uncaughtPromiseErrors;
    /*
     * This code patches Error so that:
     *   - It ignores un-needed stack frames.
     *   - It Shows the associated Zone for reach frame.
     */
    var FrameType;
    (function (FrameType) {
        /// Skip this frame when printing out stack
        FrameType[FrameType["blackList"] = 0] = "blackList";
        /// This frame marks zone transition
        FrameType[FrameType["transition"] = 1] = "transition";
    })(FrameType || (FrameType = {}));
    var NativeError = global[__symbol__('Error')] = global.Error;
    // Store the frames which should be removed from the stack frames
    var blackListedStackFrames = {};
    // We must find the frame where Error was created, otherwise we assume we don't understand stack
    var zoneAwareFrame;
    global.Error = ZoneAwareError;
    // How should the stack frames be parsed.
    var frameParserStrategy = null;
    var stackRewrite = 'stackRewrite';
    // fix #595, create property descriptor
    // for error properties
    var createProperty = function (props, key) {
        // if property is already defined, skip it.
        if (props[key]) {
            return;
        }
        // define a local property
        // in case error property is not settable
        var name = __symbol__(key);
        props[key] = {
            configurable: true,
            enumerable: true,
            get: function () {
                // if local property has no value
                // use internal error's property value
                if (!this[name]) {
                    var error_2 = this[__symbol__('error')];
                    if (error_2) {
                        this[name] = error_2[key];
                    }
                }
                return this[name];
            },
            set: function (value) {
                // setter will set value to local property value
                this[name] = value;
            }
        };
    };
    // fix #595, create property descriptor
    // for error method properties
    var createMethodProperty = function (props, key) {
        if (props[key]) {
            return;
        }
        props[key] = {
            configurable: true,
            enumerable: true,
            writable: true,
            value: function () {
                var error = this[__symbol__('error')];
                var errorMethod = (error &amp;&amp; error[key]) || this[key];
                if (errorMethod) {
                    return errorMethod.apply(error, arguments);
                }
            }
        };
    };
    var createErrorProperties = function () {
        var props = Object.create(null);
        var error = new NativeError();
        var keys = Object.getOwnPropertyNames(error);
        for (var i = 0; i &lt; keys.length; i++) {
            var key = keys[i];
            // Avoid bugs when hasOwnProperty is shadowed
            if (Object.prototype.hasOwnProperty.call(error, key)) {
                createProperty(props, key);
            }
        }
        var proto = NativeError.prototype;
        if (proto) {
            var pKeys = Object.getOwnPropertyNames(proto);
            for (var i = 0; i &lt; pKeys.length; i++) {
                var key = pKeys[i];
                // skip constructor
                if (key !== 'constructor' &amp;&amp; key !== 'toString' &amp;&amp; key !== 'toSource') {
                    createProperty(props, key);
                }
            }
        }
        // some other properties are not
        // in NativeError
        createProperty(props, 'originalStack');
        createProperty(props, 'zoneAwareStack');
        // define toString, toSource as method property
        createMethodProperty(props, 'toString');
        createMethodProperty(props, 'toSource');
        return props;
    };
    var errorProperties = createErrorProperties();
    // for derived Error class which extends ZoneAwareError
    // we should not override the derived class's property
    // so we create a new props object only copy the properties
    // from errorProperties which not exist in derived Error's prototype
    var getErrorPropertiesForPrototype = function (prototype) {
        // if the prototype is ZoneAwareError.prototype
        // we just return the prebuilt errorProperties.
        if (prototype === ZoneAwareError.prototype) {
            return errorProperties;
        }
        var newProps = Object.create(null);
        var cKeys = Object.getOwnPropertyNames(errorProperties);
        var keys = Object.getOwnPropertyNames(prototype);
        cKeys.forEach(function (cKey) {
            if (keys.filter(function (key) {
                return key === cKey;
            })
                .length === 0) {
                newProps[cKey] = errorProperties[cKey];
            }
        });
        return newProps;
    };
    /**
     * This is ZoneAwareError which processes the stack frame and cleans up extra frames as well as
     * adds zone information to it.
     */
    function ZoneAwareError() {
        // make sure we have a valid this
        // if this is undefined(call Error without new) or this is global
        // or this is some other objects, we should force to create a
        // valid ZoneAwareError by call Object.create()
        if (!(this instanceof ZoneAwareError)) {
            return ZoneAwareError.apply(Object.create(ZoneAwareError.prototype), arguments);
        }
        // Create an Error.
        var error = NativeError.apply(this, arguments);
        this[__symbol__('error')] = error;
        // Save original stack trace
        error.originalStack = error.stack;
        // Process the stack trace and rewrite the frames.
        if (ZoneAwareError[stackRewrite] &amp;&amp; error.originalStack) {
            var frames_1 = error.originalStack.split('\n');
            var zoneFrame = _currentZoneFrame;
            var i = 0;
            // Find the first frame
            while (frames_1[i] !== zoneAwareFrame &amp;&amp; i &lt; frames_1.length) {
                i++;
            }
            for (; i &lt; frames_1.length &amp;&amp; zoneFrame; i++) {
                var frame = frames_1[i];
                if (frame.trim()) {
                    var frameType = blackListedStackFrames.hasOwnProperty(frame) &amp;&amp; blackListedStackFrames[frame];
                    if (frameType === FrameType.blackList) {
                        frames_1.splice(i, 1);
                        i--;
                    }
                    else if (frameType === FrameType.transition) {
                        if (zoneFrame.parent) {
                            // This is the special frame where zone changed. Print and process it accordingly
                            frames_1[i] += " [" + zoneFrame.parent.zone.name + " => " + zoneFrame.zone.name + "]";
                            zoneFrame = zoneFrame.parent;
                        }
                        else {
                            zoneFrame = null;
                        }
                    }
                    else {
                        frames_1[i] += " [" + zoneFrame.zone.name + "]";
                    }
                }
            }
            error.stack = error.zoneAwareStack = frames_1.join('\n');
        }
        // use defineProperties here instead of copy property value
        // because of issue #595 which will break angular2.
        Object.defineProperties(this, getErrorPropertiesForPrototype(Object.getPrototypeOf(this)));
        return this;
    }
    // Copy the prototype so that instanceof operator works as expected
    ZoneAwareError.prototype = NativeError.prototype;
    ZoneAwareError[Zone.__symbol__('blacklistedStackFrames')] = blackListedStackFrames;
    ZoneAwareError[stackRewrite] = false;
    if (NativeError.hasOwnProperty('stackTraceLimit')) {
        // Extend default stack limit as we will be removing few frames.
        NativeError.stackTraceLimit = Math.max(NativeError.stackTraceLimit, 15);
        // make sure that ZoneAwareError has the same property which forwards to NativeError.
        Object.defineProperty(ZoneAwareError, 'stackTraceLimit', {
            get: function () {
                return NativeError.stackTraceLimit;
            },
            set: function (value) {
                return NativeError.stackTraceLimit = value;
            }
        });
    }
    if (NativeError.hasOwnProperty('captureStackTrace')) {
        Object.defineProperty(ZoneAwareError, 'captureStackTrace', {
            // add named function here because we need to remove this
            // stack frame when prepareStackTrace below
            value: function zoneCaptureStackTrace(targetObject, constructorOpt) {
                NativeError.captureStackTrace(targetObject, constructorOpt);
            }
        });
    }
    Object.defineProperty(ZoneAwareError, 'prepareStackTrace', {
        get: function () {
            return NativeError.prepareStackTrace;
        },
        set: function (value) {
            if (!value || typeof value !== 'function') {
                return NativeError.prepareStackTrace = value;
            }
            return NativeError.prepareStackTrace = function (error, structuredStackTrace) {
                // remove additional stack information from ZoneAwareError.captureStackTrace
                if (structuredStackTrace) {
                    for (var i = 0; i &lt; structuredStackTrace.length; i++) {
                        var st = structuredStackTrace[i];
                        // remove the first function which name is zoneCaptureStackTrace
                        if (st.getFunctionName() === 'zoneCaptureStackTrace') {
                            structuredStackTrace.splice(i, 1);
                            break;
                        }
                    }
                }
                return value.apply(this, [error, structuredStackTrace]);
            };
        }
    });
    // Now we need to populet the `blacklistedStackFrames` as well as find the
    // run/runGuraded/runTask frames. This is done by creating a detect zone and then threading
    // the execution through all of the above methods so that we can look at the stack trace and
    // find the frames of interest.
    var detectZone = Zone.current.fork({
        name: 'detect',
        onInvoke: function (parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source) {
            // Here only so that it will show up in the stack frame so that it can be black listed.
            return parentZoneDelegate.invoke(targetZone, delegate, applyThis, applyArgs, source);
        },
        onHandleError: function (parentZD, current, target, error) {
            if (error.originalStack &amp;&amp; Error === ZoneAwareError) {
                var frames_2 = error.originalStack.split(/\n/);
                var runFrame = false, runGuardedFrame = false, runTaskFrame = false;
                while (frames_2.length) {
                    var frame = frames_2.shift();
                    // On safari it is possible to have stack frame with no line number.
                    // This check makes sure that we don't filter frames on name only (must have
                    // linenumber)
                    if (/:\d+:\d+/.test(frame)) {
                        // Get rid of the path so that we don't accidintely find function name in path.
                        // In chrome the seperator is `(` and `@` in FF and safari
                        // Chrome: at Zone.run (zone.js:100)
                        // Chrome: at Zone.run (http://localhost:9876/base/build/lib/zone.js:100:24)
                        // FireFox: Zone.prototype.run@http://localhost:9876/base/build/lib/zone.js:101:24
                        // Safari: run@http://localhost:9876/base/build/lib/zone.js:101:24
                        var fnName = frame.split('(')[0].split('@')[0];
                        var frameType = FrameType.transition;
                        if (fnName.indexOf('ZoneAwareError') !== -1) {
                            zoneAwareFrame = frame;
                        }
                        if (fnName.indexOf('runGuarded') !== -1) {
                            runGuardedFrame = true;
                        }
                        else if (fnName.indexOf('runTask') !== -1) {
                            runTaskFrame = true;
                        }
                        else if (fnName.indexOf('run') !== -1) {
                            runFrame = true;
                        }
                        else {
                            frameType = FrameType.blackList;
                        }
                        blackListedStackFrames[frame] = frameType;
                        // Once we find all of the frames we can stop looking.
                        if (runFrame &amp;&amp; runGuardedFrame &amp;&amp; runTaskFrame) {
                            ZoneAwareError[stackRewrite] = true;
                            break;
                        }
                    }
                }
            }
            return false;
        }
    });
    // carefully constructor a stack frame which contains all of the frames of interest which
    // need to be detected and blacklisted.
    var detectRunFn = function () {
        detectZone.run(function () {
            detectZone.runGuarded(function () {
                throw new Error('blacklistStackFrames');
            });
        });
    };
    // Cause the error to extract the stack frames.
    detectZone.runTask(detectZone.scheduleMacroTask('detect', detectRunFn, null, function () { return null; }, null));
    return global['Zone'] = Zone;
})(typeof window === 'object' &amp;&amp; window || typeof self === 'object' &amp;&amp; self || global);

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Suppress closure compiler errors about unknown 'Zone' variable
 * @fileoverview
 * @suppress {undefinedVars}
 */
var zoneSymbol = function (n) { return "__zone_symbol__" + n; };
var _global$1 = typeof window === 'object' &amp;&amp; window || typeof self === 'object' &amp;&amp; self || global;
function bindArguments(args, source) {
    for (var i = args.length - 1; i >= 0; i--) {
        if (typeof args[i] === 'function') {
            args[i] = Zone.current.wrap(args[i], source + '_' + i);
        }
    }
    return args;
}


var isNode = (!('nw' in _global$1) &amp;&amp; typeof process !== 'undefined' &amp;&amp;
    {}.toString.call(process) === '[object process]');





var EVENT_TASKS = zoneSymbol('eventTasks');
// For EventTarget
var ADD_EVENT_LISTENER = 'addEventListener';
var REMOVE_EVENT_LISTENER = 'removeEventListener';
function findExistingRegisteredTask(target, handler, name, capture, remove) {
    var eventTasks = target[EVENT_TASKS];
    if (eventTasks) {
        for (var i = 0; i &lt; eventTasks.length; i++) {
            var eventTask = eventTasks[i];
            var data = eventTask.data;
            var listener = data.handler;
            if ((data.handler === handler || listener.listener === handler) &amp;&amp;
                data.useCapturing === capture &amp;&amp; data.eventName === name) {
                if (remove) {
                    eventTasks.splice(i, 1);
                }
                return eventTask;
            }
        }
    }
    return null;
}
function findAllExistingRegisteredTasks(target, name, capture, remove) {
    var eventTasks = target[EVENT_TASKS];
    if (eventTasks) {
        var result = [];
        for (var i = eventTasks.length - 1; i >= 0; i--) {
            var eventTask = eventTasks[i];
            var data = eventTask.data;
            if (data.eventName === name &amp;&amp; data.useCapturing === capture) {
                result.push(eventTask);
                if (remove) {
                    eventTasks.splice(i, 1);
                }
            }
        }
        return result;
    }
    return null;
}
function attachRegisteredEvent(target, eventTask, isPrepend) {
    var eventTasks = target[EVENT_TASKS];
    if (!eventTasks) {
        eventTasks = target[EVENT_TASKS] = [];
    }
    if (isPrepend) {
        eventTasks.unshift(eventTask);
    }
    else {
        eventTasks.push(eventTask);
    }
}
var defaultListenerMetaCreator = function (self, args) {
    return {
        useCapturing: args[2],
        eventName: args[0],
        handler: args[1],
        target: self || _global$1,
        name: args[0],
        invokeAddFunc: function (addFnSymbol, delegate) {
            if (delegate &amp;&amp; delegate.invoke) {
                return this.target[addFnSymbol](this.eventName, delegate.invoke, this.useCapturing);
            }
            else {
                return this.target[addFnSymbol](this.eventName, delegate, this.useCapturing);
            }
        },
        invokeRemoveFunc: function (removeFnSymbol, delegate) {
            if (delegate &amp;&amp; delegate.invoke) {
                return this.target[removeFnSymbol](this.eventName, delegate.invoke, this.useCapturing);
            }
            else {
                return this.target[removeFnSymbol](this.eventName, delegate, this.useCapturing);
            }
        }
    };
};
function makeZoneAwareAddListener(addFnName, removeFnName, useCapturingParam, allowDuplicates, isPrepend, metaCreator) {
    if (useCapturingParam === void 0) { useCapturingParam = true; }
    if (allowDuplicates === void 0) { allowDuplicates = false; }
    if (isPrepend === void 0) { isPrepend = false; }
    if (metaCreator === void 0) { metaCreator = defaultListenerMetaCreator; }
    var addFnSymbol = zoneSymbol(addFnName);
    var removeFnSymbol = zoneSymbol(removeFnName);
    var defaultUseCapturing = useCapturingParam ? false : undefined;
    function scheduleEventListener(eventTask) {
        var meta = eventTask.data;
        attachRegisteredEvent(meta.target, eventTask, isPrepend);
        return meta.invokeAddFunc(addFnSymbol, eventTask);
    }
    function cancelEventListener(eventTask) {
        var meta = eventTask.data;
        findExistingRegisteredTask(meta.target, eventTask.invoke, meta.eventName, meta.useCapturing, true);
        return meta.invokeRemoveFunc(removeFnSymbol, eventTask);
    }
    return function zoneAwareAddListener(self, args) {
        var data = metaCreator(self, args);
        data.useCapturing = data.useCapturing || defaultUseCapturing;
        // - Inside a Web Worker, `this` is undefined, the context is `global`
        // - When `addEventListener` is called on the global context in strict mode, `this` is undefined
        // see https://github.com/angular/zone.js/issues/190
        var delegate = null;
        if (typeof data.handler == 'function') {
            delegate = data.handler;
        }
        else if (data.handler &amp;&amp; data.handler.handleEvent) {
            delegate = function (event) { return data.handler.handleEvent(event); };
        }
        var validZoneHandler = false;
        try {
            // In cross site contexts (such as WebDriver frameworks like Selenium),
            // accessing the handler object here will cause an exception to be thrown which
            // will fail tests prematurely.
            validZoneHandler = data.handler &amp;&amp; data.handler.toString() === '[object FunctionWrapper]';
        }
        catch (e) {
            // Returning nothing here is fine, because objects in a cross-site context are unusable
            return;
        }
        // Ignore special listeners of IE11 &amp; Edge dev tools, see
        // https://github.com/angular/zone.js/issues/150
        if (!delegate || validZoneHandler) {
            return data.invokeAddFunc(addFnSymbol, data.handler);
        }
        if (!allowDuplicates) {
            var eventTask = findExistingRegisteredTask(data.target, data.handler, data.eventName, data.useCapturing, false);
            if (eventTask) {
                // we already registered, so this will have noop.
                return data.invokeAddFunc(addFnSymbol, eventTask);
            }
        }
        var zone = Zone.current;
        var source = data.target.constructor['name'] + '.' + addFnName + ':' + data.eventName;
        zone.scheduleEventTask(source, delegate, data, scheduleEventListener, cancelEventListener);
    };
}
function makeZoneAwareRemoveListener(fnName, useCapturingParam, metaCreator) {
    if (useCapturingParam === void 0) { useCapturingParam = true; }
    if (metaCreator === void 0) { metaCreator = defaultListenerMetaCreator; }
    var symbol = zoneSymbol(fnName);
    var defaultUseCapturing = useCapturingParam ? false : undefined;
    return function zoneAwareRemoveListener(self, args) {
        var data = metaCreator(self, args);
        data.useCapturing = data.useCapturing || defaultUseCapturing;
        // - Inside a Web Worker, `this` is undefined, the context is `global`
        // - When `addEventListener` is called on the global context in strict mode, `this` is undefined
        // see https://github.com/angular/zone.js/issues/190
        var eventTask = findExistingRegisteredTask(data.target, data.handler, data.eventName, data.useCapturing, true);
        if (eventTask) {
            eventTask.zone.cancelTask(eventTask);
        }
        else {
            data.invokeRemoveFunc(symbol, data.handler);
        }
    };
}
function makeZoneAwareRemoveAllListeners(fnName, useCapturingParam) {
    if (useCapturingParam === void 0) { useCapturingParam = true; }
    var symbol = zoneSymbol(fnName);
    var defaultUseCapturing = useCapturingParam ? false : undefined;
    return function zoneAwareRemoveAllListener(self, args) {
        var target = self || _global$1;
        if (args.length === 0) {
            // remove all listeners without eventName
            target[EVENT_TASKS] = [];
            // we don't cancel Task either, because call native eventEmitter.removeAllListeners will
            // will do remove listener(cancelTask) for us
            target[symbol]();
            return;
        }
        var eventName = args[0];
        var useCapturing = args[1] || defaultUseCapturing;
        // call this function just remove the related eventTask from target[EVENT_TASKS]
        findAllExistingRegisteredTasks(target, eventName, useCapturing, true);
        // we don't need useCapturing here because useCapturing is just for DOM, and
        // removeAllListeners should only be called by node eventEmitter
        // and we don't cancel Task either, because call native eventEmitter.removeAllListeners will
        // will do remove listener(cancelTask) for us
        target[symbol](eventName);
    };
}
function makeZoneAwareListeners(fnName) {
    var symbol = zoneSymbol(fnName);
    return function zoneAwareEventListeners(self, args) {
        var eventName = args[0];
        var target = self || _global$1;
        if (!target[EVENT_TASKS]) {
            return [];
        }
        return target[EVENT_TASKS]
            .filter(function (task) { return task.data.eventName === eventName; })
            .map(function (task) { return task.data.handler; });
    };
}
var zoneAwareAddEventListener = makeZoneAwareAddListener(ADD_EVENT_LISTENER, REMOVE_EVENT_LISTENER);
var zoneAwareRemoveEventListener = makeZoneAwareRemoveListener(REMOVE_EVENT_LISTENER);

var originalInstanceKey = zoneSymbol('originalInstance');
// wrap some native API on `window`


function createNamedFn(name, delegate) {
    try {
        return (Function('f', "return function " + name + "(){return f(this, arguments)}"))(delegate);
    }
    catch (e) {
        // if we fail, we must be CSP, just return delegate.
        return function () {
            return delegate(this, arguments);
        };
    }
}
function patchMethod(target, name, patchFn) {
    var proto = target;
    while (proto &amp;&amp; Object.getOwnPropertyNames(proto).indexOf(name) === -1) {
        proto = Object.getPrototypeOf(proto);
    }
    if (!proto &amp;&amp; target[name]) {
        // somehow we did not find it, but we can see it. This happens on IE for Window properties.
        proto = target;
    }
    var delegateName = zoneSymbol(name);
    var delegate;
    if (proto &amp;&amp; !(delegate = proto[delegateName])) {
        delegate = proto[delegateName] = proto[name];
        proto[name] = createNamedFn(name, patchFn(delegate, delegateName, name));
    }
    return delegate;
}
// TODO: support cancel task later if necessary
function patchMacroTask(obj, funcName, metaCreator) {
    var setNative = null;
    function scheduleTask(task) {
        var data = task.data;
        data.args[data.callbackIndex] = function () {
            task.invoke.apply(this, arguments);
        };
        setNative.apply(data.target, data.args);
        return task;
    }
    setNative = patchMethod(obj, funcName, function (delegate) { return function (self, args) {
        var meta = metaCreator(self, args);
        if (meta.callbackIndex >= 0 &amp;&amp; typeof args[meta.callbackIndex] === 'function') {
            var task = Zone.current.scheduleMacroTask(meta.name, args[meta.callbackIndex], meta, scheduleTask, null);
            return task;
        }
        else {
            // cause an error by calling it directly.
            return delegate.apply(self, args);
        }
    }; });
}

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var callAndReturnFirstParam = function (fn) {
    return function (self, args) {
        fn(self, args);
        return self;
    };
};
// For EventEmitter
var EE_ADD_LISTENER = 'addListener';
var EE_PREPEND_LISTENER = 'prependListener';
var EE_REMOVE_LISTENER = 'removeListener';
var EE_REMOVE_ALL_LISTENER = 'removeAllListeners';
var EE_LISTENERS = 'listeners';
var EE_ON = 'on';
var zoneAwareAddListener$1 = callAndReturnFirstParam(makeZoneAwareAddListener(EE_ADD_LISTENER, EE_REMOVE_LISTENER, false, true, false));
var zoneAwarePrependListener = callAndReturnFirstParam(makeZoneAwareAddListener(EE_PREPEND_LISTENER, EE_REMOVE_LISTENER, false, true, true));
var zoneAwareRemoveListener$1 = callAndReturnFirstParam(makeZoneAwareRemoveListener(EE_REMOVE_LISTENER, false));
var zoneAwareRemoveAllListeners = callAndReturnFirstParam(makeZoneAwareRemoveAllListeners(EE_REMOVE_ALL_LISTENER, false));
var zoneAwareListeners = makeZoneAwareListeners(EE_LISTENERS);
function patchEventEmitterMethods(obj) {
    if (obj &amp;&amp; obj.addListener) {
        patchMethod(obj, EE_ADD_LISTENER, function () { return zoneAwareAddListener$1; });
        patchMethod(obj, EE_PREPEND_LISTENER, function () { return zoneAwarePrependListener; });
        patchMethod(obj, EE_REMOVE_LISTENER, function () { return zoneAwareRemoveListener$1; });
        patchMethod(obj, EE_REMOVE_ALL_LISTENER, function () { return zoneAwareRemoveAllListeners; });
        patchMethod(obj, EE_LISTENERS, function () { return zoneAwareListeners; });
        obj[EE_ON] = obj[EE_ADD_LISTENER];
        return true;
    }
    else {
        return false;
    }
}
// EventEmitter
var events;
try {
    events = __webpack_require__(13);
}
catch (err) {
}
if (events &amp;&amp; events.EventEmitter) {
    patchEventEmitterMethods(events.EventEmitter.prototype);
}

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var fs;
try {
    fs = __webpack_require__(14);
}
catch (err) {
}
// watch, watchFile, unwatchFile has been patched
// because EventEmitter has been patched
var TO_PATCH_MACROTASK_METHODS = [
    'access', 'appendFile', 'chmod', 'chown', 'close', 'exists', 'fchmod',
    'fchown', 'fdatasync', 'fstat', 'fsync', 'ftruncate', 'futimes', 'lchmod',
    'lchown', 'link', 'lstat', 'mkdir', 'mkdtemp', 'open', 'read',
    'readdir', 'readFile', 'readlink', 'realpath', 'rename', 'rmdir', 'stat',
    'symlink', 'truncate', 'unlink', 'utimes', 'write', 'writeFile',
];
if (fs) {
    TO_PATCH_MACROTASK_METHODS.filter(function (name) { return !!fs[name] &amp;&amp; typeof fs[name] === 'function'; })
        .forEach(function (name) {
        patchMacroTask(fs, name, function (self, args) {
            return {
                name: 'fs.' + name,
                args: args,
                callbackIndex: args.length > 0 ? args.length - 1 : -1,
                target: self
            };
        });
    });
}

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
function patchTimer(window, setName, cancelName, nameSuffix) {
    var setNative = null;
    var clearNative = null;
    setName += nameSuffix;
    cancelName += nameSuffix;
    var tasksByHandleId = {};
    function scheduleTask(task) {
        var data = task.data;
        data.args[0] = function () {
            task.invoke.apply(this, arguments);
            delete tasksByHandleId[data.handleId];
        };
        data.handleId = setNative.apply(window, data.args);
        tasksByHandleId[data.handleId] = task;
        return task;
    }
    function clearTask(task) {
        delete tasksByHandleId[task.data.handleId];
        return clearNative(task.data.handleId);
    }
    setNative =
        patchMethod(window, setName, function (delegate) { return function (self, args) {
            if (typeof args[0] === 'function') {
                var zone = Zone.current;
                var options = {
                    handleId: null,
                    isPeriodic: nameSuffix === 'Interval',
                    delay: (nameSuffix === 'Timeout' || nameSuffix === 'Interval') ? args[1] || 0 : null,
                    args: args
                };
                var task = zone.scheduleMacroTask(setName, args[0], options, scheduleTask, clearTask);
                if (!task) {
                    return task;
                }
                // Node.js must additionally support the ref and unref functions.
                var handle = task.data.handleId;
                if (handle.ref &amp;&amp; handle.unref) {
                    task.ref = handle.ref.bind(handle);
                    task.unref = handle.unref.bind(handle);
                }
                return task;
            }
            else {
                // cause an error by calling it directly.
                return delegate.apply(window, args);
            }
        }; });
    clearNative =
        patchMethod(window, cancelName, function (delegate) { return function (self, args) {
            var task = typeof args[0] === 'number' ? tasksByHandleId[args[0]] : args[0];
            if (task &amp;&amp; typeof task.type === 'string') {
                if (task.cancelFn &amp;&amp; task.data.isPeriodic || task.runCount === 0) {
                    // Do not cancel already canceled functions
                    task.zone.cancelTask(task);
                }
            }
            else {
                // cause an error by calling it directly.
                delegate.apply(window, args);
            }
        }; });
}

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var set = 'set';
var clear = 'clear';
var _global = typeof window === 'object' &amp;&amp; window || typeof self === 'object' &amp;&amp; self || global;
// Timers
var timers = __webpack_require__(21);
patchTimer(timers, set, clear, 'Timeout');
patchTimer(timers, set, clear, 'Interval');
patchTimer(timers, set, clear, 'Immediate');
var shouldPatchGlobalTimers = global.setTimeout !== timers.setTimeout;
if (shouldPatchGlobalTimers) {
    patchTimer(_global, set, clear, 'Timeout');
    patchTimer(_global, set, clear, 'Interval');
    patchTimer(_global, set, clear, 'Immediate');
}
patchNextTick();
// Crypto
var crypto;
try {
    crypto = __webpack_require__(12);
}
catch (err) {
}
// TODO(gdi2290): implement a better way to patch these methods
if (crypto) {
    var nativeRandomBytes_1 = crypto.randomBytes;
    crypto.randomBytes = function randomBytesZone(size, callback) {
        if (!callback) {
            return nativeRandomBytes_1(size);
        }
        else {
            var zone = Zone.current;
            var source = crypto.constructor.name + '.randomBytes';
            return nativeRandomBytes_1(size, zone.wrap(callback, source));
        }
    }.bind(crypto);
    var nativePbkdf2_1 = crypto.pbkdf2;
    crypto.pbkdf2 = function pbkdf2Zone() {
        var args = [];
        for (var _i = 0; _i &lt; arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var fn = args[args.length - 1];
        if (typeof fn === 'function') {
            var zone = Zone.current;
            var source = crypto.constructor.name + '.pbkdf2';
            args[args.length - 1] = zone.wrap(fn, source);
            return nativePbkdf2_1.apply(void 0, args);
        }
        else {
            return nativePbkdf2_1.apply(void 0, args);
        }
    }.bind(crypto);
}
// HTTP Client
var httpClient;
try {
    httpClient = __webpack_require__(10);
}
catch (err) {
}
if (httpClient &amp;&amp; httpClient.ClientRequest) {
    var ClientRequest_1 = httpClient.ClientRequest.bind(httpClient);
    httpClient.ClientRequest = function (options, callback) {
        if (!callback) {
            return new ClientRequest_1(options);
        }
        else {
            var zone = Zone.current;
            return new ClientRequest_1(options, zone.wrap(callback, 'http.ClientRequest'));
        }
    };
}
function patchNextTick() {
    var setNative = null;
    function scheduleTask(task) {
        var args = task.data;
        args[0] = function () {
            task.invoke.apply(this, arguments);
        };
        setNative.apply(process, args);
        return task;
    }
    setNative =
        patchMethod(process, 'nextTick', function (delegate) { return function (self, args) {
            if (typeof args[0] === 'function') {
                var zone = Zone.current;
                var task = zone.scheduleMicroTask('nextTick', args[0], args, scheduleTask);
                return task;
            }
            else {
                // cause an error by calling it directly.
                return delegate.apply(process, args);
            }
        }; });
}

})));


/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 7 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_7__;

/***/ }),
/* 8 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_8__;

/***/ }),
/* 9 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_9__;

/***/ }),
/* 10 */
/***/ (function(module, exports) {

if(typeof __WEBPACK_EXTERNAL_MODULE_10__ === 'undefined') {var e = new Error("Cannot find module \"_http_client\""); e.code = 'MODULE_NOT_FOUND'; throw e;}
module.exports = __WEBPACK_EXTERNAL_MODULE_10__;

/***/ }),
/* 11 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_11__;

/***/ }),
/* 12 */
/***/ (function(module, exports) {

if(typeof __WEBPACK_EXTERNAL_MODULE_12__ === 'undefined') {var e = new Error("Cannot find module \"crypto\""); e.code = 'MODULE_NOT_FOUND'; throw e;}
module.exports = __WEBPACK_EXTERNAL_MODULE_12__;

/***/ }),
/* 13 */
/***/ (function(module, exports) {

if(typeof __WEBPACK_EXTERNAL_MODULE_13__ === 'undefined') {var e = new Error("Cannot find module \"events\""); e.code = 'MODULE_NOT_FOUND'; throw e;}
module.exports = __WEBPACK_EXTERNAL_MODULE_13__;

/***/ }),
/* 14 */
/***/ (function(module, exports) {

if(typeof __WEBPACK_EXTERNAL_MODULE_14__ === 'undefined') {var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e;}
module.exports = __WEBPACK_EXTERNAL_MODULE_14__;

/***/ }),
/* 15 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_15__;

/***/ }),
/* 16 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_16__;

/***/ }),
/* 17 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_17__;

/***/ }),
/* 18 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_18__;

/***/ }),
/* 19 */,
/* 20 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_20__;

/***/ }),
/* 21 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_21__;

/***/ }),
/* 22 */,
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(4);
__webpack_require__(5);
module.exports = __webpack_require__(2);


/***/ })
/******/ ]);</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-angularGeneric.html">angularGeneric</a></li></ul><h3>Classes</h3><ul><li><a href="module-angularGeneric.AbstractItemsComponent.html">AbstractItemsComponent</a></li><li><a href="module-angularGeneric.AbstractResolver.html">AbstractResolver</a></li><li><a href="module-angularGeneric-_class3._class3.html">_class3</a></li><li><a href="module-angularGeneric-_class8._class8.html">_class8</a></li><li><a href="module-angularGeneric-_class21._class21.html">_class21</a></li><li><a href="module-angularGeneric-_class22._class22.html">_class22</a></li><li><a href="module-angularGeneric-_class25._class25.html">_class25</a></li><li><a href="module-angularGeneric-_class28._class29._class29.html">_class29</a></li><li><a href="module-angularGeneric-_class31._class31.html">_class31</a></li><li><a href="module-angularGeneric-_class34._class34.html">_class34</a></li><li><a href="module-angularGeneric-_class35._class36._class36.html">_class36</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Tue Jan 31 2017 23:55:51 GMT+0100 (CET)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
